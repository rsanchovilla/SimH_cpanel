
;*              I/O Package Configuraton for SimH SWTPC 6800 Simulator
;*              should work on real hw too

;*              (C) Roberto Sancho, Jun 2022
;*              based on SSB I/O Package

;*              features implemented: 
;                            mapalg: Only supports mapping algorith 0001
;                            I/O Implemented using active wait (no interruption based)
;                            no clock interrupt
;                            no vt terminal driver. Just a minimal subset
;                                              BackSpace, Tab (converted to 8 spaces) 
;                                              ^C to discard current input 
;                                              ^C^C to kill current program
;                                              <CR> is the only activation key allowed (cannot be changed)
;                                              ^Z to signal end of file
;                                              ^D to call monitor, J A080 to return to SDOS
;                                              basic debug keys ^B, ^T, ^G, ^V
;                            support for 4 floppy disk
;                            only supported disk geometry: 5'25 floppy 2 sides x 35tr x 18 sec x 128 bytes
;                            supports for HLE 5MB Hard Disk
;                            PORT: device to read from PTR/punch to PTP
;                           

NDRIVES		equ	4
NIOCHANNELS	equ 	16+3	; number of files that can be opened at same time

				; SWTBUG ROM entry points

		; conditional assembly for SWTPC with 64K ram and
		; I/O address at FF00..FF1F instead of 8000..801F		

	     if	ram64k=1

				; Memory Map
				; 0000..B3FF User RAM (46080 BYTES = 45 kB)
DRIVERBASE      set 	$B400	; B400..BFFF SDOS I/O Driver for SWTPC 6800 
IOBUF 		EQU	$C080	; C080..CDFF BUFFERS FOR I/O DRIVER
IOBUFEND	EQU	$CE00
SDOS            EQU     $CE00	; CE00..EFFF SDOS Operating System (64K compile version)
				; FF00..FF1F IO MAPED MEMORY
IRQVECTOR 	equ	$FFF8 	; IRQ VECTOR IN HIGH MEM IS RAM

	      else
				; Memory Map
				; 0000..6FFF User RAM
DRIVERBASE      EQU     $7000	; 7000..7FFF SDOS I/O Driver for SWTPC 6800
				; 8000..9FFF IO MAPED MEMORY
				; A000..A07F 6810 RAM (128 BYTES), used by SWTBUG ROM
IOBUF 		EQU	$A080	; A080..ADFF BUFFERS FOR I/O DRIVER
IOBUFEND	EQU	$AE00	;
SDOS            EQU     $AE00	; AE00..DFFF SDOS Operating System (56K compile version)
				; E000..E7FF SWTBUG ROM
				; E800..FFFF EPROM

OUTEEE		EQU	$E1D1	; OUTPUT A CHAR USING SWTPC 6800 SWTBUG ROM
INEEE		equ	$E1AC	; INPUT A CHAR (BLOCKING) USING SWTPC 6800 SWTBUG ROM
SWTMON		EQU 	$E0D0	; SWTBUG COLD START ENTRY POINT
RDON		equ	$E334+3	; reader on (skip echo setting in rom)
RDOFF		equ	$E347 	; reader off
PNCHON		equ	$E34d 	; punch on 
PNCHOFF		equ	$E353 	; punch off
PORECH		equ	$A00C 	; swtbug echo flag (=0 -> echo, $FF -> no echo)
IRQVECTOR 	equ	$A000	; ON SWTBUG, A000=IRQ VECTOR IN RAM

	     fin


;*              Fill in the SDOS-TO-IOPACKAGE COMMUNICATION REGION

                ORG     SDOS

                FCB     $11                  ; SDOS:VERSIONNUMBER	SDOS VERSION NUMBER (=$AE00)
                FDB     0                    ; SDOS:LASTERROR		LAST ERROR ENCOUNTERED
                FDB     CNFGTABLE            ; SDOS:CONFIGURATION	TELL SDOS WHERE ALL THE GOODIES ARE
                FDB     0                    ; SDOS:SERIALNUMBER	SERIAL NUMBER
                FDB     0                    ; SDOS:IOBLOCKPTR		IOBLOCKPTR
                FDB     0                    ; SDOS:IOCBPOINTER		IOCB POINTER (FOR FILE-TYPE DEVICE DRIVERS)
                FCB     0,0,0                ; SET CLOCK TO "MIDNITE"
                FCB     16                   ; DAY, LET COMMAND INTERPRETER KNOW
                FCB     8                    ; MONTH, THAT THE TIME HASN'T BEEN SET
                FCB     $82                  ; YEAR 


;* patches SDOSINIT AND SDOS O/S

OFS		EQU	SDOS-$AE00	; Offset for pathing (0=for 56k compile)

	     if	ram64k=1		
	     	; No need to apply any patch to loaded SDOS11G64K file. It is generated by 
		; assembling SDOS11G.ASM and has already been edited to disable all the checksum/serial number
		; validations
	     else
		; patch the loaded original unmodified SDOS11G56K file, it is the build
	     	; for 56K RAM machine that comes from CHM and is generated by 
	     	; assembling SDOS11GPART1.ASM and SDOS11GPART2.ASM and 	  

		ORG $2027
		NOP		; SKIP CHECKSUM VERIFICATION. WILL NOT WORK BECAUSE
		NOP		; SDOS IS BEING PATCHED AND ... WE TRUST THE HW!
		ORG $23E9
		NOP		; REMOVE STACK MESSED UP IF START CODE CHECKSUM
		NOP		; IS NOT ZERO BECAUSE IT HAS BEEN PATCHED, AS WE ARE DOING NOW!
		ORG $2031
		NOP		; PATCH ROM SERIAL NUMBER CHECHING TO DO NOTHING
		NOP
		ORG $217A
		RTS		; INMEDIATE RETURN ON CALL TO WRITERANDOM (DO NOT CHECK)
		ORG $B00F+OFS
		DES		; PATCH SAFEGUARD ROUTINE TO ITS FINAL FORM
		INS		; AS IF IT WAS SET-UP BY SERIALNUMBER.SYS 
		RTS		; THIS ALLOWS TO BYPASS SERIALNUMBER.SYS EXECUTION
		RTI
		RTI
		RTI
		RTI
		ORG $B408+OFS
		LDAA #$01	; SET CHECKSUM ON COPYRIGHT STRING AS ALLWAYS OK
		ORG $DD82+OFS
		NOP		; PATCH TASK USER STACK POINTER 
		NOP		; SO IT NOT GET MESSED UP IF CHECKSUM DOES NOT MATCH
		NOP
		NOP
		NOP
		NOP
		ORG $B844+OFS	; PATCH SerialNumberLocation to Point to SerialNumber 
		FDB $FFF0
		ORG $B837+OFS	; PATCH EXITCKSUML ROUTINE TO IGNORE CHECKSUM
		CLRA
		ORG $C6F1+OFS  	; PATCH ERRBOOTCKSUMFAIL, SO BOOT CHECKSUM IS IGNORED
		NOP
		NOP
		ORG $2138	; PATCH TO ALLOW LOAD A NON-ENCRYPTED SERIALNUMBER.SYS (OR WAHTERES IS THE FIRST PROGRAM TO RUN)
		NOP
		NOP
		ORG $2736	; PATH  FCC "SERIALNUMBER.SYS" FILENAME
		FCC "DEFAULTPROGRAM  "
                                ; INSTEAD OF RUNNING SERIALNUMBER.SYS ON STARTUP
		                ; JUST RUN DEFAULTPROGRAM (HOPEFULLY BEING A COPY 
		                ; OF SDOS USER COMMAND PROCESSOR)
	      fin
	      
		ORG $2000	; PATCH MAIN ENTRY POINT TO SET-UP PROPERLY 
		JMP SWTPCINIT	; DRIVER MEM
		
SDOS.IOBLOCKPTR EQU $07		; POINTER TO I/O REQUEST (PASSED TO DRIVERS)
SDOS.RTI	equ $15		; JMP TO "RETURN FROM INTERRUPT; NO EVENT"
SDOS.ERROR	equ $2D		; ERROR SUBROUTINE; INLINE 2 BYTE ERROR CODE 
SDOS.ERRORSAVE	equ $30		; ERROR CODE SAVE ROUTINE; SAVES (X) AS ERROR CODE 
SDOS.ERRORED	equ $33		; "ERROR CAN'T BE HANDLED BY ME" ENTRY 
SDOS.WAITEVENT	equ $2A		; JMP TO WAIT FOR EVENT SELECTED BY (X)
SDOS.CHECKRDLEN EQU $36
SDOS.CLOCK	EQU $0B

SCBLK.OPCODE	equ $00		; PRIMARY SYSCALL FUNCTION (OPEN, READ, ETC.)    
SCBLK.WLEN	equ $01		; WAIT FLAG BIT (0=WAIT) AND SYSCALL BLOCK LENGTH (0..127)      
SCBLK.PARAMS	equ $02		; PARAMETER BYTES TO OPCODE (SECONDARY OPCODE, CHANNEL #)    
SCBLK.WRBUF	equ $04		; POINTER TO WRITE DATA BUFFER     
SCBLK.WRLEN	equ $06		; NUMBER OF BYTES IN WRITE DATA BUFFER
SCBLK.RPLEN	equ $08		; LENGTH OF REPLY (RESULT OF SYSCALL)    
SCBLK.RDBUF	equ $0A		; POINTER TO READ DATA BUFFER (WHERE RESULT GOES)     
SCBLK.RDLEN	equ $0C		; CEILING ON SIZE OF REPLY (READ DATA BUFFER)
SCBLK.DATA	EQU $0E		; OTHER PARAMETERS FOR SYSCALL; UP TO 127-12 BYTES
 
SPECIALFN.CLEAR	equ $0082            
SPECIALFN.EEOL	equ $0083            
SPECIALFN.POSN	equ $0081

DSKINFO.SECTORDB	EQU $2B
DSKINFO.OPSCOUNT	equ $3c


FCB.SIZE	equ $001A
IOCB.SIZE	EQU $0022
NMAGICFCBS	EQU	2	; FOR ERRMSGFCB, SYSFCB


;*
;*	device errors 
;*
ERR.EOFHIT			EQU 1001
ERR.ILLDEVICEOP			equ 1034
err.programkilled		EQU 1041
ERR.DEVICETIMEDOUT		equ 1042
ERR.DISKREAD			equ 1045
ERR.DISKWRITE			equ 1046
ERR.DISKSEEK			equ 1047
ERR.DSKWRTPROT			equ 1048                  
ERR.DEVICENOTREADY		equ 1060
ERR.WRONGDISKTYPE		equ 1902
ERR.ACTIVATIONNOTINBUFFER	EQU 1907
err.activationreceived		equ 1909

;*
;*	DEVICE CONTROL BLOCK DISPLACEMENTS
;*
DCB.DONEFLAG	EQU	0	; 0 --> DEVICE IS BUSY; <>0 --> DEVICE IS DONE
DCB.LASTERROR	equ	1	; IF DCB IS DONE, CONTAINS ERROR STATUS (0 = NONE )
DCB.NAME	EQU	3	; POINTER TO DEVICE NAME STRING TERMINATED BY ZERO BYTE
DCB.NEXTDCB	EQU	5	; POINTER TO NEXT DCB IN LIST OR ZERO
DCB.DRIVER	EQU	7	; POINTER TO DRIVER ENTRY POINT LIST
dcb.fdunit	equ	$43               	

dcb.oilquiescent	equ	$13
dcb.profile		equ	$28
dcb.ringinbase		equ  	$4d
dcb.ringoutbase		equ 	$59
dcb.ringoutthreshold	equ 	$5d
dcb.linebuf		equ 	$67
dcb.linebuflen		equ	$7a
DCB.TLBUFFER		equ 	$7D
dcb.outputtoblk 	equ     $a1
dcb.inputtoblk  	equ     $a9
dcb.tcb			equ     $b1
dcb.taskstack		equ     $b3
DCB.RESET       	EQU     $B5
dcb.clearin		equ	$ca
dcb.vtsize		equ	$fd

DCBPOINTER		EQU	$06	; POINTER TO DEVICE CONTROL BLOCK


DVTYP.TYPE		EQU	$00
DVTYP.CLOCK		EQU	$0B
DVTYP.STAPE		equ	$02

RDSI.DISKINFO		EQU	$00
RDSI.LSN		EQU	$02  
RDSI.SECTORBASE		EQU	$05           
RDSI.FLINK		EQU	$07                 
RDSI.BLINK		EQU	$09                 
RDSI.MODIFIED		EQU	$0B             
RDSI.STATE		EQU	$0C                 
RDSI.RETRYCOUNT		EQU	$0D            
RDSI.SECTOR		EQU	$0E
RDSI.TRACK		EQU	$10                
RDSI.CYLINDER		EQU	$12             
RDSI.SIZE		EQU	$14 

RDSISTATE.IDLE		EQU	$00
RDSISTATE.READING	EQU	$01         
RDSISTATE.VERIFYING	EQU	$03        
RDSISTATE.WRITING	EQU	$02         

CC.DISMOUNTDISK		EQU	$11	; DEVICE CONTROL OPS: DISMOUNT THE DISK
cc.activationck		EQU	$1D
CC.ECHO			EQU	$10
CC.NOECHO		EQU	$11
cc.SETACTBLOCK		EQU	$14


SC.GETTYPE		EQU	$04
SC.GETLINEFLAGS		EQU	$2C
SC.GETCOL		equ	$01
sc.geteof		equ	$02

SYSCALL.OPEN		EQU	$00
SYSCALL.CREATE		EQU	$01            
SYSCALL.CLOSE		EQU	$02
SYSCALL.RENAME		EQU	$03
SYSCALL.DELETE		EQU	$04            
SYSCALL.CHAIN		EQU	$06             
SYSCALL.READA		EQU	$0A             
SYSCALL.READB		EQU	$0B             
SYSCALL.WRITEA		EQU	$0C
SYSCALL.WRITEB		EQU	$0D             
SYSCALL.CONTROL		EQU	$0E           
SYSCALL.STATUS		EQU	$0F            
SYSCALL.EXIT		EQU	$11              
SYSCALL.ERROREXIT	EQU	$12         
SYSCALL.SETERROR	EQU	$13
SYSCALL.GETERROR	EQU	$14
SYSCALL.DISPERROR	EQU	$15
SYSCALL.DEBUG		EQU	$18             

GOBIT			EQU	$08	; GO FROM BREAKPOINT/SINGLE STEP
SSTEPBIT		EQU	$10	; SINGLE STEP REQUEST
BREAKBIT		EQU	$20	; REQUEST LINE NUMBER BREAKPOINT
TRACEBIT		EQU	$40	; REQUEST LINE NUMBER TRACE
ABORTBIT		EQU	$80	; REQUEST PROGRAM ABORT

;*
;* ONE TIME START-UP INITIALIZATION 
;* FOR SWTPC 6800. NEEDED BECAUSE 
;* WE MUST INIT FCB/IOCBS TO ZERO
;* WE MUST SET UP IOCBPOINTERS PROPERLY

			ORG 	$3000

SWTPCINIT	LDX	#FCBS		; FCB/IOCBS TO ZERO
SINIT1		CLR	0,X
		INX
		CPX	#IOCBPOINTERS	
		BNE 	SINIT1	
		LDAA	#(IOCBS/256)	; SET UP IOCBPOINTERS PROPERLY
		LDAB	#(IOCBS&$FF)	; EACH IOCBPOINTER POINTS TO
SINIT2		STAA	0,X		; THE CORRESPONDING IOCB
		STAB	1,X
		ADDB	#(IOCB.SIZE&$FF)
		ADCA	#(IOCB.SIZE/256)
		INX
		INX
		CPX	#INTERRUPTSTACK
		BNE	SINIT2
		CLR	BASICDEBUGFLAGS
		; INIT DONE, RETURN TO SDOSINIT	
		LDX  	$AE03+OFS	; $AE03=CODE+SDOS:CONFIGURATION	GET THE STACK POINTER
		JMP	$2003

;*		BUFFERS FOR I/O DRIVER
;*		MUST BE INITIALIZED!

		ORG	IOBUF 		; A080..AE00 

	     if	ram64k=1
	     	; ^D not available on RAM64K. SWTBUG ROM not present
	     else
swtgo		jmp 	swtret		; return address from SWTBUG MONITOR
					; ^D -> enter to monitor, JA080 | JE480 return to sdos
	     fin
BASICDEBUGFLAGS	fcb     0	 	; set basic debug flags  A083 | E483


FCBS    	RMB     FCB.SIZE*(NIOCHANNELS+2*NDRIVES+NMAGICFCBS)	; MUST PRECEDE IOCBS
IOCBS   	RMB     IOCB.SIZE*NIOCHANNELS
IOCBPOINTERS	RMB	NIOCHANNELS*2
INTERRUPTSTACK  RMB	$40	; STACK SPACE FOR INTERRUPT ROUTINES
INTSTACKTOP	FCB     0
DSKBUFFERPOOL	fcb     0
DSKPOOLSIZE	equ     IOBUFEND-DSKBUFFERPOOL-2

                ORG     DRIVERBASE      

				; THIS IS CODE+SDOS:CONFIGURATION ADDRESS				; 

SYSCALLIO       JMP     SYSCALLIO	; SDOS SETS JMP ADDR TO ITS ENTRY POINT

CNFGTABLE       FDB     DISKDCBS	; CNFG:DISKDCBS		DEFAULT DISK MUST BE FIRST
                FDB     DCB.TTY		; CNFG:DEVICEDCBS		CONSOLE MUST BE FIRST
                FDB     IOCBPOINTERS	; CNFG:IOCBPOINTERS	POINTER LIST TO IOCB'S
                FCB     NIOCHANNELS	; CNFG:NIOCHANNELS	NUMBER OF I/O CHANNELS
                FDB     DSKBUFFERPOOL	; CNFG:DSKBUFFERPOOL	POINTER TO THE DISK BUFFER POOL
                FDB     DSKPOOLSIZE	; CNFG:DSKPOOLSIZE	SIZE OF THE BUFFER POOL
                FDB     ATTNCHECK	; CNFG:ATTNCHECK	ADDRESS OF ATTENTION CHECK ROUTINE
                FDB     DEBUGSYSCALL	; CNFG:DEBUGGER	RMB	ADDRESS OF DEBUGGER (0 IF NONE)
                FDB     DRIVERBASE	; CNFG:DRIVERBASE	LOWEST ADDRESS USED BY DRIVERS = END OF USER RAM
                FDB     INTSETUP	; CNFG:INTSETUP		POINTER TO INTERRUPT SYSTEM SETUP ROUTINE
		JMP	INTDISABLE	; CNFG:INTDISABLE	SUBROUTINE (OR "JMP") TO DISABLE ALL INTERRUPTS
		JMP	INTENABLE	; CNFG:INTENABLE	SUBROUTINE (OR "JMP") TO ENABLE ALL INTERRUPTS
		JMP	INTRTI		; CNFG:INTRTI		CODE TO ENABLE PRIORITY INTERRUPT AND DO RTI (USUALLY JUST "RTI")
		FDB	INTSTACKTOP	; CNFG:INTERRUPTSTACK	POINTER TO LAST BYTE OF INTERRUPT STACK SPACE
		FDB	IOINTPOLL	; CNFG:IOINTPOLL	POINTER TO I/O INTERRUPT SERVICE DEVICE POLL ROUTINE
		FDB	TASKQUEUE	; CNFG:TASKQUEUE	POINTER TO FIRST TASK IN TASK QUEUE
		FDB	TIMEOUTQUEUE	; CNFG:TIMEOUTLIST	POINTER TO CHAINED LIST OF TIMEOUT BLOCKS


INTSETUP	LDX #IRQINT
		STX IRQVECTOR 		; ON SWTBUG, A000=IRQ VECTOR IN RAM
		JSR INTDK		; INIT THE DISK SYSTEM
		ldx	#InputBuf	; init Input buf head and and pointerd
		stx	InputBufP0	; to set as no chars has been typed yet (empty buf)
		stx	InputBufP1
		RTS
INTDISABLE	SEI
		RTS
INTENABLE	CLI
		RTS
IRQINT		NOP
INTRTI  	RTI     

IOINTPOLL	CLRA
		; LDA $8xxx			; No MP-T TIMER INTERRUPT
		RORA
		BCC	NOTIMERINT
		; LDX 	#CLOCKDCB
		; JMP	CLOCKSTATE
NOTIMERINT	LDX     BADINTERRUPTCOUNT 	; CAN'T FIGURE OUT WHO IT IS...
		INX				; BUMP CRAZY INTERRRUPT COUNTER
		STX     BADINTERRUPTCOUNT   
		JMP     SDOS+SDOS.RTI 		; AND HOPE IT WENT AWAY !   

BADINTERRUPTCOUNT       FDB     0      		; # OF INTERRUPTS FROM UNKNOWN DEVICES

TIMEOUTQUEUE	FDB	0			; TIMEOUT:LINK		POINTER TO NEXT TIMEOUTBLOCK
		FDB     0       		; TIMEOUT:FUSE. 	16 BIT TIMEOUT COUNT (1/60 SEC UNITS); 0--> NO TIMEOUT
		FDB     FUSEBURNEDUP   		; TIMEOUT:ROUTINE	POINTER TO TIMEOUT INTERRUPT ROUTINE FOR DEVICE
		FDB	DCB.TTY			; TIMEOUT:DCB		POINTER TO DCB BEING TIMED OUT

FUSEBURNEDUP	NOP
		; BSR     ABORTQUANTUM
		JMP     SDOS+SDOS.RTI

IGN		EQU  	0			; IGNORE VALUE

TASKQUEUE	FDB	0			; TCB:LNK		POINTER TO NEXT TCB IN QUEUE
		FDB	TASKSTACKINIT		; TCB:STACK		STACK POINTER FOR TASK
		FDB	0			; TCB:COND		TASK'S WAKE UP ROUTINE
		FDB	0			; TCB:PARAM		PARAMETER TO TCB:COND ROUTINE
		FCB	0,0,0,0,0,0,0,0		; TCB:SCRATCHPAD	SPACE FOR TASK'S SCRATCHPAD (LOCATIONS 0-7)
		FDB	DCB.TTY			
		RMB	10
TASKSTACKINIT	FCB	0,0,IGN,IGN,IGN,IGN	; ZERO CC SO INTERRUPTS ARE ENABLED
		FDB	TASKSETUP		; INITIAL PC OF FIRST TASK
TASKSTACKTOP	FCB 	0		
TASKWAKEUPFLAG	FCB	0			; TASK IS SLEEPING
TASKSETUP 	LDX	#TASKWAKEUPFLAG
		JSR	SDOS+SDOS.WAITEVENT	; WAIT FOR EVENT (X) TO GO NON-ZERO
		BRA	TASKSETUP


; DEVICE CONTROL BLOCK FOR TTY CONSOLE

dcbname.tty     fcc     'CONSOLE:'
                fcb     0

DCB.TTY         FCB     1    			; DCB:DONEFLAG	; 0 --> DEVICE IS BUSY; <>0 --> DEVICE IS DONE
                FDB     0    			; DCB:LASTERROR	; IF DCB IS DONE, CONTAINS ERROR STATUS (0 = NONE )
                FDB     dcbname.tty		; DCB:NAME	; POINTER TO DEVICE NAME STRING TERMINATED BY ZERO BYTE
                FDB     DCB.PORT		; DCB:NEXTDCB	; POINTER TO NEXT DCB IN LIST OR ZERO
                FDB     CONSOLEDRIVER		; DCB:DRIVER	; POINTER TO DRIVER ENTRY POINT LIST

; DEVICE DRIVER BLOCK FOR TTY CONSOLE

CONSOLEDRIVER	FDB 	OPEN.TTY	; DRIVER:OPEN	OPEN FILE
		FDB	CLOSE.TTY	; DRIVER:CLOSE	CLOSE FILE
		FDB	READA.TTY	; DRIVER:READA	READ ASCII
		FDB	WRITEA.TTY	; DRIVER:WRITEA	WRITE ASCII
		FDB	READB.TTY	; DRIVER:READB	READ BINARY
		FDB	WRITEB.TTY	; DRIVER:WRITEB	WRITE BINARY
		FDB	OPEN.TTY	; DRIVER:CREATE	CREATE FILE
		FDB	ILLDEVICEOP	; DRIVER:RENAME	RENAME FILE
		FDB	ILLDEVICEOP	; DRIVER:DELETE	DELETE FILE
		FDB	CONTROL.TTY	; DRIVER:CONTROL	DO CONTROL OPERATION
		FDB	STATUS.TTY	; DRIVER:STATUS	READ DEVICE (DRIVER) STATUS
		FDB	RESET.TTY	; DRIVER:RESET	RESET DRIVER (ON BOOT)
		FDB	ILLDEVICEOP	; DRIVER:STARTIO	power-fail restart--dream on!

OKRTS		CLC
		RTS

ILLDEVICEOP  	JSR     SDOS+SDOS.ERROR
		FDB     ERR.ILLDEVICEOP
ERRETX  	JSR     SDOS+SDOS.ERRORSAVE
		JMP     SDOS+SDOS.ERRORED


LMODE		RMB	1		; =0 -> reada in non-line mode, >0 -> reada line mode 
LEN		RMB	2		; DATA BUFFER LENGTH
PDATA		RMB	2		; ADDR OF DATA 
RPLEN		RMB	2		; REPLY DATA BUFFER LENGTH

InputBufLen	EQU	250		; length of input buffer (max 255)
InputBuf	RMB	InputBufLen	; input buffer ADDR
InputBufP0	RMB	2		; addr of next char into InputBuffer TO BE PROCESSED (HEAD OF BUFFER)
InputBufP1	RMB	2		; addr of next free char into InputBuffer (END OF BUFFER)

EOFFLAG		RMB	1		; =1 -> EOF = input line processed
ECHOFLAG	rmb	1		; =0 -> NO ECHO 
ncol		rmb	1		; number of chars printed in the current line
basicflags	rmb	1		; flags for basic control chars for debugging
CTRLCNUM	RMB	1		; NUMBER OF CONTROL-C TYPED IN SEQUENCE
expandtabflag	rmb	1
crflag		rmb 	1		;1=if prev char recv in port: was a <CR>

ACTIVATIONCHARSVECTOR	RMB 16		; Activation Chars vector
ActivationCharSensed	rmb 1		; Activation Char typed by user

	     if	ram64k=1
		; on 64K RAM machine, SWTBUG rom not present. Here goes the console I/O routines
ACIAPORT	EQU	$FF04	; ACIA PORT IN SWTBUG 64K RAM
PORECH		FCB	0	; ECHO (=0 -> echo, $FF -> no echo)

		; *OUTPUT ONE CHARACTER
OUTEEE		PSHB		; SAVE ACC B
		STX	$00	; STORE INDEX REGISTER
		LDX	#ACIAPORT
		LDAB	1,X
		CMPB	3,X
ACIOUT		LDAB	#$11
		STAB	0,X
ACIOU1		LDAB	0,X
		ASRB
		ASRB
		BCC	ACIOU1	; ACIA NOT READY
		STAA	1,X	; OUTPUT CHARACTER **log OUTCH:A
RES		PULB		; RESTORE ACC B
		LDX	$00
		RTS

		; *INPUT ONE CHAR INTO ACC B
INEEE		PSHB		; SAVE ACC B
		STX	$00	; STORE INDEX REGISTER
		LDX	#ACIAPORT
		LDAB	1,X
		CMPB	3,X
		LDAA	#$15	; RECONFIG FOR 8 BIT, 1 SB
		STAA	0,X     ;             **troff
ACIAIN		LDAA	0,X
		ASRA
		BCC	ACIAIN	; NOT READY
		LDAA	1,X	; LOAD CHAR   **tron
		LDAB	PORECH
		BEQ	ACIOUT	; ECHO
		BRA	RES	; DON'T ECHO

RDON		LDAA	#$11	; RON CHAR.
		BRA	OUTEEE
RDOFF		LDAA	#$13	; TURN READER OFF
		BRA	OUTEEE
PNCHON		LDAA	#$12 	; punch on 
		BRA	OUTEEE
PNCHOFF		LDAA	#$14	; punch off
		BRA	OUTEEE
		
	     else
		; use SWTBUG rom for INEEE and OUTEEE, and so ...	
	     fin

		; print a char 

prtch		cmpa	#13		; <CR> RESET COLUMN COUNT
		beq	prt1
		cmpa	#8		; backSpace
		beq	prt4		
		bita 	#60		; DO NOT INCR NCOL ON CONTROL CHARS
		BEQ	PRT3
prt2		inc	ncol		; INCR NCOL ON REGULAR $20-$7F
prt3		jmp	outeee
prt1		clr 	ncol
		dec	ncol
		bra	prt3
prt4		jsr	outeee
		ldaa	#32
		jsr	outeee
		dec 	ncol
		ldaa	#8
		jmp	outeee

		; read keyboard key pressed 

inch		nop				; **troff
		jsr	ineee			; read the keyboard (blocking)
		rts				; **tron

OPEN.TTY	CLR	EOFFLAG		; RESET EOF FLAG
		LDAA	#1
		STAA 	ECHOFLAG	; set ECHO ON (to be done by this iopackage)
		ldaa	#255
		staa	PORECH		; DISABLE ECHO into swtbug 
		clr	ncol		; init numbers of chars printed in line
		LDX	#ACTIVATIONCHARSVECTOR
		LDAA	#16
OPEN.TTY1	CLR	0,X		; reset the 16 bytes of Activation Char vector
		INX
		DECA
		BNE	OPEN.TTY1	
		CLR	CTRLCNUM	; INIT ^c COUNT
		clr	basicflags
		JMP	OKRTS		; TTY IS ALWAYS OPEN

CLOSE.TTY	JMP	OKRTS		; AND TTY CANNOT BE CLOSED


STATUS.TTY	ldx     SDOS+SDOS.IOBLOCKPTR
          	ldaa    #0  ; vt:sclen
          	ldab    scblk.params+1,x	; get sc status opcode
		cmpb	#SC.GETLINEFLAGS
                bne	st0
		ldaa	basicflags		; get the basic flags

		oraa	BASICDEBUGFLAGS		; or basic debug flags 
;               oraa #TRACEBIT			; turn on basic trace 

		clr	basicflags		; ans clear them
		bra	statusret1
st0		cmpb	#SC.GETCOL
		bne	st1
		ldaa	ncol			; get the number of columns used in current line
		bra	statusret1
st1		cmpb	#sc.geteof
		bne 	st2		
		ldaa	eofflag
		bra	statusret1
st2		ldaa	#0			; any other request returns 0
statusret1      LDX     scblk.rdbuf,x		; return 1 byte status
		staa    0,X			; STORE IN RDBUF
		JMP	OKRTS 

CONTROL.TTY	ldx	sdos+sdos.ioblockptr
		ldab	scblk.params+1,x
		cmpb	#cc.activationck
		beq	dactivationck
		cmpb	#cc.ECHO
		beq	dECHO
		cmpb	#cc.NOECHO
		beq	dnoecho
		cmpb	#cc.SETACTBLOCK
		beq	dsetactivation
RESET.TTY	JMP	OKRTS		; TTY DOES NOT NEED RESET

DECHO		LDAA	#1
		STAA	ECHOFLAG
		JMP	OKRTS
DNOECHO		CLR 	ECHOFLAG
		JMP	OKRTS		
		
dactivationck	ldx	InputBufp0		; Is input Buf empty?
		cpx	InputBufP1
		beq	dactivation1		; br if so (reada will block)
	        jsr     sdos+sdos.error		; something in input buffer
        	fdb	err.activationreceived	; signal it (reada will not block)
dactivation1	JMP 	OKRTS			


dsetactivation	jsr 	GETWRITEPARAMS		; set the activation chars vector
		ldx	#ACTIVATIONCHARSVECTOR	
		stx	ddata
		ldab 	#16
dsetact1	ldx	pdata
		ldaa	0,x
		inx
		stx	pdata
		ldx	ddata
		staa	0,x	
		inx
		stx	ddata
		decb
		bne	dsetact1
		jmp 	okrts

		; read params from READA/B SYSCALL
		; set LMODE, PDATA, LEN, clears RPLEN

getreadparams	ldx     sdos+sdos.ioblockptr
		ldaa    scblk.params+1,x	; if LMODE=0 -> reada in non-line mode, >0 -> reada line mode 
		staa    LMODE
		LDX     scblk.rdlen,x		; LEN=reada/B SYSCALL buffer length
		stX	LEN
		LDX	SDOS+SDOS.IOBLOCKPTR	; INIT RPLEN TO ZERO (ACTUAL CHARS READ INTO SYSCALL BUFFER)
		CLR	scblk.RPLEN,x
		CLR	scblk.RPLEN+1,x
		LDX	SDOS+SDOS.IOBLOCKPTR	; PDATA=addr of INPUT buffer 
		LDX	scblk.rdbuf,x
		STX	PDATA
		rts
		
		; save x-reg as rplen (numb of chars read) as syscall return 
setrplen	stx	$00
		ldaa	$00
		ldab	$01
		LDX	SDOS+SDOS.IOBLOCKPTR	
		staa	scblk.RPLEN,x
		stab	scblk.RPLEN+1,x
		rts

readb.TTY	jsr 	getreadparams		; get syscall params
		ldx	len			; readb will read
		jsr 	setrplen		; exactly len chars from keyboard
readb1		ldx	len			; input buf full? (remaining len=0)
		beq	readb2			; br if buf full
		dex				; no, decr remaining len
		stx 	len
		jsr 	inch			; read char from keyboard
		ldx	pdata			; input buf addr
		staa	0,x			; store into input buf
		inx
		stx	pdata
		bra	readb1
readb2		clc
		rts		

reada.TTY	jsr 	getreadparams		; get syscall params
		LDAA	LMODE			; CHECK IF NON-LINE MODE READ BUT BUF LEN > 0
		BNE	reada1			; BR BECAUSE IN LINE MODE
		LDX	LEN
		BEQ	reada1
		jmp     ILLDEVICEOP  		; ERROR BECAUSE NON-LINE MODE READ BUT BUF LEN > 0
reada1		LDX	LEN			; IS BUFFER IS ZERO BYTES
		BNE	READA2			; THE JUST RETURN FROM READ 
		jsr     sdos+sdos.error		; signaling "Activation not in buffer" error
		fdb 	ERR.ACTIVATIONNOTINBUFFER				
READA2		ldx	InputBufp0		; LEN IS >0 -> CHECK Is input Buf empty?
		cpx	InputBufP1
		bne	reada3			; br if not
		jsr	readInputBuf		; input buffer empty -> read it from keyboard
reada3		LDX	#0
		STX	RPLEN			; INIT RPLEN
READA4		LDX	iNPUTBUFP0		; CHECK IF INPUT BUF IS EMPTY
		CPX	iNPUTBUFP1		
		BEq	READA6			; BR IF EMPTY 
		LDX	iNPUTBUFP0		; GET CHAR FROM INPUT BUFFER
		LDAA	0,X					
		INX
		STX 	INPUTBUFP0
		cmpa	#26			; char is ^Z ? 
		beq	reada6			; br if so to signal eof
		LDX	PDATA			; STORE CHAR IN SYSCALL BUFFER
		STAA	0,X
		INX	
		STX	PDATA
		cmpa	#13			; <cr> resets ncol to 0
		bne     rd1ncol
		clr	ncol
		bra	rd2ncol
rd1ncol		inc	ncol			; incr ncol chars processed				
rd2ncol		LDX	RPLEN			; INCR RPLEN NUM OF BYTES STORED
		INX				; IN SYSCALL BUFFER
		STX	RPLEN
		psha
		JSR	setrplen		
		pula
		CMPA	ActivationCharSensed	; CHAR IS activation char sensed ?
		BNE	READA5			; BR IF NOT
		JMP	OKRTS			; YES! ACTIVATION CHAR IN READ BUFFER -> EXIT FROM SYSCALL, NO ERRORS
READA5		LDX	RPLEN			; CHECK IF SYSCALL BUFFER
		CPX	LEN 			; IS FULL
		BNE	READA4			; BR IF NOT ...
		jsr     sdos+sdos.error		; BUFFER IS FULL -> RETURN FROM SYSCALL 
		fdb 	ERR.ACTIVATIONNOTINBUFFER ; signaling "Activation not in buffer" error
READA6		LDAA	#1			; SIGNAL EOF FLAG
		STAA	EOFFLAG
		jsr     sdos+sdos.error		; NO MORE CHARS IN INPUT BUFFER
		fdb 	err.eofhit		; return from read signaling eof CONDITION
		
		
ReadInputBuf	CLR	CTRLCNUM
		CLR	ActivationCharSensed	; no activation char sensed
		clr	expandtabflag		; tabs should be echoed as ^I if echo is enabled
RINBUF		ldx	#InputBuf		; init Input buf head and and pointer
		stx	InputBufP0		; to set as no chars has been typed yet (empty buf)
		stx	InputBufP1
RINCH		jsr	inch			; READ KEY FROM KEYBOARD
		staa	ch			; save
		CMPa	#3			; is ^C (BREAK)
		BNE	RI1
RCTRLC		jsr	write.chcr.echo		; if echo set, write ^C on screen, then <cr><LF>
		INC	CTRLCNUM		; INC COUNTER OF ^c'S ISSUED
		LDAA	CTRLCNUM
		CMPA	#2	
		BNE	rINBUF			; BR IF IS THE FIRST ONE: DISCARD CURRENT LINE
		jsr     sdos+sdos.error		; TWO ^C IN SEQUENCE
          	FDB	err.programkilled	; KILL THE CURRENT PROGRAM
RI1		CLR	CTRLCNUM		; KEY READ IS NOT ^c -> RESET COUNT
		CMPA 	#8			; IS ^H (BACKSPACE)
		BEQ   	RBACKSPACE
		CMPA	#127			; OR IS ROUBOUT/DEL
		BNE	RI2			;    BR IF NOT
RBACKSPACE	JSR	BACKSPACE		; DEL LAST TYPED CHAR FROM INPUTBUF AND (IF ECHO ENABLED) FROM SCREEN
		BRA	RINCH			; IF SO, IGNORE THE BACKSPACE KEY AND BR TO KEEP READING KEYBOARD			
RI2		CMPA	#4			; IS ^D ? (GO TO DEBUG MONITOR)			
		BNE	RI3
RCTRLD		jsr	write.chcr.echo		; if echo set, write ^D on screen, then <cr><LF>
	     if ram64k=1
		JMP	RINCH			; RAM64K does not uses SWTBUG ROM, so ^D does nothing
	     else
		STS	SWTRET+1		; SAVE STACK POINTER
		JMP	SWTMON			; JUMP TO SWTBUG monitor. return from monitor with JA080 command
SWTRET		LDS	#$A07F			; SWTBUG MONITOR GO COMMAND RETURNS HERE. RESTORE STACK POINTER
		ldaa	#255
		staa	PORECH			; DISABLE ECHO FOR ACIA
		JMP	RINCH			; JMP TO KEEP READING KEYBOARD AS NOTHING HAPPEND
	     fin
RI3		ldab	#BREAKBIT		; 
		CMPA	#2			; IS ^B? (REQUEST LINE NUMBER BREAKPOINT in a basic program)
		BEQ	Rbas			;    br if SO ...
		ldab	#SSTEPBIT	
		cmpa	#$16			; IS ^V? (REQUEST SINGLE STEP in a basic program)
		BEQ	Rbas			;    br if SO ...
		ldab	#TRACEBIT		
		cmpa	#$14			; IS ^T? (REQUEST LINE NUMBER TRACE in a basic program)
		BEQ	Rbas			;    br if SO ...
		ldab	#GOBIT		
		cmpa	#7			; IS ^G? (GO FROM BREAKPOINT/SINGLE STEP in a basic program)
		Bne	RI4			;    br if SO ...
RBAS		orab	basicflags		; add current basic flags
		orab	#1			; SET BASIC KEYB POLL ACTIVE ON SC:GETLINEFLAGS
		stab	basicflags		; store back
RI4						
		LDX	INPUTBUFP1		; CHECK IF INPUTBUF IS FULL
		CPX	#INPUTBUF+INPUTBUFLEN-1
		BNE	RSTORECH		; BR IF BUF HAS ROOM LEFT TO STORE THE TYPED CHAR
		PSHA				; IF INPUTBUF FULL, THEN ...
		JSR	BACKSPACE		; ... DEL LAST TYPED CHAR FROM INPUTBUF AND (IF ECHO ENABLED) FROM SCREEN	
		PULA				; TO REPLACE IT WITH NEW TYPED CHAR
RSTORECH	LDX	INPUTBUFP1		
		STAA	0,X			; STORE CHAR IN INPUTBUF
		inx
		stx	inputbufp1
		psha
		JSR	WRITEA.CH.echo		; ECHO IT TO SCREEN 
		pula
		CMPa 	#13			; IS <CR> ? 
		BEQ	ActivChar		;   BR IF SO ...
		CMPa 	#26			; IS ^Z ? 
		bne	ri5			;   BR IF NOT ...
		jsr	write.cr.echo		; write a <cr> after ^Z
		Bra	Rendofinput		; then end reading the line
ri5		psha				; now check if the char in a-reg is an activation char
		anda	#7
		ldab	#1			; set to 1 the bit number
ri6		tsta				; corresponding to (char & 7)
		beq	ri7
		aslb		
		deca
		bra	ri6
ri7		pula
		asra				; a=byte index on ACTIVATIONCHARSVECTOR
		asra				; b=bit mask 
		asra
		staa	ActivByte+1	
		ldx 	#ACTIVATIONCHARSVECTOR	; check ACTIVATIONCHARSVECTOR to 
ActivByte	ldaa	0,X			; determine if char is an activation char
		stab	$00
		anda	$00
		bne	ActivChar		; BR if char is an activation char
		JMP	RINCH
ActivChar	ldaa	ch
		staa	ActivationCharSensed	; save the activation char sensed
Rendofinput	RTS				; > READ LINE FROM KEYBOARD TERMINATED
		
		

BACKSPACE	LDX	InputBufP1		; DEL LAST TYPED CHAR FROM INPUTBUF AND (IF ECHO ENABLED) FROM SCREEN
		CPX	#iNPUTbUF		
		BEQ	BACKSPC2
		DEX
		STX	iNPUTBUFP1		; BACKSPACE TO ERASE LAST CHAR TYPED FROM INPUTBUF
		TST	ECHOflag
		BEQ	BACKSPC2		; IF NO ECHO, BR TO KEEP READING KEYBOARD
		LDAA	0,X			; GET CHAR THAT HAS BEEN ERASED
		CMPA	#32			; IS A CONTROL CHAR?
		BCC	BACKSPC1		; BR IF A >= 32 
		LDAA	#8			; IS A CONTROL CHAR -> ISSUE TWO BACKSPACES
		JSR 	PRTCH			; TO DELETE ^x FROM SCREEN
BACKSPC1	LDAA	#8
		JSR 	PRTCH
BACKSPC2	RTS

GETWRITEPARAMS	LDX	SDOS+SDOS.IOBLOCKPTR	; get number of chars to write form syscall
		LDX	scblk.wrlen,x		
		STX	LEN			
		LDX	SDOS+SDOS.IOBLOCKPTR	; get addr of chars to write
		LDX	scblk.wrbuf,x
		STX	PDATA
		RTS


WRITEA.TTY	LDAa	#1
		STaA	write.MODE+1
		staa	expandtabflag		; signal tabs should be expanded to spaces
		BRA	WRITE.0
WRITEB.TTY	CLR	write.MODE+1
		clr 	ncol
WRITE.0		JSR	GETWRITEPARAMS 
		LDX	LEN			
		BEQ	WRITE.9			; exit because writing zero chars
WRITE.1		LDX	PDATA			; get next char to write.
		LDAA	0,X
		INX				; .*echo wrtch:a
		STX	PDATA
write.MODE	ldab	#0			; if not ascii mode (that means, we are executing a writeb)
		BEQ	WRITE.2			; br to print char without any further processing		
		JSR	WRITEA.CH		; convert char <CR> -> <CR><LF>, ctrol char -> ^X
		bra	write.3
WRITE.2		JSR 	prtch			; send char to console via swtbug
write.3		LDX	LEN
		DEX
		STX	LEN
		BNE	WRITE.1
WRITE.9		JMP	OKRTS


write.chcr.echo	jsr	WRITEA.CH.echo	
write.cr.echo 	ldaa	#13
WRITEA.CH.echo	tst	echoflag		; write char only if echo set and expand tabs. 
		bne	writea.ch1		; this is called from ReadInputBuf
		rts
WRITEA.CH	cmpa	#12			; ^L -> do not print
		beq	WRITEA.CH4
		cmpa	#7			; ^G -> do not print
		beq	WRITEA.CH4
writea.ch1	andA 	#$7f		
		CMPA	#13
		BNE	WRITEA.CH2		; SEND A <LF> AFTER EACH <CR>
		JSR 	prtch
		LDAA    #10
		bra	WRITEA.CH3	
WRITEA.CH2  	cmpa	#9			; check for <TAB> (char 9 dec)
		bne	WRITEA.CH2b
		tst	expandtabflag		; tabs should be expanded to spaces?
		beq	WRITEA.CH2c		; br if not to print tab as ^I
		ldab	ncol			; tab converted to 1-8 spaces depending on ncol
		andb	#7
		ldaa	#8
		sba
		tab				; b=spaces that replaces tab=8-ncol
WRITEA.CH2a	pshb
		ldaa	#32
		jsr	prtch
		pulb
		decb
		bne	WRITEA.CH2a
 		rts
WRITEA.CH2b	cmpa	#32			; if ch < 32, print it as control char "^ch"
		bcC	WRITEA.CH3		; BR IF A-REG >= 32
WRITEA.CH2c	psha
		ldaa	#'^
		JSR 	prtch
		pula
		adda	#'@
WRITEA.CH3	jsr 	prtch
WRITEA.CH4	RTS
		
; DEVICE CONTROL BLOCK FOR SIMH IO VIRTUAL PORT

dcbname.port    fcc     'PORT:'
                fcb     0

DCB.PORT        FCB     1    			; DCB:DONEFLAG	; 0 --> DEVICE IS BUSY; <>0 --> DEVICE IS DONE
                FDB     0    			; DCB:LASTERROR	; IF DCB IS DONE, CONTAINS ERROR STATUS (0 = NONE )
                FDB     dcbname.port		; DCB:NAME	; POINTER TO DEVICE NAME STRING TERMINATED BY ZERO BYTE
                FDB     CLOCKDCB		; DCB:NEXTDCB	; POINTER TO NEXT DCB IN LIST OR ZERO
                FDB     PORTDRIVER		; DCB:DRIVER	; POINTER TO DRIVER ENTRY POINT LIST

; DEVICE DRIVER FOR IO PORT (for simh PTR and PTP)

PORTDRIVER	FDB 	OPEN.PORT	; DRIVER:OPEN	OPEN FILE
		FDB	CLOSE.PORT	; DRIVER:CLOSE	CLOSE FILE
		FDB	READA.PORT	; DRIVER:READA	READ ASCII
		FDB	WRITEA.PORT	; DRIVER:WRITEA	WRITE ASCII
		FDB	READB.PORT	; DRIVER:READB	READ BINARY
		FDB	WRITEB.PORT	; DRIVER:WRITEB	WRITE BINARY
		FDB	OPEN.PORT	; DRIVER:CREATE	CREATE FILE
		FDB	ILLDEVICEOP	; DRIVER:RENAME	RENAME FILE
		FDB	ILLDEVICEOP	; DRIVER:DELETE	DELETE FILE
		FDB	control.port	; DRIVER:CONTROL	DO CONTROL OPERATION
		FDB	status.port	; DRIVER:STATUS	READ DEVICE (DRIVER) STATUS
		FDB	OKRTS		; DRIVER:RESET	RESET DRIVER (ON BOOT)
		FDB	ILLDEVICEOP	; DRIVER:STARTIO	power-fail restart--dream on!

PORTMODE	FCB	$FF		; =1 -> READING FROM PTR, =2 -> READING FROM PTP
ch		rmb 	1		; char read/write

control.port	ldx	sdos+sdos.ioblockptr
		ldab	scblk.params+1,x
		cmpb	#cc.activationck
		jmp	okrts

status.port	ldx     SDOS+SDOS.IOBLOCKPTR
          	ldab    scblk.params+1,x	; get sc status opcode
		cmpb	#sc.gettype
		bne	stpo1
		ldaa	#DVTYP.STAPE
		bra	stpo2
stpo1 		ldaa	#0			; any other request returns 0
stpo2		LDX     scblk.rdbuf,x		; return 1 byte status
		staa    0,X			; STORE IN RDBUF
		JMP	OKRTS 


OPEN.PORT	LDAA	#0
		STAA	PORTMODE	; =0 -> ready for read/write
		JMP 	OKRTS

CLOSE.PORT	ldaa	portmode
		bne	cl1
		jmp	okrts		; just close after open
cl1		cmpa	#1		
		bne	cl2
					; close ptr
		jsr	RDOFF		; PTR off (^S)
		ldaa	#$ff		; set mode as closed
		staa	portmode
		JMP 	OKRTS
cl2					
		cmpa	#2
		bne	cl3
					; close ptp
		jsr	PNCHOFF		; PTR off (^T)
		ldaa	#$ff		; set mode as closed
		staa	portmode
		JMP 	OKRTS

		JMP 	OKRTS
cl3		JMP	ILLDEVICEOP	

delay1k		ldx	#50		; **troff
delay1kb	dex
		bne	delay1kb
		rts			; **tron

innyble		jsr 	delay1k		; RECEIVE A BYTE FROM PTR AS TWO ASCII NYBLLES TO FORM A BYTE
		jsr	inch		; EXAMPLE: RECIVE CHARS "3A" -> RECV BYTE = $3A
		cmpa	#'0		; .*echo inch:a
		BCC	innyb1		; BR IF A >= '0'
		cmpa	#26
		bne	innyble		; invalid char -> read next 
		sec			; RECEIVED ^Z
		rts			; return carry set -> eof
innyb1		suba	#'0
		cmpa	#10
		bcc	innyb4		; br if a >= 10
		clc
		rts			; return nyble 0..9
innyb4		suba	#7
		cmpa	#16
		bcc	innyble		; br if a >= 16 -> invalid nyble -> read next
		clc
		rts

INBYTE		jsr 	delay1k		; RECEIVE AN ASCII CHAR FROM PTR 
		jsr	inch		
		CMPA	#0		; RECV $00 CHAR -> END OF FILE
		BEQ 	INBYTEEOF
		CMPA	#26		; RECV ^Z -> END OF FILE
		BEQ 	INBYTEEOF
		CLC
		RTS
INBYTEEOF	SEC			; SET CARRY TO SIGNAL END OF FILE TO CALLER
		RTS


READA.PORT	LDAa	#1
		STaA	APORT.MODE+1
		BRA	READ.PORT
READB.PORT	CLR	APORT.MODE+1
READ.PORT	jsr 	getreadparams	; get syscall params
		ldx	#0
		jsr 	setrplen	; set reply len size
		LDAA	PORTMODE
		BNE	RP1
		LDAA	#1		; start reading from ptr
		STAA	PORTMODE	; 
		clr	crflag
		jsr	RDON		; ACTIVATE PTR on (^Q)
		LDAA	APORT.MODE+1	; GET PORT READA/READB MODE
		BNE	rp1start	; BR IF READA
		LDAA	#129		; ACTIVATE PTR bin mode (129)
		JSR	PRTCH	
		bra	rp1start
rp1		cmpa	#1
		beq	rp1start	; br read port input
		jmp	ILLDEVICEOP	
rp1start	ldx	#0
		stx 	rplen
rpin		ldx 	len
		bne	rp1a
		jmp	okrts		; input buffer full -> terminate read
rp1a		dex
		stx	len
APORT.MODE	LDAA 	#0
		BEQ	READBPORT
READAPORT	JSR	INBYTE	
		bcs	rp1eof		; br if eof
		; now handle the end of line: DOS <CR><LF>, Unix <LF>, Mac/SDOS <CR>
		cmpa 	#13
		bne	cr1		; if <CR> -> set crflag
		ldab	#1
		stab	crflag
		bra     cr0
cr1		cmpa 	#10		; if <LF> after a <CR> -> ignore <LF>
		bne	cr2		; if <LF> NOT after a <CR> -> convert to <CR>
		tst 	crflag
		bne	READAPORT	
 		ldaa 	#13
		bra	cr0
cr2		clr	crflag		; not <cr>/<l> -> clear cr flag 
		bra	SAVEREADPORTCH	; and br to store char
cr0		tst	lmode
		beq	SAVEREADPORTCH	; if not line mode br to store char
		clr	len		; recv <cR> in line more -> set len to zero so reada is terminated
		clr	len+1
		BRA	SAVEREADPORTCH
READBPORT	jsr	innyble
		bcs	rp1eof		; br if eof
		asla
		asla
		asla
		asla
		staa	ch		; save hi nyble
		jsr	innyble
		bcs	rp1eof		; br if eof
		adda	ch
		staa	ch		; binary char composed
SAVEREADPORTCH	ldx	pdata		; input buf addr
		staa	0,x		; store into input buf
		inx			; .*echo inbyte:a
		stx	pdata
		ldx	rplen
		inx
		stx	rplen
		jsr 	setrplen	; set reply len size = num of bytes read
		bra	rpin

rp1eof		jsr     sdos+sdos.error	; .*echo eof
		fdb 	err.eofhit	; return from read signaling eof CONDITION

WRITEA.PORT	LDAa	#1
		STaA	APORT.MODE+1
		staa	expandtabflag	; signal tabs should be expanded to spaces
		BRA	WRITE.PORT
WRITEB.PORT	CLR	APORT.MODE+1
WRITE.PORT	JSR	GETWRITEPARAMS 
		LDAA	PORTMODE
		BNE	WP1
		LDAA	#2		; start WRITING AT ptP
		STAA	PORTMODE	; 
		jsr	PNCHON		; ACTIVATE PTP on (^R)
		ldaa	#130		; ACTIVATE PTP ascii (130)
		LDAb	APORT.MODE+1	; GET PORT WRITEA/WRITEB MODE
		BNE	Wp0		; BR IF writeA
		LDAA	#131		; ACTIVATE PTP bin mode (131)
		JSR	PRTCH	
		LDAA	#32
		JSR	PRTCH		; SEND A SPACEs TO SYNC
		LDAA	#32
		JSR	PRTCH		
		LDAA	#32
wp0		JSR	PRTCH		
		bra	Wp1start
Wp1		cmpa	#2
		beq	Wp1start	; br read port input
		jmp	ILLDEVICEOP	
Wp1start	
WpOUT		ldx 	len
		bne	Wp1a
		jmp	okrts		; input buffer full -> terminate read
Wp1a		dex
		stx	len
 		LDX	PDATA		; get next char to write.
		LDAA	0,X
		INX			; .*echo wrtch:a
		STX	PDATA
		LDAB 	APORT.MODE+1
		BEQ	WRITEBPORT
WRITEAPORT	JSR	WRITEA.CH	; convert char <CR> -> <CR><LF>, cTRol char -> ^X
		BRA	WPOUT
WRITEBPORT	STAA 	CH
		LSRA
		LSRA
		LSRA
		LSRA
		JSR 	OUTNYBLE
		LDAA	CH
		ANDa 	#$0F
		JSR 	OUTNYBLE
		BRA	WPOUT

OUTNYBLE	ADDA	#'0
		CMPA	#'9+1
		BCS	OUTNYBLE1  	; BR IF A<'9'+1
		ADDA	#7		; 7='A'-'0'-10
OUTNYBLE1	jMP	PRTCH








; DEVICE CONTROL BLOCK FOR MF-68 FLOPPY DISK

LSN.SIZE	EQU	3	; # BYTES OCCUPIED BY AN LSN
LCN.SIZE	EQU	2	; # BYTES OCCUPIED BY AN LCN

dcbname.D0      fcc     'D0:'
                fcb     0
DISKDCBS	
DCB.D0          FCB     1    			; DCB:DONEFLAG	; 0 --> DEVICE IS BUSY; <>0 --> DEVICE IS DONE
                FDB     0    			; DCB:LASTERROR	; IF DCB IS DONE, CONTAINS ERROR STATUS (0 = NONE )
                FDB     dcbname.D0		; DCB:NAME	; POINTER TO DEVICE NAME STRING TERMINATED BY ZERO BYTE
                FDB     dcb.d1			; DCB:NEXTDCB	; POINTER TO NEXT DCB IN LIST OR ZERO
                FDB     DSKDRIVER		; DCB:DRIVER	; POINTER TO DRIVER ENTRY POINT LIST

								; DISK GEOMETRY
		FDB	128     		; DSKINFO:NBPS	; NUMBER OF BYTES PER SECTOR
		FDB	18			; DSKINFO:NSPT	; NUMBER OF SECTORS PER TRACK
		FDB	2			; DSKINFO:NTPC	; NUMBER OF TRACKS PER CYLINDER
		FDB	35			; DSKINFO:NCYL	; NUMBER OF CYLINDERS PER DRIVE

								; THE FOLLOWING ARE FILLED FROM THE BOOT SECTOR
		RMB	1			; DSKINFO:NSPC		NUMBER OF SECTORS PER CLUSTER
		RMB	LCN.SIZE		; DSKINFO:MINALLOC	ALLOCATION MINIMUM FOR NEW FILES
		RMB	LCN.SIZE		; DSKINFO:MIDALLOC	ALLOCATION MIN FOR FILE EXTENSION
		RMB	2			; DSKINFO:MAPALGORITHM	CODE TO SELECT LOGICAL TO PHYSICAL SECTOR MAP ALGORITHM

								; CONTAINS DISK ID FOR MOUNTED DISKS
		RMB	1			; DSKINFO:LOG2NBPS	LOG BASE 2 OF DSKINFO:NBPS
		RMB	2			; DSKINFO:NBPSM1	= NBPS-1 FOR USE AS MASK (QUICK "MOD NBPS")
		RMB	LSN.SIZE		; DSKINFO:NLSN		NUMBER OF LSNS FOR THIS DISK = NSPT*NTPC*NCYL
		RMB	LCN.SIZE		; DSKINFO:NLCN		NUMBER OF LCNS FOR THIS DISK = NLSN/NSPC
		RMB	2			; DSKINFO:NBPC		NUMBER OF BYTES PER CLUSTER
		RMB	LCN.SIZE		; DSKINFO:RANDMAP	"RANDOM" LCN TO DISTRIBUTE NEW FILES
		RMB	LSN.SIZE		; DSKINFO:MAPLSN	LSN OF 1ST SECTOR IN DISK...

								; ALLOCATION MAP CLUSTER
		RMB	2			; DSKINFO:DIRFCB	POINTER TO FCB FOR $DIRECTORY FILE
		RMB	2			; DSKINFO:MAPFCB	POINTER TO FCB FOR $DISKMAP FILE
		RMB	2			; DSKINFO:SECTORDB	POINTER TO RDSI CONTAINING LSN, ADDRESS PARAMETERS
		RMB	LSN.SIZE		; DSKINFO:BADLSN	LSN OF LAST SECTOR THAT COULDN'T READ/WRITE/SEEK
		FDB	0			; DSKINFO:SEEKERRCNT	# SEEK ERRORS SINCE MOUNT
		FDB	0			; DSKINFO:SEEKERRSTS	16 BITS OF LAST "SEEK" STATUS IN ERROR
		FDB	0			; DSKINFO:WRITEERRCNT	# WRITE ERRORS SINCE MOUNT
		FDB	0			; DSKINFO:WRITEERRSTS	16 BITS OF LAST "WRITE" STATUS IN ERROR
		FDB	0			; DSKINFO:READERRCNT	# READ ERRORS SINCE MOUNT
		FDB	0			; DSKINFO:READERRSTS	16 BITS OF LAST "READ" STATUS IN ERROR
		FCB	0,0,0			; DSKINFO:OPSCOUNT	24 BITS OF # DRIVER OPERATIONS SINCEMOUNT
		RMB	LSN.SIZE		; DSKINFO:ERRLSN	LSN CAUSING ANY SOFT OR HARD ERROR
		RMB	1			; DSKINFO:WRITEPROTSTATE	0 --> WRITEABLE
		FCB	0			; FDUNIT		Drive number 

dcbname.D1      fcc     'D1:'
                fcb     0
DCB.D1          FCB     1    			; DCB:DONEFLAG	; 0 --> DEVICE IS BUSY; <>0 --> DEVICE IS DONE
                FDB     0    			; DCB:LASTERROR	; IF DCB IS DONE, CONTAINS ERROR STATUS (0 = NONE )
                FDB     dcbname.D1		; DCB:NAME	; POINTER TO DEVICE NAME STRING TERMINATED BY ZERO BYTE
                FDB     dcb.d2			; DCB:NEXTDCB	; POINTER TO NEXT DCB IN LIST OR ZERO
                FDB     DSKDRIVER		; DCB:DRIVER	; POINTER TO DRIVER ENTRY POINT LIST

								; DISK GEOMETRY
		FDB	128     		; DSKINFO:NBPS	; NUMBER OF BYTES PER SECTOR
		FDB	18			; DSKINFO:NSPT	; NUMBER OF SECTORS PER TRACK
		FDB	2			; DSKINFO:NTPC	; NUMBER OF TRACKS PER CYLINDER
		FDB	35			; DSKINFO:NCYL	; NUMBER OF CYLINDERS PER DRIVE

								; THE FOLLOWING ARE FILLED FROM THE BOOT SECTOR
		RMB	1			; DSKINFO:NSPC		NUMBER OF SECTORS PER CLUSTER
		RMB	LCN.SIZE		; DSKINFO:MINALLOC	ALLOCATION MINIMUM FOR NEW FILES
		RMB	LCN.SIZE		; DSKINFO:MIDALLOC	ALLOCATION MIN FOR FILE EXTENSION
		RMB	2			; DSKINFO:MAPALGORITHM	CODE TO SELECT LOGICAL TO PHYSICAL SECTOR MAP ALGORITHM

								; CONTAINS DISK ID FOR MOUNTED DISKS
		RMB	1			; DSKINFO:LOG2NBPS	LOG BASE 2 OF DSKINFO:NBPS
		RMB	2			; DSKINFO:NBPSM1	= NBPS-1 FOR USE AS MASK (QUICK "MOD NBPS")
		RMB	LSN.SIZE		; DSKINFO:NLSN		NUMBER OF LSNS FOR THIS DISK = NSPT*NTPC*NCYL
		RMB	LCN.SIZE		; DSKINFO:NLCN		NUMBER OF LCNS FOR THIS DISK = NLSN/NSPC
		RMB	2			; DSKINFO:NBPC		NUMBER OF BYTES PER CLUSTER
		RMB	LCN.SIZE		; DSKINFO:RANDMAP	"RANDOM" LCN TO DISTRIBUTE NEW FILES
		RMB	LSN.SIZE		; DSKINFO:MAPLSN	LSN OF 1ST SECTOR IN DISK...

								; ALLOCATION MAP CLUSTER
		RMB	2			; DSKINFO:DIRFCB	POINTER TO FCB FOR $DIRECTORY FILE
		RMB	2			; DSKINFO:MAPFCB	POINTER TO FCB FOR $DISKMAP FILE
		RMB	2			; DSKINFO:SECTORDB	POINTER TO RDSI CONTAINING LSN, ADDRESS PARAMETERS
		RMB	LSN.SIZE		; DSKINFO:BADLSN	LSN OF LAST SECTOR THAT COULDN'T READ/WRITE/SEEK
		FDB	0			; DSKINFO:SEEKERRCNT	# SEEK ERRORS SINCE MOUNT
		FDB	0			; DSKINFO:SEEKERRSTS	16 BITS OF LAST "SEEK" STATUS IN ERROR
		FDB	0			; DSKINFO:WRITEERRCNT	# WRITE ERRORS SINCE MOUNT
		FDB	0			; DSKINFO:WRITEERRSTS	16 BITS OF LAST "WRITE" STATUS IN ERROR
		FDB	0			; DSKINFO:READERRCNT	# READ ERRORS SINCE MOUNT
		FDB	0			; DSKINFO:READERRSTS	16 BITS OF LAST "READ" STATUS IN ERROR
		FCB	0,0,0			; DSKINFO:OPSCOUNT	24 BITS OF # DRIVER OPERATIONS SINCEMOUNT
		RMB	LSN.SIZE		; DSKINFO:ERRLSN	LSN CAUSING ANY SOFT OR HARD ERROR
		RMB	1			; DSKINFO:WRITEPROTSTATE	0 --> WRITEABLE
		FCB	1			; FDUNIT		Drive number 

dcbname.D2      fcc     'D2:'
                fcb     0
DCB.D2          FCB     1    			; DCB:DONEFLAG	; 0 --> DEVICE IS BUSY; <>0 --> DEVICE IS DONE
                FDB     0    			; DCB:LASTERROR	; IF DCB IS DONE, CONTAINS ERROR STATUS (0 = NONE )
                FDB     dcbname.D2		; DCB:NAME	; POINTER TO DEVICE NAME STRING TERMINATED BY ZERO BYTE
                FDB     dcb.d3			; DCB:NEXTDCB	; POINTER TO NEXT DCB IN LIST OR ZERO
                FDB     DSKDRIVER		; DCB:DRIVER	; POINTER TO DRIVER ENTRY POINT LIST

								; DISK GEOMETRY
		FDB	128     		; DSKINFO:NBPS	; NUMBER OF BYTES PER SECTOR
		FDB	18			; DSKINFO:NSPT	; NUMBER OF SECTORS PER TRACK
		FDB	2			; DSKINFO:NTPC	; NUMBER OF TRACKS PER CYLINDER
		FDB	35			; DSKINFO:NCYL	; NUMBER OF CYLINDERS PER DRIVE

								; THE FOLLOWING ARE FILLED FROM THE BOOT SECTOR
		RMB	1			; DSKINFO:NSPC		NUMBER OF SECTORS PER CLUSTER
		RMB	LCN.SIZE		; DSKINFO:MINALLOC	ALLOCATION MINIMUM FOR NEW FILES
		RMB	LCN.SIZE		; DSKINFO:MIDALLOC	ALLOCATION MIN FOR FILE EXTENSION
		RMB	2			; DSKINFO:MAPALGORITHM	CODE TO SELECT LOGICAL TO PHYSICAL SECTOR MAP ALGORITHM

								; CONTAINS DISK ID FOR MOUNTED DISKS
		RMB	1			; DSKINFO:LOG2NBPS	LOG BASE 2 OF DSKINFO:NBPS
		RMB	2			; DSKINFO:NBPSM1	= NBPS-1 FOR USE AS MASK (QUICK "MOD NBPS")
		RMB	LSN.SIZE		; DSKINFO:NLSN		NUMBER OF LSNS FOR THIS DISK = NSPT*NTPC*NCYL
		RMB	LCN.SIZE		; DSKINFO:NLCN		NUMBER OF LCNS FOR THIS DISK = NLSN/NSPC
		RMB	2			; DSKINFO:NBPC		NUMBER OF BYTES PER CLUSTER
		RMB	LCN.SIZE		; DSKINFO:RANDMAP	"RANDOM" LCN TO DISTRIBUTE NEW FILES
		RMB	LSN.SIZE		; DSKINFO:MAPLSN	LSN OF 1ST SECTOR IN DISK...

								; ALLOCATION MAP CLUSTER
		RMB	2			; DSKINFO:DIRFCB	POINTER TO FCB FOR $DIRECTORY FILE
		RMB	2			; DSKINFO:MAPFCB	POINTER TO FCB FOR $DISKMAP FILE
		RMB	2			; DSKINFO:SECTORDB	POINTER TO RDSI CONTAINING LSN, ADDRESS PARAMETERS
		RMB	LSN.SIZE		; DSKINFO:BADLSN	LSN OF LAST SECTOR THAT COULDN'T READ/WRITE/SEEK
		FDB	0			; DSKINFO:SEEKERRCNT	# SEEK ERRORS SINCE MOUNT
		FDB	0			; DSKINFO:SEEKERRSTS	16 BITS OF LAST "SEEK" STATUS IN ERROR
		FDB	0			; DSKINFO:WRITEERRCNT	# WRITE ERRORS SINCE MOUNT
		FDB	0			; DSKINFO:WRITEERRSTS	16 BITS OF LAST "WRITE" STATUS IN ERROR
		FDB	0			; DSKINFO:READERRCNT	# READ ERRORS SINCE MOUNT
		FDB	0			; DSKINFO:READERRSTS	16 BITS OF LAST "READ" STATUS IN ERROR
		FCB	0,0,0			; DSKINFO:OPSCOUNT	24 BITS OF # DRIVER OPERATIONS SINCEMOUNT
		RMB	LSN.SIZE		; DSKINFO:ERRLSN	LSN CAUSING ANY SOFT OR HARD ERROR
		RMB	1			; DSKINFO:WRITEPROTSTATE	0 --> WRITEABLE
		FCB	2			; FDUNIT		Drive number 


dcbname.D3      fcc     'D3:'
                fcb     0
DCB.D3          FCB     1    			; DCB:DONEFLAG	; 0 --> DEVICE IS BUSY; <>0 --> DEVICE IS DONE
                FDB     0    			; DCB:LASTERROR	; IF DCB IS DONE, CONTAINS ERROR STATUS (0 = NONE )
                FDB     dcbname.D3		; DCB:NAME	; POINTER TO DEVICE NAME STRING TERMINATED BY ZERO BYTE
                FDB     DCB.HD			; DCB:NEXTDCB	; POINTER TO NEXT DCB IN LIST OR ZERO
                FDB     DSKDRIVER		; DCB:DRIVER	; POINTER TO DRIVER ENTRY POINT LIST

								; DISK GEOMETRY
		FDB	128     		; DSKINFO:NBPS	; NUMBER OF BYTES PER SECTOR
		FDB	18			; DSKINFO:NSPT	; NUMBER OF SECTORS PER TRACK
		FDB	2			; DSKINFO:NTPC	; NUMBER OF TRACKS PER CYLINDER
		FDB	35			; DSKINFO:NCYL	; NUMBER OF CYLINDERS PER DRIVE

								; THE FOLLOWING ARE FILLED FROM THE BOOT SECTOR
		RMB	1			; DSKINFO:NSPC		NUMBER OF SECTORS PER CLUSTER
		RMB	LCN.SIZE		; DSKINFO:MINALLOC	ALLOCATION MINIMUM FOR NEW FILES
		RMB	LCN.SIZE		; DSKINFO:MIDALLOC	ALLOCATION MIN FOR FILE EXTENSION
		RMB	2			; DSKINFO:MAPALGORITHM	CODE TO SELECT LOGICAL TO PHYSICAL SECTOR MAP ALGORITHM

								; CONTAINS DISK ID FOR MOUNTED DISKS
		RMB	1			; DSKINFO:LOG2NBPS	LOG BASE 2 OF DSKINFO:NBPS
		RMB	2			; DSKINFO:NBPSM1	= NBPS-1 FOR USE AS MASK (QUICK "MOD NBPS")
		RMB	LSN.SIZE		; DSKINFO:NLSN		NUMBER OF LSNS FOR THIS DISK = NSPT*NTPC*NCYL
		RMB	LCN.SIZE		; DSKINFO:NLCN		NUMBER OF LCNS FOR THIS DISK = NLSN/NSPC
		RMB	2			; DSKINFO:NBPC		NUMBER OF BYTES PER CLUSTER
		RMB	LCN.SIZE		; DSKINFO:RANDMAP	"RANDOM" LCN TO DISTRIBUTE NEW FILES
		RMB	LSN.SIZE		; DSKINFO:MAPLSN	LSN OF 1ST SECTOR IN DISK...

								; ALLOCATION MAP CLUSTER
		RMB	2			; DSKINFO:DIRFCB	POINTER TO FCB FOR $DIRECTORY FILE
		RMB	2			; DSKINFO:MAPFCB	POINTER TO FCB FOR $DISKMAP FILE
		RMB	2			; DSKINFO:SECTORDB	POINTER TO RDSI CONTAINING LSN, ADDRESS PARAMETERS
		RMB	LSN.SIZE		; DSKINFO:BADLSN	LSN OF LAST SECTOR THAT COULDN'T READ/WRITE/SEEK
		FDB	0			; DSKINFO:SEEKERRCNT	# SEEK ERRORS SINCE MOUNT
		FDB	0			; DSKINFO:SEEKERRSTS	16 BITS OF LAST "SEEK" STATUS IN ERROR
		FDB	0			; DSKINFO:WRITEERRCNT	# WRITE ERRORS SINCE MOUNT
		FDB	0			; DSKINFO:WRITEERRSTS	16 BITS OF LAST "WRITE" STATUS IN ERROR
		FDB	0			; DSKINFO:READERRCNT	# READ ERRORS SINCE MOUNT
		FDB	0			; DSKINFO:READERRSTS	16 BITS OF LAST "READ" STATUS IN ERROR
		FCB	0,0,0			; DSKINFO:OPSCOUNT	24 BITS OF # DRIVER OPERATIONS SINCEMOUNT
		RMB	LSN.SIZE		; DSKINFO:ERRLSN	LSN CAUSING ANY SOFT OR HARD ERROR
		RMB	1			; DSKINFO:WRITEPROTSTATE	0 --> WRITEABLE
		FCB	3			; FDUNIT		Drive number 

		
; DEVICE DRIVER BLOCK FOR FLOPPY DISK

DSKDRIVER	FDB 	DSKRESTORE		; DRIVER:DISKRESET	RESET THIS DISK DRIVER
		FDB	DSKREAD			; DRIVER:DISKREAD	INITIATE A DISK SECTOR READ
		FDB	DSKWRITE		; DRIVER:DISKWRITE	INITIATE A DISK SECTOR WRITE
		FDB	DSKWAITDONE		; DRIVER:DISKWAIT	WAIT FOR DISK I/O COMPLETE
		FDB	ILLDEVICEOP     	; DRIVER:DISKSTATUS	STATUS handled completely by SDOS1.1
		FDB	DSKCONTROL		; DRIVER:DISKCONTROL	PERFORM DISK-SPECIFIC CONTROL OPERATION
		FDB	ILLDEVICEOP     	; DRIVER:DISKWRITEPROTQ	DETERMINE IF DISK IS WRITE PROTECTED
		FDB	ILLDEVICEOP     	; DRIVER:DISKVERIFY	INITIATE A DISK SECTOR VERIFY
		FDB	ILLDEVICEOP     	; DRIVER:DISKLSNTOPSN	CONVERT LSN TO PHYSICAL CYLINDER, TRACK AND SECTOR

; FLOPPY DISK LOW LEVEL I/O

DSKCONTROL	CMPA    #CC.DISMOUNTDISK	; SINCE SDOS PASSES THIS THRU
		BEQ     DSKDISMOUNT		; B/ ITS A DISMOUNT!
		JMP     ILLDEVICEOP		; NOT A LEGAL CONTROL CALL
DSKDISMOUNT	CLRB				; CLEAR THE CARRY
		RTS
		
;
;       Take RDSI:LSN and split it up into RDSI:CYLINDER,
;       RDSI:TRACK, and RDSI:SECTOR, 
;       mapalg NOT IMPLEMENTED 
;
FDTEARLSN	LDX	RDSIPOINTER
		CLR	RDSI.SECTOR,X		; CLEAR MSB OF SECTOR, TRACK AND CYL
		CLR	RDSI.TRACK,X
		CLR	RDSI.TRACK+1,X
		CLR	RDSI.CYLINDER,X

;        ASSERT RDSI:LSN ALREADY CHECKED FOR LEGAL BY SDOS
; 
;        The formulae for computing the DCB parameters as a function
;        of number of sides, single density (SD) or double density (DD)
;        first track, SD or DD on other than first track, and number of
;        tracks on the drive are:
; 
;                SS/SD   NBPS = 128 bytes per sector
;                        NSPT = 18  sectors per track
;                        NTPC = 1 (See note 1) tracks per cylinder
;                        NCYL = #sides * #tracks (See note 2)
; 
;                note 1: This is a lie to SDOS in the case of a double
;                        sided disk, but it makes the NLSN (NSPT*NTPC*NCYL)
;                        work out to be correct.
;                note 2: #tracks is the number of tracks on the disk, including
;                        double tracks on a double track disk.
; 
;      +-------------------------------------------+
;      |        5" DRIVE       |   SINGLE SIDED    |
;      | # TRACKS ON DRIVE --> | 35   40   70   80 |
;      |         NSPT NBPS NTPC|NCYL NCYL NCYL NCYL|
;      |-----------------------+-------------------+
;      |   SS/SD  18   128    1| 35   40   70   80 |
;      |   DS/SD              2|                   |
;      +-------------------------------------------+
; 
;       To compute the sector, track and cylinder, use this formula:
;                LSN/18 --> REM --> SECTOR#
;                       --> /2  --> REM -> TRACK (HEAD)
;                               --> CYLINDER
;       where REM is the remainder from the previous step. 

		LDAA	RDSI.LSN+1,X		; SO DISCARD HIGHER LSN BYTE
		LDAB	RDSI.LSN+2,X            
		NOP				; .*echo Read_LSN:D
		JSR	DIV18			; GO DO THE FAST DIVIDE BY NSPT
                INCA				; SECTORS ON PHYSICAL DISK ARE NUMBERED 1..18
		STAA	RDSI.SECTOR+1,X		; A CONTAINS SECTOR = (LSN MOD 18)+1
		LSRB				; B CONTAINS CYL = INT(LSN/18) / 2, bit0 -> carry
		STAB	RDSI.CYLINDER+1,X	
		ROL	RDSI.TRACK+1,X		; TRACK (HEAD) = INT(LSN/18) MOD 2, head<-carry 0/1
		RTS
;
;       Fancy divide algorithm takes (A,B) and divides by NSPT (18).
;       If we have 35 track, double side,
;       18 sectors/track this is 35*2*18 LSNs =0..1259, with a max
;       quotient of 69.
;
;       Divide (A,B) by 18 (NSPT), quotient in B, remainder in A
;
DIV18		ASLB
		ROLA
		ADDA	#-18			; ADD -NSPT TO GENERATE QUOTIENT BIT
		BCS	DIV18.1			; B/ Q BIT IS ONE
		SUBA	#-18			; RESTORE BY ADDING DIVISOR; LEAVE CARRY=0
DIV18.1		ROLB				; SHIFT QUOTIENT BIT INTO QUOTIENT
		ROLA
		ADDA	#-18
		BCS	DIV18.2
		SUBA	#-18
DIV18.2		ROLB				; SHIFT QUOTIENT BIT INTO QUOTIENT
		ROLA
		ADDA	#-18
		BCS	DIV18.3
		SUBA	#-18
DIV18.3		ROLB				; SHIFT QUOTIENT BIT INTO QUOTIENT
		ROLA
		ADDA	#-18
		BCS	DIV18.4
		SUBA	#-18
DIV18.4		ROLB				; SHIFT QUOTIENT BIT INTO QUOTIENT
		ROLA
		ADDA	#-18
		BCS     DIV18.5
		SUBA	#-18
DIV18.5		ROLB				; SHIFT QUOTIENT BIT INTO QUOTIENT
		ROLA
		ADDA	#-18
		BCS	DIV18.6
		SUBA	#-18
DIV18.6		ROLB				; SHIFT QUOTIENT BIT INTO QUOTIENT
		ROLA
		ADDA	#-18
		BCS	DIV18.7
		SUBA	#-18
DIV18.7		ROLB				; SHIFT QUOTIENT BIT INTO QUOTIENT
		ROLA
		ADDA	#-18
		BCS	DIV18.8
		SUBA	#-18
DIV18.8		ROLB
		RTS

DSKOPSCOUNT	INC     DSKINFO.OPSCOUNT+2,X   	; COUNT # OPERATIONS ISSUED TO disk
		BNE     DSKOPSCOUNT1
		INC     DSKINFO.OPSCOUNT+1,X
		BNE     DSKOPSCOUNT1
		INC     DSKINFO.OPSCOUNT,X
DSKOPSCOUNT1	rts

; PREPARE A SINGLE SECTOR TRANSFER

DSKPREP 	LDX     DCBPOINTER		; GET DCB POINTER
		jsr	DSKOPSCOUNT		; incr count of I/O operations done
		LDAA    dcb.fdunit,X            ; get this dcb drive number
		STAA	DRV
		CLR	DCB.LASTERROR,X		; CLEAR ANY ERROR
		CLR	DCB.LASTERROR+1,X
		LDX	DSKINFO.SECTORDB,X	; GET RDSI POINTER
		STX	RDSIPOINTER		; SAVE IT
		JSR 	FDTEARLSN		; CONVERT RDSI:LSR -> RDSI:TRACK/CYLINDER/SECTOR
		LDAA 	RDSI.SECTORBASE,X	; POINTER TO ACTUAL SECTOR CONTENTS
		LDAB 	RDSI.SECTORBASE+1,X
		STAA	DDATA
		STAB	DDATA+1
		LDAA 	RDSI.CYLINDER+1,X	
		STAA	TRK
		LDAA 	RDSI.SECTOR+1,X	
		STAA	SECT
		LDAA 	RDSI.TRACK+1,X	
		STAA	SIDE
		CLR	RDSI.STATE,X		; RESET SECTOR STATE TO "IDLE"
		RTS
		
; READ/WRITE -- DO SINGLE SECTOR TRANSFER

DSKREAD 	JSR	DSKPREP
		JSR	RDSEC			; DO I/O OPERATION WITH ACTIVE WAIT: NO INTERRUPTS :-(
		BNE	DSKERR
		LDX	DDATA			
		CLC				; .*mX-80:RdSec
		RTS

DSKWRITE 	JSR	DSKPREP
		JSR	WRSEC			; DO I/O OPERATION WITH ACTIVE WAIT: NO INTERRUPTS :-(
		BNE	DSKERR
		LDX	DDATA			
		CLC				; .*mX-80:WrSec
		RTS
		
DSKERR		LDX     #ERR.DISKSEEK
		BITA 	#$10
		bne	dskerr1			; seek error reported by controler status reg
		LDX     #ERR.DISKWRITE
		BITA 	#$20			
		bne	dskerr1			; WRITE FAULT reported by controler status reg
		LDX     #ERR.DSKWRTPROT
		BITA 	#$40			
		bne	dskerr1			; WRITE PROTECT reported by controler status reg
		LDX     #ERR.DISKREAD		; ELSE ASUME LOST DATA OR CRC ERROR HAS BEEN reported by controler status reg
DSKERR1		STX	$00			; TXAB X=SDOS ERROR CODE (16 BITS) -> (A,B)
		LDAA	$00
		LDAB	$01		
		LDX     DCBPOINTER		; GET DCB POINTER
		STAA    DCB.LASTERROR,X		; SAVE THE ERROR
		STAB    DCB.LASTERROR+1,X
		LDX	$00			; GET BACK ERROR IN X-REG
		SEC
		RTS	
	
DSKRESTORE
DSKWAITDONE
		CLRB                           ; CLEAR THE CARRY
		RTS


RDSIPOINTER	RMB	2


; DISK DRIVERS FOR SOUTHWEST TECHNICAL PRODUCTS MF-68

; INPUT PARAMS

DRV    RMB 1         ; DRIVE TO OPERATE ON
TRK    RMB 1         ; TRACK TO READ/WRITE
SECT   RMB 1         ; SECTOR TO READ/WRITE
SIDE   RMB 1         ; SIDE TO READ/WRITE
DDATA  RMB 2         ; POINTER TO DATA BUFFER (MUST HAVE 128 BYTES)

; COMMANDS FOR WD1771 CONTROLLER CHIP
;
FDRSC  EQU $0B       ; RESTORE
FDSKI  EQU $1B       ; SEEK
FDRDC  EQU $8C       ; READ A SECTOR
FDWRC  EQU $AC       ; WRITE A SECTOR

; ADDR OF WD1771 CONTROLLER CHIP REGISTERS 

	if RAM64K=1

DRVREG set $ff14
CMDREG set $ff18
TRKREG set $ff19
SECREG set $ff1A
DATREG set $ff1B

	else
	
DRVREG EQU $8014
CMDREG EQU $8018
TRKREG EQU $8019
SECREG EQU $801A
DATREG EQU $801B

	fin

; DRIVER VARS

CURDRV FCB $FF       ; PRESENTLY SELECTED DRIVE #
CTRK0  RMB 4         ; TRACK STATE TABLE
RCNT   RMB 1         ; RETRY COUNT
SIDEBT RMB 1         ; SIDE SELECTION BIT

; INIT THE DISK SYSTEM

INTDK  CLR CURDRV    ; ASSUME DRIVE 0 BOOTED
       LDAA #$FF
       STAA CTRK0       
       STAA CTRK0+1
       STAA CTRK0+2       
       STAA CTRK0+3
DUMMY  RTS       

; READ A SECTOR
;
RDSEC  JSR SELDRV 
RDSEC1 JSR READ       ; GETA SECTOR
       BEQ QUIT10     ; OK
       DEC RCNT       ; RETRY AGAIN?
       BNE RDSEC1     ; YES
       BRA QERR

; WRITE A SECTOR
;
WRSEC  JSR SELDRV 
WTSEC1 JSR WRITE
       BEQ QUIT10     ; OK
       DEC RCNT       ; TRY AGAIN?
       BNE WTSEC1     ; YES
QERR   TSTA           ; A HAS THE STATUS BITS WITH ERROR 
QUIT10 RTS

; READ A SECTOR (A=TRK, B=SECTOR, X=CTRKx)
;
READ   JSR SEEK
       LDAA #FDRDC    ; READ
       ADDA SIDEBT
       STAA CMDREG     
       JSR DEL56U     ; DELAY
       LDX DDATA      ; GET BUFFER ADDRESS
       LDAB #128      ; 128 BYTES/SECTOR     
READ1  LDAA CMDREG     
       BITA #$02      ; DATA REG FULL?
       BNE READ2      ; YES
       BITA #1        ; BUSY?
       BNE READ1      ; YES
       BRA READ3      ; ERROR
READ2  LDAA DATREG    ; GET A BYTE
       STAA 0,X       ; STORE IN BUFFER
       INX             
       DECB            
       BNE READ1      ; DO AGAIN
       BSR WBUSY      ; WAIT TILL DONE
READ3  ANDA #$1C      ; MASK OF STATUS BITS
       RTS             
                       
WBUSY  LDAA CMDREG     
       BITA #1        ; BUSY?
       BNE WBUSY      ; YES
       RTS

; WRITE A SECTOR (A=TRK, B=SECTOR, X=CTRKx)

WRITE  JSR SEEK
       LDAA #FDWRC    ; WRITE COMMAND
       ADDA SIDEBT
       STAA CMDREG     
       JSR DEL56U      
       LDX DDATA      ; GET BUFFER ADDRESS
       LDAB #128      ; 128 BYTES/SECTOR
WRITE1 LDAA CMDREG     
       BITA #2        ; REG EMPTY?
       BNE WRITE2     ; YES
       BITA #1        ; BUSY?
       BNE WRITE1     ; YES
       BRA QERR       ; ERROR
WRITE2 LDAA 0,X       ; GET A BYTE
       STAA DATREG     
       INX             
       DECB            
       BNE WRITE1     ; DO AGAIN
       JSR WBUSY      ; WAIT FOR BUSY
WRITE3 ANDA #$7C      ; MASK OFF STATUS BITS
       RTS

; SEEK A=TRACK, B=SECTOR, X=CTRKx

SEEK   CMPA TRKREG    ; ON TRACK?
       BEQ SEEK2      ; YES
       STAA DATREG    ; NO, STORE TRACK#
       JSR DEL56U      
       STAA 0,X       ; SAVE CURRENT TRACK OF DRIVE
       LDAA #FDSKI    ; SEEK COMMAND
       STAA CMDREG     
       JSR DEL56U      
       JSR WBUSY      ; WAIT FOR BUSY
SEEK2  STAB SECREG    ; SET SECTOR
       JSR DEL56U
       LDAA SIDE
       BEQ SEEK3
       LDAA #$08      ; SELECT SIDE 1
SEEK3  STAA SIDEBT       
       RTS

; DEL56U- DELAY 56us INCLUDING THE CALL TO DELAY56U

DEL56U JSR DELAY2
DELAY2 JSR DELAY3
DELAY3 RTS

; FIND TRACK- RETURN X->TRACK TABLE FOR CURDRV

FNDTRK LDX #CTRK0     ; POINT TO TABLE
       LDAA CURDRV
       BEQ FNDTK3
FNDTK2 INX
       DECA
       BNE FNDTK2
FNDTK3 RTS

; RESTORE SEEK TRACK0

RESTOR LDAA #FDRSC    ; RESTORE COMMAND
       STAA CMDREG
       JSR DEL56U
       JSR WBUSY
       RTS

; SELECT THE DRIVE
; RETURN A=TRACK, B=SECTOR, X=CTRKx

SELDRV BSR FNDTRK     ; SAVE TRACK FOR CURRENT DRIVE
       LDAA TRKREG     
       STAA 0,X        
       LDAA DRV       ; GET DRIVE 
       STAA CURDRV     
       STAA DRVREG    ; SELECT THE DRIVE
       BSR FNDTRK     ; LOAD TRACK FOR NEW DRIVE
       LDAA 0,X       ; A=CURRENT DRIVE TRACK
       STAA TRKREG     
       CMPA #$FF      ; INITIALIZED?
       BNE SELD1      ; YES
       BSR RESTOR     ; SEEK TRACK0
SELD1  LDAA #5        ; SET RETRY COUNT
       STAA RCNT       
       LDAA TRK       ; GET TRACK#        
       LDAB SECT      ; GET SECTOR#
       RTS            


; High level EMULATOR (HLE) for swtpc 6800 harddisk with
; XIBEX S1410 Winchester Disk Controller and
; TANDOM TM-602S 5MB DRIVE


dcbname.hd      fcc     'HD:'
                fcb     0
DCB.HD          FCB     1    			; DCB:DONEFLAG	; 0 --> DEVICE IS BUSY; <>0 --> DEVICE IS DONE
                FDB     0    			; DCB:LASTERROR	; IF DCB IS DONE, CONTAINS ERROR STATUS (0 = NONE )
                FDB     dcbname.HD		; DCB:NAME	; POINTER TO DEVICE NAME STRING TERMINATED BY ZERO BYTE
                FDB     0			; DCB:NEXTDCB	; POINTER TO NEXT DCB IN LIST OR ZERO
                FDB     HDDRIVER		; DCB:DRIVER	; POINTER TO DRIVER ENTRY POINT LIST

								; DISK GEOMETRY
		FDB	128     		; DSKINFO:NBPS	; NUMBER OF BYTES PER SECTOR
		FDB	64			; DSKINFO:NSPT	; NUMBER OF SECTORS PER TRACK
		FDB	4			; DSKINFO:NTPC	; NUMBER OF TRACKS PER CYLINDER (=surfaces)
		FDB	153			; DSKINFO:NCYL	; NUMBER OF CYLINDERS PER DRIVE

								; THE FOLLOWING ARE FILLED FROM THE BOOT SECTOR
		RMB	1			; DSKINFO:NSPC		NUMBER OF SECTORS PER CLUSTER
		RMB	LCN.SIZE		; DSKINFO:MINALLOC	ALLOCATION MINIMUM FOR NEW FILES
		RMB	LCN.SIZE		; DSKINFO:MIDALLOC	ALLOCATION MIN FOR FILE EXTENSION
		RMB	2			; DSKINFO:MAPALGORITHM	CODE TO SELECT LOGICAL TO PHYSICAL SECTOR MAP ALGORITHM

								; CONTAINS DISK ID FOR MOUNTED DISKS
		RMB	1			; DSKINFO:LOG2NBPS	LOG BASE 2 OF DSKINFO:NBPS
		RMB	2			; DSKINFO:NBPSM1	= NBPS-1 FOR USE AS MASK (QUICK "MOD NBPS")
		RMB	LSN.SIZE		; DSKINFO:NLSN		NUMBER OF LSNS FOR THIS DISK = NSPT*NTPC*NCYL
		RMB	LCN.SIZE		; DSKINFO:NLCN		NUMBER OF LCNS FOR THIS DISK = NLSN/NSPC
		RMB	2			; DSKINFO:NBPC		NUMBER OF BYTES PER CLUSTER
		RMB	LCN.SIZE		; DSKINFO:RANDMAP	"RANDOM" LCN TO DISTRIBUTE NEW FILES
		RMB	LSN.SIZE		; DSKINFO:MAPLSN	LSN OF 1ST SECTOR IN DISK...

								; ALLOCATION MAP CLUSTER
		RMB	2			; DSKINFO:DIRFCB	POINTER TO FCB FOR $DIRECTORY FILE
		RMB	2			; DSKINFO:MAPFCB	POINTER TO FCB FOR $DISKMAP FILE
		RMB	2			; DSKINFO:SECTORDB	POINTER TO RDSI CONTAINING LSN, ADDRESS PARAMETERS
		RMB	LSN.SIZE		; DSKINFO:BADLSN	LSN OF LAST SECTOR THAT COULDN'T READ/WRITE/SEEK
		FDB	0			; DSKINFO:SEEKERRCNT	# SEEK ERRORS SINCE MOUNT
		FDB	0			; DSKINFO:SEEKERRSTS	16 BITS OF LAST "SEEK" STATUS IN ERROR
		FDB	0			; DSKINFO:WRITEERRCNT	# WRITE ERRORS SINCE MOUNT
		FDB	0			; DSKINFO:WRITEERRSTS	16 BITS OF LAST "WRITE" STATUS IN ERROR
		FDB	0			; DSKINFO:READERRCNT	# READ ERRORS SINCE MOUNT
		FDB	0			; DSKINFO:READERRSTS	16 BITS OF LAST "READ" STATUS IN ERROR
		FCB	0,0,0			; DSKINFO:OPSCOUNT	24 BITS OF # DRIVER OPERATIONS SINCEMOUNT
		RMB	LSN.SIZE		; DSKINFO:ERRLSN	LSN CAUSING ANY SOFT OR HARD ERROR
		RMB	1			; DSKINFO:WRITEPROTSTATE	0 --> WRITEABLE
		FCB	0			; FDUNIT		Drive number 


; DEVICE DRIVER BLOCK FOR HARD DISK

HDDRIVER	FDB 	DSKRESTORE		; DRIVER:DISKRESET	RESET THIS DISK DRIVER
		FDB	HDREAD			; DRIVER:DISKREAD	INITIATE A DISK SECTOR READ
		FDB	HDWRITE			; DRIVER:DISKWRITE	INITIATE A DISK SECTOR WRITE
		FDB	DSKWAITDONE		; DRIVER:DISKWAIT	WAIT FOR DISK I/O COMPLETE
		FDB	ILLDEVICEOP     	; DRIVER:DISKSTATUS	STATUS handled completely by SDOS1.1
		FDB	DSKCONTROL		; DRIVER:DISKCONTROL	PERFORM DISK-SPECIFIC CONTROL OPERATION
		FDB	ILLDEVICEOP     	; DRIVER:DISKWRITEPROTQ	DETERMINE IF DISK IS WRITE PROTECTED
		FDB	ILLDEVICEOP     	; DRIVER:DISKVERIFY	INITIATE A DISK SECTOR VERIFY
		FDB	ILLDEVICEOP     	; DRIVER:DISKLSNTOPSN	CONVERT LSN TO PHYSICAL CYLINDER, TRACK AND SECTOR

HDCMD.HEARTBEAT	EQU	$01
HDCMD.SELDRV	EQU	$02
HDCMD.SETSECT	EQU	$03
HDCMD.SETSURF	EQU	$04
HDCMD.SETTRACK	EQU	$05
HDCMD.SETADDRH	EQU	$06
HDCMD.SETADDRL	EQU	$07
HDCMD.READ	EQU	$08
HDCMD.WRITE	EQU	$09


		if ram64k=1

HDCMD		EQU 	$FF10	; PORTS FOR HARD DISK HIGH LEVEL EMULATOR INTERFACE
HDDATA		EQU 	$FF11		

		else

HDCMD		EQU 	$8010	; PORTS FOR HARD DISK HIGH LEVEL EMULATOR INTERFACE
HDDATA		EQU 	$8011		

		fin


HDPREP 		LDAA	#$55			; TEST IF HD HLE CONTROLER IS RESPONDING
		STAA	HDDATA
		LDAA	#HDCMD.HEARTBEAT	
		STAA	HDCMD
		LDAA	HDDATA
		CMPa	#$67			; SHOULD GET THIS REPLY 
		BEQ	HDHLEOK
		LDX     #ERR.DEVICENOTREADY	; WE ARE RUNNING WITH HD DISABLED OR IN ANOTHER SIMULATOR 
		SEC				; WITHOUT HLE HARD DRIVE EMULATOR, OR EVEN IN REAL HW!
		RTS				; IN ANY CASE, THERE IS NO HARD DISK -> SIGNALS DEVICE NOT READY ERROR
HDHLEOK		LDX     DCBPOINTER		; GET DCB POINTER
		jsr	DSKOPSCOUNT		; incr count of I/O operations done
		LDAA    dcb.fdunit,X            ; get this dcb drive number
		LDAB	#HDCMD.SELDRV		; HD COMMAND: SELECT DRIVE
		STAB	HDCMD
		STAA	HDDATA
		CLR	DCB.LASTERROR,X		; CLEAR ANY ERROR
		CLR	DCB.LASTERROR+1,X
		LDX	DSKINFO.SECTORDB,X	; GET RDSI POINTER
		STX	RDSIPOINTER		; SAVE IT
						; CONVERT RDSI:LSR -> RDSI:CYLINDER/SECTOR
		LDX	RDSIPOINTER
		CLR	RDSI.SECTOR,X		; CLEAR MSB OF SECTOR, TRACK 
		CLR	RDSI.TRACK,X
		CLR	RDSI.CYLINDER,X	

		LDAA	RDSI.LSN+1,X		; DISCARD HIGHER LSN BYTE
		LDAB	RDSI.LSN+2,X            
		PSHB
		ANDB	#63			; SECTOR = LSN AND 63
		STAB	RDSI.SECTOR+1,X		; B CONTAINS SECTOR = 0..63
		STAB	HDDATA
		LDAB	#HDCMD.SETSECT		; HD COMMAND: SET SECTOR
		STAB	HDCMD
		PULB
		LSRA				; LSN = LSN DIV 64
		RORB
		LSRA				
		RORB
		LSRA				
		RORB
		LSRA				
		RORB
		LSRA				
		RORB
		LSRA				
		RORB
		PSHB
		ANDB	#3			; SURFACE = LSN AND 3
		STAB	RDSI.TRACK+1,X		; B CONTAINS SURFACE = 0..3
		STAB	HDDATA
		LDAB	#HDCMD.SETSURF		; HD COMMAND: SET SURFACE
		STAB	HDCMD
		PULB				; LSN = LSN DIV 4
		LSRA				
		RORB
		LSRA				
		RORB
		STAB	RDSI.CYLINDER+1,X	; B CONTAINS TRACK 0..152
		STAB	HDDATA
		LDAB	#HDCMD.SETTRACK		; HD COMMAND: SET TRACK
		STAB	HDCMD

		LDAA 	RDSI.SECTORBASE,X	; POINTER TO ACTUAL SECTOR CONTENTS
		STAA	DDATA
		STAA	HDDATA
		LDAA	#HDCMD.SETADDRH		; HD COMMAND: SET ADDR (MSB)
		STAA	HDCMD
		LDAB 	RDSI.SECTORBASE+1,X	; POINTER TO ACTUAL SECTOR CONTENTS
		STAB	DDATA+1
		STAB	HDDATA
		LDAB	#HDCMD.SETADDRL		; HD COMMAND: SET ADDR (LSB)
		STAB	HDCMD

		CLR	RDSI.STATE,X		; RESET SECTOR STATE TO "IDLE"
		RTS

HDREAD		JSR	HDPREP
		BCS	HDERR
		LDAA	#HDCMD.READ		; HD COMMAND: READ SECTOR
		STAA	HDCMD
		LDAA	HDDATA			; retried status of hd operation
		BEQ	HDRDOK
		LDX     #ERR.DISKREAD
HDERR		JMP	DSKERR1
HDRDOK		LDX	DDATA			
		CLC				; .*mX-80:HdSec
		RTS
		
HDWRITE		JSR	HDPREP
		BCS	HDERR
		LDAA	#HDCMD.WRITE		; HD COMMAND: WRITE SECTOR
		STAA	HDCMD
		LDAA	HDDATA
		BEQ	HDRDOK
		LDX     #ERR.DISKWRITE
		BRA	HDERR
		


; DEVICE CONTROL BLOCK FOR CLOCK 

CLOCKSTR	FCC     'CLOCK:'
                fcb     0

CLOCKDCB        FCB     1    			; DCB:DONEFLAG	; 0 --> DEVICE IS BUSY; <>0 --> DEVICE IS DONE. CLOCK'S ALWAYS DONE
                FDB     0    			; DCB:LASTERROR	; IF DCB IS DONE, CONTAINS ERROR STATUS (0 = NONE )
                FDB     CLOCKSTR		; DCB:NAME	; POINTER TO DEVICE NAME STRING TERMINATED BY ZERO BYTE
                FDB     0			; DCB:NEXTDCB	; POINTER TO NEXT DCB IN LIST OR ZERO
                FDB     CLOCKDRIVER		; DCB:DRIVER	; POINTER TO DRIVER ENTRY POINT LIST

; DEVICE DRIVER BLOCK FOR CLOCK CONSOLE

CLOCKDRIVER	FDB 	CLOCKOPEN	; DRIVER:OPEN	OPEN FILE
		FDB	CLOCKCLOSE	; DRIVER:CLOSE	CLOSE FILE
		FDB	CLOCKREADA	; DRIVER:READA	READ ASCII
		FDB	ILLDEVICEOP	; DRIVER:WRITEA	WRITE ASCII WRITEA IS A NO-NO
		FDB	CLOCKREADB	; DRIVER:READB	READ BINARY
		FDB	CLOCKWRITEB	; DRIVER:WRITEB	WRITE BINARY
		FDB	ILLDEVICEOP	; DRIVER:CREATE	CREATE FILE YOU UPDATE THE CLOCK, NOT REBUILD IT (CREATE)
		FDB	ILLDEVICEOP	; DRIVER:RENAME	RENAME FILE RENAME IT TO WHAT? CLOCK-RADIO: ???
		FDB	ILLDEVICEOP	; DRIVER:DELETE	DELETE FILE YOU CAN'T GET RID OF THE CLOCK, NEITHER
		FDB	ILLDEVICEOP	; DRIVER:CONTROL NO CONTROL FUNCTIONS
		FDB	CLOCKSTATUS     ; DRIVER:STATUS	READ DEVICE (DRIVER) STATUS SAY "I'M A CLOCK, TICK-TOCK"
		FDB	CLOCKRESET	; DRIVER:RESET	RESET DRIVER (ON BOOT)
		FDB	CLOCKPFRESTART  ; DRIVER:STARTIO	WHO UNPLUGGED ME???

TEMPX		EQU	0

CLOCKOPEN       EQU     *       	; HOW ABOUT LOOKING AT YOUR $9 TI CHEAPIE, MAC!
CLOCKCLOSE      EQU     *       	; WHAT AM I SUPPOSED TO DO, PUT THE CLOCK AWAY??
CLOCKPFRESTART  EQU     *       	; AM I SUPPOSED TO KEEP TIME WITH NO POWER???
		JMP	OKRTS           ; TOUGH!

CLOCKSPRUNG     JMP     ILLDEVICEOP
CLOCKSTATUS     CMPA    #SC.GETTYPE	; The only status syscall accepted is SC:GETTYP, which returns DVTYF.CLOCK
		BNE     CLOCKSPRUNG	; 
		LDX	SDOS+SDOS.IOBLOCKPTR
		JSR     SDOS+SDOS.CHECKRDLEN    ; HAS HE GOT A BYTE SPACE
		FDB     1
		LDX     SCBLK.RDBUF,X   ; GET THE BUFFER POINTER (where syscall return values are to be set)
		LDAA    #DVTYP.CLOCK    ; I'M ALIVE AND TICKING (HOPEFULLY!)
		STAA    0,X	
		JMP	OKRTS
CLOCKWRITEB	EQU	*
CLOCKRESET	EQU 	*
		JMP	OKRTS

CLOCKREADB	JSR     SDOS+SDOS.CHECKRDLEN
		FDB     6       	; HE BETTER HAVE 6 BYTES AT LEAST
		LDX     #SDOS		; READ CURRENT CLOCK SETTING
		LDAB    #6		; TO STACK
CLOCKRB1	LDAA    SDOS.CLOCK,X
		INX
		PSHA
		DECB
		BNE     CLOCKRB1
		LDX     SDOS+SDOS.IOBLOCKPTR
		LDX     SCBLK.RDBUF,X
		LDAB    #6		; PUT CLOCK IN READ BUFFER
CLOCKRB2        PULA
		STAA    5,X
		DEX
		DECB
		BNE     CLOCKRB2
		JMP	OKRTS

CLOCKREADA	JSR     SDOS+SDOS.CHECKRDLEN
		FDB     17 		; ENOUGH FOR HH:MM:SS MM/DD/YY
		LDX     SDOS+SDOS.IOBLOCKPTR
		LDAA    SCBLK.RDLEN,X	; SEE IF ENOUGH SPACE FOR CR
		BNE	CLOCKREADA0
		LDAB    SCBLK.RDLEN+1,X	
		CMPB    #18
		BLO     CLOCKREADA1	; B/ NO
CLOCKREADA0	INC     SCBLK.RPLEN+1,X	; YES, INCLUDE THE CR IN THE COUNT
CLOCKREADA1	LDX     SCBLK.RDBUF,X
		BLO     CLOCKREADA2	; B/ CR NOT INCLUDED
		LDAA    #13		; <CR>
		STAA    17,X
CLOCKREADA2	LDAA    #17
		STX     TEMPX
		LDX     #TIMESTR
CLOCKREADA3	LDAB    0,X
		INX
		STX     TEMPX+2
		LDX     TEMPX
		STAB    0,X
		INX
		STX     TEMPX
		LDX     TEMPX+2
		DECA
		BNE     CLOCKREADA3
		JMP	OKRTS

TIMESTR   	FCC     '00:00:00 08/16/82'
  
ATTNCHECK	
DEBUGSYSCALL	
		jmp	okrts


		if *>>IOBUF
		? IO package too big! overlaps IOBUF
		fin
 		
		end




*
* Contains SDOS11G4DEFS.ASM, SDOS11GPART1.ASM and SDOS11GPART2.ASM
* mergen in one big file 
* all checksum/serial validations removed (marked with ZZZ as comment in source code)
*



        TITLE *** SDOS -- SOFTWARE DYNAMICS 6800/6809 OPERATING SYSTEM (C) 1978 ***
        PAGE     SDOS REVISION HISTORY
SC:GETLINEFLAGSHINT       EQU     $34     *** FIGURE OUT WHERE TO PUT THIS!!
        NAME     SDOS1.1
********************************************************************************
******** Copyright (C) 1978, 1979, 1980, 1981, 1982 by Software Dynamics ********
********************************************************************************
*       This file, and all derivatives of it, in either source or object format,
*       are a copyright and Trade Secret of Software Dynamics.
*       Possession of its contents, modification or distribution of all
*       or any part of this information without explicit written permission
*       from Software Dynamics is strictly prohibited.
***************************************************************************
*
*       SDOS REVISION HISTORY:
*
*       9/2/78  SDOS1.0f        Original SDOS for 6800 only
*
*       11/21/81        SDOS1.1c        6800/6809 SDOS identical to SDOS1.0f
*                       All bugs fixed by 1.0f patch file are corrected
*                       Can use SDOS1.1 with I/O packages built for SDOS1.0f
*                       MIKBUG no longer accepted
*
*       1/2/82          SDOS1.1d        Trivial fixes to 1.1c
*       2/1/82          SDOS1.1e        More fixes
*       3/16/82         SDOS1.1f        6809 Test flight version. Works fine.
*
*       8/16/82         SDOS1.1g        Several modifications.
*                                       1) Changed so serialnumber can be
*                                          in fixed memory location, to allow
*                                          SDOS to run on mass-produced computers
*                                          that have boot ROMs that cannot be
*                                          changed to match requirements of
*                                          encryption scheme.
*                                       2) Enhanced performance of Block move
*                                          for 6800 slightly.
*                                       3) Improved disk I/O to enhance
*                                          performance on floppies.
*                                       4) Fixed "LOG doesn't print
*                                          characters typed on CONSOLE:"
*                                       5) Verifies that SERIALNUMBER.SYS
*                                          is an encrypted file
        page
*       Known Bugs:
*               After a Write at EOF, SC:GETEOF doesn't always claim
*               that EOF condition has occurred.
*
        page
*   SDOS1.1 improvements to SDOS1.0f:
*   1)  Fixed sparse file problem.
*   2)  Fixed Rename to same name to re-hash to proper directory slot.
*   3)  Replaced block move by very fast block move routine; added entry point
*       for fast block move to entry point table.
*   4)  Installed Illegal LSN check in SDOS so it need not be replicated
*       in drivers.
*   5)  Changed Mount logic to use BOOT:DIRLSN pointer instead of NLCN/2.
*       SDOS now verifies that DIRECTORY.SYS is present in directory entry
*   6)  Dumpbuffers modified to move contents of modified FCBs back
*       to disk.
*   7)  EXIT changed so that if error when fetching DEFAULTPROGRAM,
*       then the disk is dismounted and SDOS tries again.
*   8)  Installed Serial Numbering (SERIALNUMBER.SYS) in SDOSINIT.
*       SERIALNUMBER.SYS chains to INITIALIZE.SYS if present,
*       and sets up INITIALIZE.DO as DO file.
*       Added Decrypting loader for encrypted files.
*   9)  Changed Disk File and Device drivers to zero column count on Ascii:FF,
*       decrement column count on Ascii:BS, and to advance column count to
*       next multiple of 8 on Ascii:HT.
*   10) Modified Dismount to delete ErrorMsgs.sys if it is marked as deleted.
*       Also modified SDOS to allow ErrorMsgs.sys to be opened on the disk
*       selected by DEFAULTDISK.
*   11) Changed so Dumpbuffers no longer checks for open files; now only
*       Dismount checks for open files.
*   12) Changed Dumpbuffers so it do it does NOT mark sectors as invalid.
*   13) Modified SetMap logic to mark Last Bad LSN as invalid, and mark
*       all sectors in the pool as invalid.
*   14) Changed PARSENAME so it no longer skips leading blanks on disk file name
*   15) Changed checksum over SDOS so it cannot be trivially defeated by
*       exchanging 2 bytes, and so that it is statically computed at assembly time.
*   16) Modified CHAIN to make a Zero start addresss illegal. Also revised
*       so CHAIN will return errors to caller if no bytes are loaded, and to
*       use the stack at the top of the address space once some bytes are loaded.
*   17) Added patch space to SDOS.
*   18) Added check in Disk File/Device driver so that ^C^C...
*       while "READA"ing nulls will terminate relatively quickly.
*   19) Fixed DisplayError to close Log channel if it gets an error, and
*       then try to display the error again before giving up completely.
*   20) Changed file name parser to recognize disk device names of the form
*       xxxx:<blank or control char> so that D0:<CR> is recognized properly.
*   21) Changed Disk File Close to automaticallly deallocate extra space
*       allocated to a file when the FCB is freed.
*   22) All updates to a file (Create, Rename, Writea, WriteB, CC:SetFileSize)
*       cause the file creation date to be modified, and to reset a new
*       bit in the directory flags that sez: "This file has been backed up."
*   23) Added SYSCALL:LUNNAME to convert a logical unit number into the text string
*       that gives the name of that device.
*   24) Added SC:GETFILEDATE, SC:GETFILEPROT, CC:SETFILEDATE, CC:SETFILESIZE,
*       CC:SETFILEPROT to allow utility programs to manipulate files more easily.
*   25) Need to add disassembler confusers around the code:
*       1) assemble in location dependent code
*       2) Mix data constants into the code
*       3) insert dummy instructions into code whose body overlaps
*          a real instruction to throw off disassembly synchronization.
*   26) Allow CC:DUMPBUFFERS to be invoked on a file; dumps all sectors
*       intended for the device
*   27) SYSCALL:CREATE syscall block extension optionally specifies file size
*   28) ERR:NOSUCHPROGRAM issued if LOAD/CHAIN can't find file
*   29) Date not set --> can't create or update files!
*   30) Modified CC:Position for disk device and files to zero the column count
*   31) Added SYSCALL:DELAY, (dummy) SYSCALL:INTERLOCK system calls
*   32) Implemented Write Protect bit (can't rename, delete, write or chop)
*   33) Added implied positioning on Read/Write system calls
*   34) Added CC:POSITIONTOEND file system call
*   35) Made SDOS:ERROR logic fully re-entrant by placing errorcode in TEMPX
*   36) Made SC:GETERRORSTATS a built-in function of SDOS disk driver.
*       Includes Operation Count, Error Statuses, and LastErroringLSN
*
*       END REVISION HISTORY

*
*       Things to do:
*
*       for SDOS 1.2
*               after user-selectable timeout, start dumping dirty pages
*               optimize interface to disk read/write routines
*               add write protect checking
*               gettype should return value of DCB:DVTYP byte
*               should not allow ':' as last character of file name
*               reply buffer outside of user space or in scratchpad s/b illegal
*
        WITH    WI=107,DE=51
*
        IFUND   MEMSIZE
MEMSIZE EQU     56      We can't beleive you would want it smaller...
        FIN
K       EQU     1024

        IF      M6800!M6801
SDOS:ESTSIZE    EQU     $3200
        ELSE    (M6809)
SDOS:ESTSIZE    EQU     $2E00
        FIN

        IFUND   CODE
CODE     EQU     MEMSIZE*K-SDOS:ESTSIZE
        FIN

LISTDEFS        EQU     1       FORCE LISTING OF EQUATES FILE
SYSTEMDEFS      EQU     1       WE WANT ALL THE DEFINITIONS!

        TABS      10,18,30        TAB SETTING FOR LISTING SDOS PROPER
        page    *** SDOS Boot time Initialization Code ***
*       "SDOSINIT" -- SDOS INITIALIZING CODE
*
        PAGE    *** SDOS 1.1 DEFINITIONS ***
*       SDOS 1.1 DEFINITIONS FILE (AS OF 8/16/82)
*
SDOSVERSION     EQU     $11     1.1 IN HEX
        PSR     0       DON'T LIST SKIPPED DEFINITIONS

        IFUND   LISTDEFS
LISTDEFS        EQU     0
        FIN

        IF      LISTDEFS
        ELSE
        LIST    0
        FIN

*
*
*       The Definitions are broken into 3 parts:
*               A) THOSE NEEDED TO ASSEMBLE SDOS PROPER OR SYSTEM PROGRAMS
*               B) THOSE NEEDED TO BUILD AN I/O PACKAGE (A SUBSET OF "A")
*               C) THOSE NEEDED BY EVERYDAY USER PROGRAMS (A SUBSET OF "B")
*

        IFUND   SYSTEMDEFS
SYSTEMDEFS      EQU     0       DON'T WANT SYSTEM DEFINITIONS
        FIN

        IFUND   IOPKDEFS
IOPKDEFS        EQU     0       DON'T WANT I/O PACKAGE DEFINITIONS
        FIN

SYSCALL$        EQU     $FB     JMP TO SDOS; RESERVED SYSCALL ENTRY POINT
*       CONTENTS OF ($FC,$FD) POINTS TO END OF USER RAM
*       CONTENTS OF ($FE,$FF) ARE SACRED; THEY BELONG TO THE ROM
        PAGE
*       SYSCALL$ OPCODE DEFINITIONS
*
        ORG     0
SYSCALL:OPEN    RMB     1       OPEN FILE
SYSCALL:CREATE  RMB     1       CREATE A NEW FILE
SYSCALL:CLOSE   RMB     1       CLOSE A FILE
SYSCALL:RENAME  RMB     1       RENAME A FILE
SYSCALL:DELETE  RMB     1       DELETE A FILE
SYSCALL:LOAD    RMB     1       LOAD AN OVERLAY
SYSCALL:CHAIN   RMB     1       CHAIN TO A FILE
SYSCALL:CREATELOG       RMB     1       CREATE THE LOG FILE
SYSCALL:CLOSELOG        RMB     1       CLOSE THE LOG FILE
SYSCALL:DISKDEFAULT     RMB     1       SELECT DEFAULT DISK DEVICE
SYSCALL:READA   RMB     1       READ ASCII BYTES FROM A FILE
SYSCALL:READB   RMB     1       READ BINARY BYTES FROM A FILE
SYSCALL:WRITEA  RMB     1       WRITE ASCII BYTES TO A FILE
SYSCALL:WRITEB  RMB     1       WRITE BINARY BYTES TO A FILE
SYSCALL:CONTROL RMB     1       PERFORM A CONTROL OPERATION ON A FILE/DEVICE
SYSCALL:STATUS  RMB     1       READ FILE/DEVICE STATUS
SYSCALL:WAITDONE        RMB     1       WAIT FOR I/O ON CHANNEL TO COMPLETE
SYSCALL:EXIT    RMB     1       GIVE CONTROL BACK TO THE OPERATING SYSTEM
SYSCALL:ERROREXIT       RMB     1       EXIT TO SYSTEM WITH ERROR CODE
SYSCALL:SETERROR        RMB     1       REPORT AN ERROR TO THE SYSTEM
SYSCALL:GETERROR        RMB     1       READ BACK THE LAST ERROR CODE
SYSCALL:DISPERROR       RMB     1       DISPLAY ERROR MESSAGE CORRESPONDING TO LAST ERROR CODE
SYSCALL:KILLPROOF       RMB     1       PREVENT USER PROGRAM FROM BEING KILLED
SYSCALL:KILLENABLE      RMB     1       ALLOW USER PROGRAM TO BE KILLED
SYSCALL:DEBUG   RMB     1       CALL SYSTEM DEBUGGER
SYSCALL:ATTNCHECK       RMB     1       OPERATOR ATTENTION REQUEST CHECK
SYSCALL:ISCONSOLE       RMB     1       CHECK FOR CHANNEL 0 INPUT DEVICE = CONSOLE:
SYSCALL:INTERLOCK       RMB     1       PERFORM INTERLOCK FUNCTIONS ON OBJECTS
SYSCALL:DELAY   RMB     1       DELAY FOR n 1/60ths OF A SECOND
SYSCALL:READLUN RMB     1       CONVERT LOGICAL UNIT NUMBER TO DEVICE NAME
SYSCALL:GETSERIALNUMBER RMB     1       GET PROCESSOR SERIAL NUMBER
SYSCALL:JOBCONTROL      RMB     1       CREATE/TEST/DESTROY OTHER JOBS
        PAGE
*
*       SYSCALL BLOCK DISPLACEMENTS
*
        ORG     0
SCBLK:OPCODE    RMB     1       PRIMARY SYSCALL FUNCTION (OPEN, READ, ETC.)
SCBLK:WLEN      RMB     1       WAIT FLAG BIT (0=WAIT) AND SYSCALL BLOCK LENGTH (0..127)
SCBLK:PARAMS    RMB     2       PARAMETER BYTES TO OPCODE (SECONDARY OPCODE, CHANNEL #)
SCBLK:WRBUF     RMB     2       POINTER TO WRITE DATA BUFFER
SCBLK:WRLEN     RMB     2       NUMBER OF BYTES IN WRITE DATA BUFFER
SCBLK:RPLEN     RMB     2       LENGTH OF REPLY (RESULT OF SYSCALL)
SCBLK:RDBUF     RMB     2       POINTER TO READ DATA BUFFER (WHERE RESULT GOES)
SCBLK:RDLEN     RMB     2       CEILING ON SIZE OF REPLY (READ DATA BUFFER)
SCBLK:DATA      RMB     0       OTHER PARAMETERS FOR SYSCALL; UP TO 127-12 BYTES
SCBLK:END       RMB     0       END OF SYSCALL BLOCK; ASSERT SCBLK:WLEN[1..7]=SCBLK:END-SCBLK:PARAMS
*
*       SYSCALL PARAMETER LIST DEFINITIONS
*
OPEN:CHANNEL    EQU     SCBLK:PARAMS    CHANNEL NUMBER
OPEN:LENGTH     EQU     SCBLK:WRLEN     FILE NAME LENGTH
OPEN:NAMEP      EQU     SCBLK:WRBUF     POINTER TO FILE NAME
OPEN:SCLEN      EQU     SCBLK:DATA      OPEN SYSCALL BLOCK LENGTH
*
CREATE:CHANNEL  EQU     SCBLK:PARAMS    CHANNEL NUMBER
CREATE:LENGTH   EQU     SCBLK:WRLEN     FILE NAME LENGTH
CREATE:NAMEP    EQU     SCBLK:WRBUF     POINTER TO FILE NAME
CREATE:SCLEN    EQU     SCBLK:DATA      CREATE SYSCALL BLOCK LENGTH
CREATE:FILESIZE EQU     SCBLK:DATA      4 BYTE FILE SIZE INITIAL ALLOCATION
CREATE:FILESIZESCLEN    EQU     CREATE:FILESIZE+4       END OF CREATE BLOCK WITH FILE SIZE ALLOCATION
*
CLOSE:CHANNEL   EQU     SCBLK:PARAMS    CHANNEL NUMBER
CLOSE:SCLEN     EQU     SCBLK:PARAMS+1  CLOSE SYSCALL BLOCK LENGTH
*
RENAME:CHANNEL  EQU     SCBLK:PARAMS    CHANNEL NUMBER
RENAME:LENGTH   EQU     SCBLK:WRLEN     NEW FILE NAME LENGTH
RENAME:NAMEP    EQU     SCBLK:WRBUF     POINTER TO NEW FILE NAME
RENAME:SCLEN    EQU     SCBLK:DATA      RENAME SYSCALL BLOCK LENGTH
*
DELETE:LENGTH   EQU     SCBLK:WRLEN     FILE NAME LENGTH
DELETE:NAMEP    EQU     SCBLK:WRBUF     POINTER TO NAME
DELETE:SCLEN    EQU     SCBLK:DATA      DELETE SYSCALL BLOCK LENGTH
*
LOAD:LENGTH     EQU     SCBLK:WRLEN     LENGTH OF FILE NAME
LOAD:NAMEP      EQU     SCBLK:WRBUF     POINTER TO FILE NAME
LOAD:SCLEN      EQU     SCBLK:DATA      LOAD SYSCALL BLOCK LENGTH
*
CHAIN:LENGTH    EQU     SCBLK:WRLEN     LENGTH OF FILE NAME
CHAIN:NAMEP     EQU     SCBLK:WRBUF     POINTER TO FILE NAME
CHAIN:SCLEN     EQU     SCBLK:DATA      CHAIN SYSCALL BLOCK LENGTH
*
CREATELOG:LENGTH        EQU     SCBLK:WRLEN     LENGTH OF FILE NAME
CREATELOG:NAMEP EQU     SCBLK:WRBUF     POINTER TO FILE NAME
CREATELOG:SCLEN EQU     SCBLK:DATA      CREATELOG SYSCALL BLOCK LENGTH
*
CLOSELOG:SCLEN  EQU     SCBLK:PARAMS    CLOSELOG SYSCALL BLOCK LENGTH
*
DISKDEFAULT:LENGTH      EQU     SCBLK:WRLEN     FILE NAME LENGTH
DISKDEFAULT:NAMEP       EQU     SCBLK:WRBUF     POINTER TO FILE NAME
DISKDEFAULT:SCLEN       EQU     SCBLK:DATA      DISKDEFAULT SYSCALL BLOCK LENGTH
*
READA:CHANNEL   EQU     SCBLK:PARAMS    CHANNEL NUMBER
READA:LMFLAG    EQU     SCBLK:PARAMS+1  LINE MODE FLAG BYTE
READA:BUFFERP   EQU     SCBLK:RDBUF     BUFFER POINTER
READA:MAXCOUNT  EQU     SCBLK:RDLEN     BYTE COUNT
READA:ACTUALCOUNT       EQU     SCBLK:RPLEN     ACTUAL NUMBER OF BYTES TRANSFERRED
READA:SCLEN     EQU     SCBLK:DATA      READA SYSCALL BLOCK LENGTH
RW:POSITION     EQU     SCBLK:DATA      READ/WRITE IMPLICIT FILE POSITION
RWPOSITION:SCLEN        EQU     RW:POSITION+4   END OF R/W SYSCALL WITH IMPLICIT FILE POSITION
*
READB:CHANNEL   EQU     SCBLK:PARAMS    CHANNEL NUMBER
READB:BUFFERP   EQU     SCBLK:RDBUF     BUFFER POINTER
READB:MAXCOUNT  EQU     SCBLK:RDLEN     BYTE COUNT
READB:ACTUALCOUNT       EQU     SCBLK:RPLEN     ACTUAL NUMBER OF BYTES TRANSFERRED
READB:SCLEN     EQU     SCBLK:DATA      READB SYSCALL BLOCK LENGTH
*
WRITEA:CHANNEL  EQU     SCBLK:PARAMS    CHANNEL NUMBER
WRITEA:BUFFERP  EQU     SCBLK:WRBUF     BUFFER POINTER
WRITEA:COUNT    EQU     SCBLK:WRLEN     BYTE COUNT
WRITEA:SCLEN    EQU     SCBLK:RPLEN     WRITEA SYSCALL BLOCK LENGTH
*
WRITEB:CHANNEL  EQU     SCBLK:PARAMS    CHANNEL NUMBER
WRITEB:BUFFERP  EQU     SCBLK:WRBUF     BUFFER POINTER
WRITEB:COUNT    EQU     SCBLK:WRLEN     BYTE COUNTER
WRITEB:SCLEN    EQU     SCBLK:RPLEN     WRITEB SYSCALL BLOCK LENGTH
*
CONTROL:CHANNEL EQU     SCBLK:PARAMS    CHANNEL NUMBER
CONTROL:CODE    EQU     SCBLK:PARAMS+1  CONTROL CODE
CONTROL:SCLEN   EQU     SCBLK:WRBUF     CONTROL SYSCALL BLOCK MINIMUM LENGTH
CONTROL:DATA    EQU     0       DISPLACEMENT INTO WRITE BUFFER FOR CONTROL DATA
*
STATUS:CHANNEL  EQU     SCBLK:PARAMS    CHANNEL NUMBER
STATUS:CODE     EQU     SCBLK:PARAMS+1  STATUS SELECTOR CODE
STATUS:BUFFERP  EQU     SCBLK:RDBUF     POINTER TO STATUS TARGET BUFFER
STATUS:MAXCOUNT EQU     SCBLK:RDLEN     SIZE OF STATUS READ-BACK BUFFER
STATUS:ACTUALCOUNT      EQU     SCBLK:RPLEN     ACTUAL # STATUS BYTES READ
STATUS:SCLEN    EQU     SCBLK:DATA      STATUS SYSCALL BLOCK MINIMUM LENGTH
STATUS:DATA     EQU     0       DISPLACEMENT INTO READ BUFFER FOR READ-BACK STATUS
*
WAITDONE:CHANNEL        EQU     SCBLK:PARAMS    CHANNEL NUMBER
WAITDONE:SCLEN  EQU     SCBLK:PARAMS+1  WAITDONE SYSCALL BLOCK LENGTH
*
EXIT:SCLEN      EQU     SCBLK:PARAMS    EXIT SYSCALL BLOCK LENGTH
*
ERROREXIT:CODE  EQU     SCBLK:PARAMS    ERROR CODE NUMBER
ERROREXIT:SCLEN EQU     SCBLK:WRBUF     ERROREXIT SYSCALL BLOCK LENGTH
*
SETERROR:CODE   EQU     SCBLK:PARAMS    ERROR CODE NUMBER
SETERROR:SCLEN  EQU     SCBLK:WRBUF     SETERROR SYSCALL BLOCK LENGTH
*
GETERROR:BUFFERP        EQU     SCBLK:RDBUF     POINTER TO ERROR READ-BACK AREA
GETERROR:MAXCOUNT       EQU     SCBLK:RDLEN     SHOULD BE 2
GETERROR:ACTUALCOUNT    EQU     SCBLK:RPLEN     SHOULD BE RETURNED AS 2
GETERROR:SCLEN  EQU     SCBLK:DATA      GETERROR SYSCALL BLOCK LENGTH
*
DISPERROR:SCLEN EQU     SCBLK:PARAMS    DISPERROR SYSCALL BLOCK LENGTH
*
KILLPROOF:SCLEN EQU     SCBLK:PARAMS    KILLPROOF SYSCALL BLOCK LENGTH
*
KILLENABLE:SCLEN        EQU     SCBLK:PARAMS    KILLENABLE SYSCALL BLOCK LENGTH
*
DEBUG:SCLEN     EQU     SCBLK:PARAMS    DEBUG SYSCALL BLOCK LENGTH
*
ATTNCHECK:SCLEN EQU     SCBLK:PARAMS    ATTNCHECK SYSCALL BLOCK LENGTH
*
ISCONSOLE:SCLEN EQU     SCBLK:PARAMS    ISCONSOLE SYSCALL BLOCK LENGTH
*
INTERLOCK:FUNCTION      EQU     SCBLK:PARAMS    INTERLOCK FUNCTION
INTERLOCK:BUFFERP       EQU     SCBLK:WRBUF     POINTER TO OBJECT
INTERLOCK:COUNT EQU     SCBLK:WRLEN     LENGTH OF OBJECT
INTERLOCK:SCLEN EQU     SCBLK:RPLEN     INTERLOCK SYSCALL BLOCK LENGTH
*
DELAY:PERIOD    EQU     SCBLK:PARAMS    DELAY PERIOD
DELAY:SCLEN     EQU     SCBLK:WRBUF     DELAY SYSCALL BLOCK LENGTH
*
*READLUNNAME:LUN        EQU     SCBLK:PARAMS    LOGICAL UNIT NUMBER
*READLUNNAME:BUFFERP    EQU     SCBLK:RDBUF     WHERE TO READ NAME BACK
*READLUNNAME:MAXCOUNT   EQU     SCBLK:RDLEN     MAXIMUM LENGTH OF REPLY
*READLUNNAME:ACTUALCOUNT        EQU     SCBLK:RPLEN     ACTUAL NAME LENGTH
READLUNNAME:SCLEN       EQU     SCBLK:DATA      READLUN SYSCALL BLOCK LENGTH
*
GETSERIALNUMBER:BUFFERP EQU     SCBLK:RDBUF     POINTER TO SERIAL NUMBER REPLY BUFFER
GETSERIALNUMBER:MAXCOUNT        EQU     SCBLK:RDLEN     SIZE OF BUFFER
GETSERIALNUMBER:ACTUALCOUNT     EQU     SCBLK:RPLEN     SIZE OF REPLY
GETSERIALNUMBER:SCLEN   EQU     SCBLK:DATA      MINIMUM SIZE OF BLOCK
*
JOBCONTROL:FUNCTION     EQU     SCBLK:PARAMS    JOB CONTROL FUNCTION
JOBCONTROL:BUFFERP      EQU     SCBLK:WRBUF     POINTER TO JOB CAPABILITY
JOBCONTROL:COUNT        EQU     SCBLK:WRLEN     SIZE OF CAPABILITY
JOBCONTROL:MAXCOUNT     EQU     SCBLK:RDLEN     MAXIMUM LENGTH OF REPLY
JOBCONTROL:ACTUALCOUNT  EQU     SCBLK:RPLEN     ACTUAL SIZE OF CAPABILITY
JOBCONTROL:SCLEN        EQU     SCBLK:WRLEN+2   JOBCONTROL SYSCALL MINIMUM BLOCK LENGTH
        PAGE
LSN:SIZE        EQU     3       # BYTES OCCUPIED BY AN LSN
LCN:SIZE        EQU     2       # BYTES OCCUPIED BY AN LCN
*
*       STANDARD STATUS SYSCALL SUB-CODES
*
        ORG     0
SC:GETPOS       RMB     1       GET BYTE POSITION
SC:GETCOL       RMB     1       GET COLUMN COUNT
SC:GETEOF       RMB     1       GET EOF FLAG
SC:GETFILESIZE  RMB     1       GET FILE SIZE
SC:GETTYPE      RMB     1       GET DEVICE TYPE AND CHARACTERISTICS
SC:GETPARAMS    RMB     1       GET DEVICE SPECIFIC PARAMETERS

SC:DEVICESPECIFICOP     EQU     $10     BASE FOR DEVICE SPECIFIC STATUS CODES
*
*       STANDARD CONTROL SYSCALL SUB-CODES
*
        ORG     0
CC:POSITION     RMB     1       POSITION TO THIS PLACE IN THE FILE
CC:DUMPBUFFERS  RMB     1       DUMP BUFFERS TO THE DEVICE (MAINLY FOR DISK)

CC:DEVICESPECIFICOP     EQU     $10     BASE FOR DEVICE-SPECIFIC CONTROL CODES
*
*       STANDARD INTERLOCK SYSCALL SUB-CODES
*
        ORG     0
IC:CREATE       RMB     1       CREATE AN OBJECT IDENTIFIER
IC:DESTROY      RMB     1       DESTROY AN OBJECT IDENTIFIER
IC:RESET        RMB     1       RESET OBJECT REFERENCE LIST
IC:LOCK RMB     1       LOCK AN OBJECT OR BLOCK UNTIL AVAILABLE
IC:RELEASE      RMB     1       RELEASE A LOCKED OBJECT
IC:TEST RMB     1       LOCK AN OBJECT OR ERROR IF UNAVAILABLE
        PAGE
*       VIRTUAL TERMINAL SPECIFIC STATUS REQUESTS
*
*
        ORG     SC:DEVICESPECIFICOP
SC:GETPROFILE   RMB     1       GET CURRENT DEVICE PROFILE NAME
SC:GETACTCOL    RMB     1       GET ACTIVATION COLUMN
SC:GETPROFILEALTERATION RMB 1   GET PROFILE ALTERATION INFORMATION
SC:GETOUTPUTTIMEOUT RMB  1      GET OUTPUT TIMEOUT
SC:GETBAUDRATE  RMB     1       GET CURRENT BAUD RATE
                RMB     1       (RESERVED)
SC:GETTABS      RMB     1       GET CURRENT TAB SETTINGS
SC:GETIDLES     RMB     1       GET NUMBER OF IDLES SENT AFTER NEWLINE
SC:GETWRAP      RMB     1       GET WRAP/NO WRAP FLAG
SC:GETCOLORING  RMB     1       GET CURRENT COLORING INFORMATION
SC:GETBACKGROUND RMB    1       GET BACKGROUND COLORING INFORMATION
SC:GETPROFILENAME RMB   1       GET NAME OF CURRENT PROFILE

        ORG     SC:DEVICESPECIFICOP+$1C (DON'T ASK!!!)
SC:GETLINEFLAGS RMB     1       GET LINE FLAGS
*
*       DISK FILE SPECIFIC STATUS REQUESTS
*
        ORG     SC:DEVICESPECIFICOP
SC:GETFILEDATE  RMB     1       READ BACK CREATION DATE OF FILE IN CLOCK FORMAT
SC:GETFILEPROT  RMB     1       READ BACK FILE PROTECTION BYTE
*
*       DISK DEVICE STATUS REQUESTS
*
        ORG     SC:DEVICESPECIFICOP
SC:GETLASTBADLSN        RMB     1       READ BACK LSN THAT CAUSED DRIVER A PROBLEM
SC:GETERRORSTATS        RMB     1       GET DEVICE ERROR (HISTORY) STATISTICS
*
*       VIRTUAL TERMINAL SPECIFIC CONTROL OPERATIONS
*
        ORG     CC:DEVICESPECIFICOP
CC:ECHO RMB     1       TURN ECHO ON
CC:NOECHO       RMB     1       TURN ECHO OFF
CC:IDLES        RMB     1       SET TTY IDLES
CC:TABS RMB     1       SET TTY TABS
CC:SETACTBLOCK  RMB     1       DECLARE ACTIVATION SET
CC:CLRINPUT     RMB     1       CLEAR INPUT BUFFER
CC:CLROUTPUT    RMB     1       CLEAR OUTPUT BUFFER
CC:SETREADTIMEOUT       RMB     1       SET TIMEOUT PERIOD FOR READA
CC:SETPROFILE   RMB     1       DECLARE DEVICE PROFILE
CC:ALTERPROFILE RMB     1       ALTER MALLEABLE DEVICE PROFILE
CC:WRITEEDITLINE        RMB     1       PUT LINE IN TYPE-AHEAD BUFFER
CC:SETFIELDSIZE RMB     1       DECLARE WIDTH OF INPUT FIELD
CC:SETPARAMS    RMB     1       DECLARE DEVICE WIDTH AND DEPTH
CC:ACTIVATIONCK RMB     1       CHECK FOR READA DATA READY
CC:WRAP RMB     1       ALLOW FORE- AND BACK-WRAP
CC:NOWRAP       RMB     1       DISALLOW FORE- AND BACK-WRAP
CC:COLORING     RMB     1       DECLARE AND SET FOREGROUND COLORING
CC:BACKGROUND   RMB     1       DECLARE AND SET BACKGROUND COLORING
CC:KILLPROOF    RMB     1       KILLPROOF VT DEVICE
CC:KILLENABLE   RMB     1       KILLENABLE VT DEVICE
CC:SETOUTPUTTIMEOUT RMB 1       SET OUTPUT TIMEOUT FOR DEVICE
CC:SETBAUDRATE  RMB     1       SET BAUD RATE FOR DEVICE
CC:SETINPUTTRANSLATION RMB 1	SET INPUT TRANSLATION
*
*       DISK FILE SPECIFIC CONTROL OPERATIONS
*
        ORG     CC:DEVICESPECIFICOP
CC:SETFILEDATE  RMB     1       SET CREATION DATE OF FILE (USE CLOCK FORMAT)
CC:SETFILEPROT  RMB     1       SET FILE PROTECTION BYTE
CC:SETFILESIZE  RMB     1       SET SIZE OF FILE
CC:POSITIONTOEND        RMB     1       POSITION TO END OF FILE
*
*       DISK DEVICE SPECIFIC CONTROL OPS
*
        ORG     CC:DEVICESPECIFICOP
CC:UNLOCKDISK   RMB     1       UNLOCK THE DISK DEVICE FOR WRITING
CC:DISMOUNTDISK RMB     1       DISMOUNT THE DISK
CC:SETMAPALGORITHM      RMB     1       SET MAP ALGORITHM NUMBER FOR DRIVE
CC:MULTISECTORREAD      RMB     1       READ MULTIPLE SECTORS
CC:MULTISECTORWRITE     RMB     1       WRITE MULTIPLE, ACCORDING TO SYSCALL EXTENSION
CC:FORMAT       RMB     1       FORMAT DISK
CC:WAITDONE     RMB     1       WAIT FOR CONTROLLER OPERATION COMPLETE
        PAGE
*       RETURNED STATUS DISPLACEMENTS
*
        ORG     0
STATUS:DIST     RMB     4       POSITION IN DISK FILE
*
        ORG     0
STATUS:COLUMN   RMB     1       COLUMN NUMBER
*
        ORG     0
STATUS:EOFFLAG  RMB     1       END OF FILE FLAG
*
        ORG     0
STATUS:DEVTYPE  RMB     1       DEVICE TYPE DATA FOR DIRECTORIED DISK
*
        ORG     0
STATUS:NBPS     RMB     2       NUMBER OF BYTES PER SECTOR
STATUS:NSPC     RMB     0       NUMBER OF SECTORS PER CLUSTER FOR DISK FILE
STATUS:NSPT     RMB     2       NUMBER OF SECTORS PER TRACK
STATUS:NTPC     RMB     2       NUMBER OF TRACKS PER CYLINDER
STATUS:NCYL     RMB     2       NUMBER OF CYLINDERS
*
        ORG     0
STATUS:FILESIZE RMB     4       SIZE OF DISK FILE IN BYTES
*
        ORG     0
STATUS:LASTBADLSN       RMB     3       LSN OF LAST BAD SECTOR ON DISK
*
*       SC:GETFILEDATE REPLY BUFFER
*
        ORG     0
STATUS:DATETICKS        RMB     3       24 BITS OF TICKS SINCE MIDNITE
STATUS:DATEDAY  RMB     1       BCD VALUE OF DAY (1..31)
STATUS:DATEMONTH        RMB     1       BCD VALUE OF MONTH (1..12)
STATUS:DATEYEAR RMB     1       BCD VALUE OF YEAR MOD 100 (00.99)
*
*       SC:GETFILEPROT REPLY BUFFER
*
        ORG     0
STATUS:PROT     RMB     1       PROTECTION BYTE FROM FILE
        PAGE
*       SC:GETERRORSTATS REPLY BUFFER
*
        ORG     0
STATUS:SEEKERRCNT       RMB     2       # SEEK ERRORS SINCE MOUNT
STATUS:SEEKERRSTS       RMB     2       16 BITS OF LAST "SEEK" STATUS IN ERROR
STATUS:WRITEERRCNT      RMB     2       # WRITE ERRORS SINCE MOUNT
STATUS:WRITEERRSTS      RMB     2       16 BITS OF LAST "WRITE" STATUS IN ERROR
STATUS:READERRCNT       RMB     2       # READ ERRORS SINCE MOUNT
STATUS:READERRSTS       RMB     2       16 BITS OF LAST "READ" STATUS IN ERROR
STATUS:OPSCOUNT RMB     3       24 BITS OF # DRIVER OPERATIONS SINCE MOUNT
STATUS:ERRLSN   RMB     LSN:SIZE        LSN CAUSING ANY SOFT OR HARD ERROR
        PAGE
*       CC:POSITION WRITE BUFFER
*
        ORG     0
CONTROL:DIST    RMB     4       VALUE OF POSITIONING COMMANDS
*
*       CC:SETFILEDATE WRITE BUFFER
*
        ORG     0
CONTROL:DATETICKS       RMB     3       24 BITS OF TICKS SINCE MIDNITE
CONTROL:DATEDAY RMB     1       BCD VALUE OF DAY (1..31)
CONTROL:DATEMONTH       RMB     1       BCD VALUE OF MONTH (1..12)
CONTROL:DATEYEAR        RMB     1       BCD VALUE OF YEAR MOD 100 (00..99)
*
*       CC:SETFILEPROT WRITE BUFFER
*
        ORG     0
CONTROL:PROT    RMB     1       PROTECTION BYTE FOR FILE
*
*       CC:SETMAPALGORITHM WRITE BUFFER
*
        ORG     0
CONTROL:MAPALGORITHM    RMB     2       PARAMETER BLOCK FOR SET MAP ALGORITHM CALL
*
*       JOB CONTROL SUB-CODES
*
        ORG     0
JC:CREATE       RMB     1       CREATE A NEW JOB
JC:TESTDONE     RMB     1       TEST TO SEE IF A JOB IS DONE
JC:DESTROY      RMB     1       DESTROY A JOB
        PAGE
*
*       SYSTEM-DEFINED ERROR CODES
*
        ORG     0
ERR:NONE        RMB     1       CODE 0 --> NO ERROR
ERR:ATTENTION   RMB     1       OPERATOR REQUESTED ATTENTION

        ORG     100
ERR:FATALCOMPILE        RMB     1       COMPILATION OR ASSEMBLY HAD FATAL ERRORS
ERR:WARNINGCOMPILE      RMB     1       COMPILATION OR ASSEMBLY HAD NON-FATAL ERRORS
ERR:BADCMDFORMAT        RMB     1       BAD COMMAND FORMAT (SYNTAX ERROR!)
ERR:CANTGOTO    RMB     1       CAN'T DO GOTO FROM CONSOLE:
ERR:ABNORMALSTOP        RMB     1       PROGRAM TERMINATED ABNORMALLY
ERR:NOTENUFMEM  RMB     1       NOT ENOUGH MEMORY TO EXECUTE COMMAND
*
*       SDOS ERROR CODES
*
*
*       ERROR CODES FOR SDOS ARE RESERVED BETWEEN 1000-1999
*
        ORG     1000
ERR:BOOTCKSUMFAIL       RMB     1       BOOT SECTOR DISKINFO CHECK SUM FAILED
ERR:EOFHIT      RMB     1       END OF FILE HIT
ERR:FILEISOPEN  RMB     1       A FILE IS OPEN DURING DISMOUNT REQUEST
ERR:NODEBUGGER  RMB     1       NO DEBUGGER TO CALL!
ERR:BADPOSITION RMB     1       BAD POSITIONING REQUEST
ERR:NBPCTOOBIG  RMB     1       NUMBER OF BYTES PER CLUSTER >= 65536
ERR:NODISKMAP   RMB     1       NO DISK MAP, CAN'T ALLOC OR FREE
ERR:NOMATCHFCB  RMB     1       NO MATCHING FILE CONTROL BLOCK FOUND
ERR:NODEFAULTPROGRAM    RMB     1       NO "DEFAULTPROGRAM" ON THIS DISK
        RMB     1       **** UNUSED ****
ERR:FILEWRTPROT RMB     1       FILE IS WRITE PROTECTED
ERR:FILENOTFOUND        RMB     1       FILE NOT FOUND
ERR:ILLEGALLCN  RMB     1       LCN OUT OF RANGE
ERR:BADFNAMESIZE        RMB     1       LENGTH OF FILE NAME > 16 CHARACTERS
ERR:NEWFILEEXISTS	RMB	1	NEW FILE ALREADY EXISTS!
ERR:NODISKSPACE	RMB	1	DISK SPACE EXHAUSTED
ERR:LCNWASNTALLOCATED	RMB	1	LCN ENCOUNTERED BY FREECLUSTERS WASN'T ALLOCATED (*SYSTEM*)
ERR:NOFREEFCBS	RMB	1	RAN OUT OF FCBS (*SYSTEM*)
ERR:WRONGFILESYSTEM	RMB	1	FILE SYSTEM INCOMPATIBLE WITH THIS VERSION OF SDOS
ERR:FILEINCREATE	RMB	1	FILE IS BEING CREATED
ERR:DISKMOUNTED	RMB	1	DISK IS MOUNTED, CAN'T CHANGE MAPALGORITHM
ERR:CANTOPENMUSTCREATE	RMB	1	MUST CREATE TO OPEN OUTPUT ONLY DEVICE
ERR:NOERRORMSGS	RMB	1	NO $ERRORMESSAGES FILE ON DRIVE 0
ERR:BADFILENAME	RMB	1	FILENAME DOESN'T START WITH A-Z OR $
ERR:ILLFILESIZE	RMB	1	ILLEGAL FILE SIZE SPECIFICATION (SYNTAX OR OVFLOW)
ERR:HCSICTOOSMALL	RMB	1	HEADER CLUSTER NOT INITZED FOR RDCN FETCH
ERR:NOTENOUGHPOOL	RMB	1	NOT ENOUGH DISKBUFFER POOL (*SYSTEM*)
ERR:PWRFAILDISKF	RMB	1	DISK FILE HANDLERS DON'T IMPLEMENT POWER FAIL
ERR:NOTALOADFILE	RMB	1	CAN'T LOAD THAT - WRONG FORMAT
ERR:BADFILEVERSION	RMB	1	FILE VERSION NUMBER HAS NO DIGITS OR IS >255!
ERR:CHTOOBIG	RMB	1	CHANNEL # IS TOO BIG
ERR:CHBUSY	RMB	1	CHANNEL IS ALREADY OPEN
ERR:CLOSED	RMB	1	CHANNEL IS ALREADY CLOSED
ERR:ILLEGALSYSCALL	RMB	1	ILLEGAL SYSCALL #
ERR:ILLDEVICEOP	RMB	1	ILLEGAL DEVICE OPERATION
ERR:RENAMEDEVICE	RMB	1	CAN'T RENAME TO DIFFERENT DEVICE
ERR:BADLOADRECORD	RMB	1	LOAD RECORD FORMAT ERROR
ERR:NOTENOUGHROOM	RMB	1	PROGRAM TOO BIG TO LOAD
ERR:ILLLSN	RMB	1	ILLEGAL LSN PASSED TO PHYSICAL DISK DRIVERS
ERR:DIRECTORYDAMAGED	RMB	1	DIRECTORY.SYS DIRECTORY ENTRY IS DAMAGED
ERR:IBUFOVERFLOW	RMB	1	INPUT BUFFER OVERFLOW IN THE DRIVERS
ERR:PROGRAMKILLED	RMB	1	PROGRAM KILLED BY OPERATOR
ERR:DEVICETIMEDOUT	RMB	1	DEVICE TIMED OUT
ERR:SECTORSIZE2	RMB	1	SECTORSIZE IS NOT A POWER OF 2!
ERR:SYSTEMCROAKED	RMB	1	...WHILE DOING AN EXIT OR CHAIN (*SYSTEM*)
ERR:DISKREAD	RMB	1	DISK READ ERROR
ERR:DISKWRITE	RMB	1	DISK WRITE ERROR
ERR:DISKSEEK	RMB	1	DISK SEEK ERROR
ERR:DSKWRTPROT	RMB	1	DISK IS WRITE PROTECTED
ERR:DISKWRITELOCKED	RMB	1	DISK DEVICE IS SOFTWARE WRITE LOCKED
ERR:SDOSCKSUM	RMB	1	SDOS GOT A KNIFE IN THE RIBS!
ERR:NLSNGE224	RMB	1	NLSN >= 2^24, ILLEGAL
ERR:CLUSTERSIZELIMITSFILE	RMB	1	CLUSTER SIZE IS TOO SMALL TO SUPPORT A FILE THAT BIG
ERR:SYSCALLTOOSHORT	RMB	1	SYSCALL BLOCK IS TOO SMALL FOR SPECIFIED SYSCALL
ERR:RDBUFTOOSMALL	RMB	1	READ BUFFER SPECIFIED BY SYSCALL IS TOO SHORT FOR REPLY
ERR:WRBUFTOOSMALL	RMB	1	WRITE BUFFER SPECIFIED BY SYSCALL IS TOO SHORT
ERR:NOSUCHDEVICE	RMB	1	NO SUCH DEVICE IN THIS CONFIGURATION
ERR:DEVICEERRORED	RMB	1	DEVICE HARDWARE DID NOT RESPOND REASONABLY
ERR:MUSTBEDISK	RMB	1	MUST SELECT DISK DEVICE
ERR:NOTOPENTOCONSOLE	RMB	1	CHANNEL 0 IS NOT OPEN TO CONSOLE DEVICE
ERR:DEVICENOTREADY	RMB	1	DEVICE IS NOT READY
ERR:TIMENOTSET	RMB	1	TIME NOT SET TO NON-ZERO DAY/MONTH!
ERR:NOSUCHLUN	RMB	1	NO SUCH LOGICAL UNIT NUMBER
ERR:ZEROSTARTADDRESS	RMB	1	OBJECT FILE HAS NO (ZERO) START ADDRESS
ERR:NOSUCHPROGRAM	RMB	1	NO SUCH PROGRAM EXISTS (ERROR ISSUED BY LOADER)
ERR:OLDFILEEXISTS	RMB	1	OLD FILE BY SAME NAME ALREADY EXISTS
	RMB	1	*** UNUSED ***
ERR:ALLOC0CLUSTERS	RMB	1	"ALLOC" CALL WITH REQUEST FOR 0 CLUSTERS!
ERR:FILEALREADYDELETED	RMB	1	FILE WAS DELETED BUT NOT CLOSED BEFORE RENAME WAS ATTEMPTED
ERR:PRINTERNOTREADY	RMB	1	PRINTER IS NOT READY
ERR:INPUTTIMEOUT	RMB	1	INPUT TIMED OUT, ABORTED
ERR:ENDOFMEDIUM	RMB	1	END OF MEDIUM ON DEVICE
ERR:SELFTESTCKSUM	RMB	1	PROGRAM SELF-TEST CHECKSUM FAILED
ERR:NOTIMEOUTBLKS	RMB	1	ZERO TIME OUT BLOCKS IN I/O PKG NOT LEGAL
ERR:SERIALNOWRONG	RMB	1	THIS CPU HAS WRONG SERIAL NUMBER TO RUN PROGRAM
ERR:NOSUCHKEY	RMB	1	NO SUCH KEY EXISTS IN INDEX
ERR:DUPLICATEKEY	RMB	1	KEY ALREADY EXISTS IN INDEX
ERR:BRANCHFACTORSIZE	RMB	1	KEY BRANCHING FACTOR IS TOO SMALL
ERR:SDOSNOTREGISTERED	RMB	1	THIS COPY OF SDOS NOT REGISTERED WITH SD YET
ERR:DECRYPTIONKEYSDONTMATCH	RMB	1	LAST FILE LOADED HAS DIFFERENT DECRYPTION KEY
*
ERR:WRONGDISKTYPE	EQU	1902	WRONG DISK TECHNOLOGY (DENSITY, SIDES, ETC.)
*
*	VIRTUAL TERMINAL DRIVER ERROR CODES
*
	ORG	1905
ERR:IOINPROGRESS	RMB	1	LAST REQUEST HAS NOT COMPLETED
ERR:BUSYFORANOTHERPROCESS	RMB	1	DCB OPEN TO ANOTHER PROCESS
ERR:ACTIVATIONNOTINBUFFER	RMB	1	RDBUF DOES NOT HOLD ACTIVATION
ERR:BADFIELDWIDTH	RMB	1	CRT SCREEN FEILD SPECIFICATION IS TOO WIDE
ERR:ACTIVATIONRECEIVED	RMB	1	ACTIV. REC'D PER CC:ACTIVATIONCK
ERR:TIMEDINPUTEXPIRED	RMB	1	TIMED INPUT PERIOD EXPIRED
ERR:PROFILENOTFOUND	RMB	1	DEVICE PROFILE NOT FOUND
ERR:PROFILENOTMALLEABLE	RMB	1	DEVICE PROFILE NOT MALLEABLE
	RMB	1	*** RESERVED ***
*
	ORG	1200	SDOS/MT ERROR CODES
ERR:BADREADBUF	RMB	1	SYSCALL REPLY BUFFER NOT WITHIN USER SPACE
ERR:BADWRITEBUF	RMB	1	SYSCALL WRITE BUFFER NOT WITHIN USER SPACE
ERR:RDBUFTOOBIG	RMB	1	SYSCALL REPLY BUFFER > 255 BYTES
ERR:WRBUFTOOBIG	RMB	1	SYSCALL WRITE BUFFER > 255 BYTES
ERR:NOTENOUGHCHANNELS	RMB	1	AVAILABLE I/O CHANNELS EXHAUSTED
ERR:NOTUNDERTIMESHARE	RMB	1	FUNCTION NOT AVAILABLE UNDER SDOS/MT
ERR:MTNOROOM	RMB	1	NOT ENOUGH ROOM TO RUN SDOS/MT
ERR:MTBADCONFIG	RMB	1	INCORRECT CONFIGURATION FOR SDOS/MT
ERR:ALREADYLOCKED	RMB	1	INTERLOCK OBJECT IS ALREADY LOCKED
ERR:NOSUCHOBJECT	RMB	1	BAD CAPABILITY GIVEN
ERR:NOTLOCKED	RMB	1	INTERLOCK OBJECT IS NOT LOCKED
ERR:OBJECTDESTROYED	RMB	1	INTERLOCK OBJECT DESTROYED WHILE WAITING FOR IT
ERR:LOCKRESET	RMB	1	INTERLOCK OBJECT WAS RESET WHILE WAITING FOR IT
ERR:IMPLEMENTATIONLIMITREACHED	RMB	1	CAN'T HANDLE MORE INTERLOCK OBJECTS NOW
ERR:ILLEGALINTERLOCKFUNCTION	RMB	1	ILLEGAL INTERLOCK FUNCTION REQUESTED
ERR:MEMORYMGMTFAIL	RMB	1	SDOS/MT INTERNAL MEMORY MANAGEMENT FAILURE
ERR:NOMOREJOBS	RMB	1	ALL AVAILABLE JOBS ARE BUSY NOW
ERR:ILLEGALJOBCONTROL	RMB	1	ILLEGAL JOB CONTROL REQUEST
ERR:CAPABILITYFAILURE	RMB	1	CAPABILITY DOES NOT HAVE RIGHTS TO PERFORM OPERATION
ERR:JOBKILLED	RMB	1	THIS JOB HAS BEEN KILLED BY ANOTHER
ERR:JOBCOMPLETED	RMB	1	JOB SUCCESSFULLY COMPLETED 
*	DEVICE TYPE DEFINITIONS 
*
	ORG	0
DVTYP.FILE	RMB	1	FILE (MANAGED BY SDOS)
DVTYP.DISK	RMB	1	DISK DEVICE (MANAGED BY SDOS)
DVTYP.STAPE	RMB	1	SERIAL TAPE DEVICE
DVTYP.DTAPE	RMB	1	DIRECTORIED TAPE DEVICE
DVTYP.CONSOLE	RMB	1	CONSOLE (HUMAN'S INTERFACE)
DVTYP.PRINTER	RMB	1	LINE PRINTER DEVICE
DVTYP.SERIALOUT	RMB	1	ILL-DEFINED
DVTYP.SERIALIN	RMB	1
DVTYP.PAROUT	RMB	1	PARALLEL OUT
DVTYP.PARIN	RMB	1	PARALLEL IN
DVTYP.DUMMY	RMB	1	BLACK HOLE FOR DATA BYTES
DVTYP.CLOCK	RMB	1	CLOCK DEVICE
*
*
*
*
*	DEVICE TYPE DATA DISPLACEMENTS
*
	ORG	0
DVTYP:TYPE	RMB	1	DEVICE TYPE
*
*	DEVICE-TYPE SPECIFIC DATA
*
	ORG	0	DISK DEVICE SPECIFIC DATA
DVDAT:NBPS	RMB	2	NUMBER OF BYTES PER SECTOR
DVDAT:NSPT	RMB	2	NUMBER OF SECTORS PER TRACK
DVDAT:NTPC	RMB	2	NUMBER OF TRACKS PER CYLINDER
DVDAT:NCYL	RMB	2	NUMBER OF CYLINDERS
*
	ORG	0	CONSOLE/PRINTER DEVICE SPECIFIC DATA
DVDAT:WIDTH	RMB	1	LINE WIDTH IN CHARACTERS
DVDAT:DEPTH	RMB	1	PAGE DEPTH (DEFAULT DEPTH FOR PRINTERS)
*				(0=INFINITY)
*
	ORG	DVDAT:NBPS+2	(DISK) FILE DEVICE SPECIFIC DATA
DVDAT:NSPC	RMB	1	NUMBER OF SECTORS PER CLUSTER
	PAGE
**********************************************************************
FILESYSTEMVERSION	EQU	$10	VERSION 1.0 OF FILESYSTEM FORMAT
********************************************************************
*
*	FUNNY VALUES TO MAKE DATA STORAGE ALLOCATION USES MORE CLEAR
*
IGNORED	EQU	0	SO I CAN MARK PLACES AS IGNORED
CHANGED	EQU	0	SO I CAN MARK PLACES AS CHANGED
*
*	LOCATIONS 0-7 ARE TREATED AS PART OF TASK'S CONTEXT
*	AND SAVED DURING A CONTEXT SWITCH
*
*	DEFINED TEMPORARIES
*	USED TO PUSH (X) ONTO STACK IN INTERRUPTABLE WAY
*	FOR USE BY TASK-LEVEL SUBROUTINES
*
	IFUND	SCRATCHPAD
	ORG	$0
TEMPX	RMB	2	ANY SUBROUTINE MAY STEP ON THIS!!!
TEMP	EQU	TEMPX	FOR CONVENIENCE
TEMPA	EQU	TEMPX	TEMP STORAGE FOR A REGISTER
TEMPB	EQU	TEMPX+1	TEMP STORAGE FOR B REGISTER
	FIN	SCRATCHPAD
*
*	PROTECTION BITS FOR DIR:PROTECTION
*
PROT::WRITE	EQU	$40	PROTECT AGAINST WRITES
PROT::BACKUP	EQU	$1	PROTECT AGAINST BACKING UP
	PAGE
*	ASCII CHARACTER SET
*
ASCII:NULL	EQU	0	^@ NULL
ASCII:SOH	EQU	1	^A START OF HEADING
ASCII:STX	EQU	2	^B START OF TEXT
ASCII:ETX	EQU	3	^C END OF TEXT
ASCII:EOT	EQU	4	^D END OF TRANSMISSION
ASCII:ENQ	EQU	5	^E ENQUIRY (WRU- WHO ARE YOU)
ASCII:ACK	EQU	6	^F ACKNOWLEDGE
ASCII:BEL	EQU	7	^G BELL
ASCII:BS	EQU	8	^H BACKSPACE
ASCII:HT	EQU	9	^I HORIZONTAL TAB
ASCII:LF	EQU	$A	^J LINE FEED
ASCII:VT	EQU	$B	^K VERTICAL TAB
ASCII:FF	EQU	$C	^L FORM FEED
ASCII:CR	EQU	$D	^M CARRIAGE RETURN
ASCII:SO	EQU	$E	^N SHIFT OUT
ASCII:SI	EQU	$F	^O SHIFT IN
ASCII:DLE	EQU	$10	^P DATA LINK ESCAPE
ASCII:DC1	EQU	$11	^Q DEVICE CONTROL 1
ASCII:DC2	EQU	$12	^R DEVICE CONTROL 2
ASCII:DC3	EQU	$13	^S DEVICE CONTROL 3
ASCII:DC4	EQU	$14	^T DEVICE CONTROL 4
ASCII:NAK	EQU	$15	^U NEGATIVE ACKNOWLEDGE
ASCII:SYN	EQU	$16	^V SYNCHRONOUS IDLE
ASCII:ETB	EQU	$17	^W END OF TRANSMISSION BLOCK
ASCII:CAN	EQU	$18	^X CANCEL
ASCII:EM	EQU	$19	^Y END OF MEDIUM
ASCII:SUB	EQU	$1A	^Z SUBSTITUTE
ASCII:ESC	EQU	$1B	^[ ESCAPE
ASCII:FS	EQU	$1C	^\ FILE SEPERATOR
ASCII:GS	EQU	$1D	^] GROUP SEPERATOR
ASCII:RS	EQU	$1E	^^ RECORD SEPERATOR
ASCII:US	EQU	$1F	^_ UNIT SEPERATOR
ASCII:SPACE	EQU	$20	SPACE (WORD SEPERATOR)
ASCII:RUBOUT	EQU	$7F	DELETE (RUBOUT)
ASCII:MASK	EQU	$7F	TO MASK OFF ALL BUT 7 LEGAL ASCII BITS
	PAGE
	IF	SYSTEMDEFS!IOPKDEFS
*	THIS BEGINS START OF DEFINITIONS REQUIRED FOR I/O PACKAGES
*
*	SDOS ENTRY POINTS
*
	ORG	0
SDOS:VERSIONNUMBER	RMB	1	VERSION NUMBER BYTE ($AB = VERSION A.B)
SDOS:LASTERROR	RMB	2	MOST RECENT ERROR ENCOUNTERED BY SDOS
SDOS:CONFIGURATION	RMB	2	POINTER TO CONFIGURATION TABLE (SUPPLIED BY  I/O PACKAGE
SDOS:SERIALNUMBER	RMB	2	SERIAL NUMBER ASSIGNED TO THIS COPY
SDOS:IOBLOCKPTR	RMB	2	POINTER TO I/O REQUEST (PASSED TO DRIVERS)
SDOS:IOCBPOINTER	RMB	2	POINTER TO IOCB FOR THIS CHANNEL
SDOS:CLOCK	RMB	3	TIME OF DAY IN 1/60 SEC UNITS (0..5,183,999)
SDOS:DAY	RMB	1	DAY NUMBER IN MONTH (1..31) BCD
SDOS:MONTH	RMB	1	MONTH OF YEAR (1..12) BCD
SDOS:YEAR	RMB	1	YEAR MODULO 100 (78..99) BCD
SDOS:STACKSWITCHED	RMB	1	"SWITCHED TO INTERRUPT STACK" COUNTER
SDOS:IOINT	RMB	3	I/O INTERRUPT GOES HERE FIRST!
SDOS:RTI	RMB	3	JMP TO "RETURN FROM INTERRUPT; NO EVENT"
SDOS:RESCHEDULE	RMB	3	JMP TO "RETURN FROM INTERRUPT; PLEASE RESCHEDULE"
SDOS:CLOCKTICKED	RMB	3	JMP TO "CLOCKTICKED" WITH (A) = # TICKS
SDOS:CURRENTASK	RMB	2	POINTER TO TCB OF CURRENTLY ACTIVE TASK
SDOS:KILLPROOF	RMB	1	0 --> USER TASK IS KILLABLE
SDOS:KILLUSERPROGRAM	RMB	3	JMP TO "KILL USER PROGRAM" ROUTINE
SDOS:STARTIO	RMB	3	JMP TO START I/O ROUTINE (X POINTS TO INTERRUPT ROUTINE)
SDOS:WAITCOND	RMB	3	JMP TO WAIT FOR CONDITION IN (A,B)
SDOS:WAITEVENT	RMB	3	JMP TO WAIT FOR EVENT SELECTED BY (X)
SDOS:ERROR	RMB	3	ERROR SUBROUTINE; INLINE 2 BYTE ERROR CODE
SDOS:ERRORSAVE	RMB	3	ERROR CODE SAVE ROUTINE; SAVES (X) AS ERROR CODE
SDOS:ERRORED	RMB	3	"ERROR CAN'T BE HANDLED BY ME" ENTRY
SDOS:CHECKRDLEN	RMB	3	CHECK READ LENGTH SUBROUTINE ENTRY POINT
SDOS:CHECKWRLEN	RMB	3	CHECK WRITE LENGTH SUBROUTINE ENTRY POINT
SDOS:CHECKSCLEN	RMB	3	CHECK SYSCALL BLOCK LENGTH SUBROUTINE ENTRY POINT
SDOS:TABLEBRANCH	RMB	3	TABLE BRANCH ROUTINE FOR SYSCALL DECODING
SDOS:BLOCKMOVE	RMB	3	"HOT DOG" BLOCK MOVE ENTRY POINT
SDOS:GETRUNNINGENCRYPTED	RMB	3	GET ADDRESS OF RUNNING ENCRYPTED BYTE TO (X)
SDOS:ENTRYSIZE	EQU	*
	PAGE
*
*	SDOS CONFIGURATION TABLE
*
	ORG	0
CNFG:DISKDCBS	RMB	2	POINTER TO DISK DEVICE CONTROL BLOCKS
CNFG:DEVICEDCBS	RMB	2	POINTER TO LIST OF NON-DISK DEVICE CONTROL BLOCKS
CNFG:IOCBPOINTERS	RMB	2	POINTER LIST TO IOCB'S
CNFG:NIOCHANNELS	RMB	1	NUMBER OF I/O CHANNELS
CNFG:DSKBUFFERPOOL	RMB	2	POINTER TO THE DISK BUFFER POOL
CNFG:DSKPOOLSIZE	RMB	2	SIZE OF THE BUFFER POOL
CNFG:ATTNCHECK	RMB	2	ADDRESS OF ATTENTION CHECK ROUTINE
CNFG:DEBUGGER	RMB	2	= ADDRESS OF DEBUGGER (0 IF NONE)
CNFG:DRIVERBASE	RMB	2	LOWEST ADDRESS USED BY DRIVERS
CNFG:INTSETUP	RMB	2	POINTER TO INTERRUPT SYSTEM SETUP ROUTINE
CNFG:INTDISABLE	RMB	3	SUBROUTINE (OR "JMP") TO DISABLE ALL INTERRUPTS
CNFG:INTENABLE	RMB	3	SUBROUTINE (OR "JMP") TO ENABLE ALL INTERRUPTS
CNFG:INTRTI	RMB	3	CODE TO ENABLE PRIORITY INTERRUPT AND DO RTI (USUALLY JUST "RTI")
CNFG:INTERRUPTSTACK	RMB	2	POINTER TO LAST BYTE OF INTERRUPT STACK SPACE
*			(USED BY AN "LDS" INSTRUCTION)
CNFG:IOINTPOLL	RMB	2	POINTER TO I/O INTERRUPT SERVICE DEVICE POLL ROUTINE
CNFG:TASKQUEUE	RMB	2	POINTER TO FIRST TASK IN TASK QUEUE
CNFG:TIMEOUTLIST	RMB	2	POINTER TO CHAINED LIST OF TIMEOUT BLOCKS
CNFG:VTPROFILES	RMB	2	POINTS TO FIRST PROFILE BLOCK IN CHAIN
CNFG:VTDEBUG	RMB	2	INTERRUPT LEVEL ENTRY POINT TO DEBUGGER
CNFG:MTPRIMS	RMB	2	POINTS TO /MT,/ES PRIMITIVES TABLE
CNFG:BOOTDEFAULTDISKDCB	RMB	2	POINTS TO DCB TO USE FOR DEFAULTDISK AT BOOT TIME
CNFG:BOOTCONSOLEDCB	RMB	2	POINTS TO DCB TO USE FOR "CONSOLE:" AT BOOT TIME
CNFG:RETURNELAPSEDMILLISECONDS	RMB	2	RETURNS ELAPSED TIME IN MILLISECONDS SINCE LAST CALL
CNFG:SETCLOCKINTERVALMILLISECONDS	RMB	2	CAUSE CALL TO SDOS:MSTICK
*	VIA INTERRUPT AFTER DELAY SPECIFIED IN MILLISECONDS
	PAGE
*
*	DEVICE DRIVER ROUTINE ENTRY POINTS
*
	ORG	0
DRIVER:OPEN	RMB	2	OPEN FILE
DRIVER:CLOSE	RMB	2	CLOSE FILE
DRIVER:READA	RMB	2	READ ASCII
DRIVER:WRITEA	RMB	2	WRITE ASCII
DRIVER:READB	RMB	2	READ BINARY
DRIVER:WRITEB	RMB	2	WRITE BINARY
DRIVER:CREATE	RMB	2	CREATE FILE
DRIVER:RENAME	RMB	2	RENAME FILE
DRIVER:DELETE	RMB	2	DELETE FILE
DRIVER:CONTROL	RMB	2	DO CONTROL OPERATION
DRIVER:STATUS	RMB	2	READ DEVICE (DRIVER) STATUS
DRIVER:RESET	RMB	2	RESET DRIVER (ON BOOT)
DRIVER:STARTIO	RMB	2	POINTER TO START I/O ENTRY OF INTERRUPT CODE
DRIVER:PFRESTART	RMB	2	POWER FAIL RESTART
*
*	DISK SECTOR I/O DRIVER ROUTINE ENTRY POINTS
*
	ORG	0
DRIVER:DISKRESET	RMB	2	RESET THIS DISK DRIVER
DRIVER:DISKREAD	RMB	2	INITIATE A DISK SECTOR READ
DRIVER:DISKWRITE	RMB	2	INITIATE A DISK SECTOR WRITE
DRIVER:DISKWAIT	RMB	2	WAIT FOR DISK I/O COMPLETE
DRIVER:DISKSTATUS	RMB	2	READ DISK-SPECIFIC STATUS
DRIVER:DISKCONTROL	RMB	2	PERFORM DISK-SPECIFIC CONTROL OPERATION
DRIVER:DISKWRITEPROTQ	RMB	2	DETERMINE IF DISK IS WRITE PROTECTED
DRIVER:DISKVERIFY	RMB	2	INITIATE A DISK SECTOR VERIFY
DRIVER:DISKLSNTOPSN	RMB	2	CONVERT LSN TO PHYSICAL CYLINDER, TRACK AND SECTOR
	PAGE
*
*	TIMEOUT ELEMENT DISPLACEMENTS
*
	ORG	0
TIMEOUT:LINK	RMB	2	POINTER TO NEXT TIMEOUT QUEUE ELEMENT
TIMEOUT:FUSE	RMB	2	16 BIT TIMEOUT COUNT (1/60 SEC UNITS); 0--> NO TIMEOUT
TIMEOUT:ROUTINE	RMB	2	POINTER TO TIMEOUT INTERRUPT ROUTINE FOR DEVICE
TIMEOUT:DCB	RMB	2	POINTER TO DCB BEING TIMED OUT
TIMEOUT:SIZE	EQU	*
*
*	REGISTER DISPLACEMENTS INTO A CONTEXT BLOCK
*	THESE VALUES ASSUME THAT (S) AFTER INTERRUPT, HAS BEEN COPIED INTO (X)
*
	IF	M6800!M6801
	ORG	1	THIS WORKS, DON'T KNOCK IT!
REG:CC	RMB	1	CONDITION CODE BITS
REG:B	RMB	1	B REGISTER
REG:A	RMB	1	A REGISTER
REG:X	RMB	2	X REGISTER (REG:X+1 IS LOW BYTE OF INDEX REGISTER)
REG:PC	RMB	2	P REGISTER (REG:P+1 IS LOW BYTE OF P COUNTER)
CONTEXTBLOCK:SIZE	EQU	*-1
	ELSE	(M6809)
	ORG	0
REG:CC	RMB	1	CONDITION CODE BITS
REG:A	RMB	1	A REGISTER
REG:B	RMB	1	B REGISTER
REG:DP	RMB	1	DIRECT PAGE REGISTER
REG:X	RMB	2	X REGISTER
REG:Y	RMB	2	Y REGISTER
REG:U	RMB	2	U REGISTER
REG:PC	RMB	2	P REGISTER
CONTEXTBLOCK:SIZE	EQU	*
	FIN
	PAGE
*
*	INTERRUPT SYSTEM DEFINITIONS

*	MINIMUM STACK SIZE HAS ROOM FOR 3 CONTEXT BLOCKS:
*	ONE FOR INTERRUPT, ONE FOR NMI AND ONE FOR DEBUGGER CONTEXT
*	WORKING SPACE REQUIRED BY A TASK MUST BE ADDED TO MINSTACK!
MINSTACK	EQU	3*CONTEXTBLOCK:SIZE

*	TCB (TASK CONTROL BLOCK) DISPLACEMENTS

	ORG	0
TCB:LNK	RMB	2	POINTER TO NEXT TCB IN QUEUE
TCB:STACK	RMB	2	STACK POINTER FOR TASK
*	ON TOP OF A STACK IS ALWAYS A CONTEXT BLOCK
TCB:COND	RMB	2	TASK'S WAKE UP ROUTINE
TCB:PARAM	RMB	2	PARAMETER TO TCB:CND ROUTINE
TCB:SCRATCHPAD	RMB	8	SPACE FOR TASK'S SCRATCHPAD (LOCATIONS 0-7)
TCB:SIZE	; SIZE OF TASK CONTROL BLOCK
*
DCBPOINTER	EQU	$6	POINTER TO DEVICE CONTROL BLOCK
*
	ORG	$F0
SYSDEPENDENT	RMB	0	16 BYTES RESERVED FOR SYSTEM DEPENDENT USE
BASICFLAGS	RMB	1	$F0 IS OWNED BY BASIC/I/O PACK FOR TRACE FLAGS
*
*	DEVICE CONTROL BLOCK DISPLACEMENTS
*
	ORG	0
DCB:DONEFLAG	RMB	1	0 --> DEVICE IS BUSY; <>0 --> DEVICE IS DONE
DCB:LASTERROR	RMB	2	IF DCB IS DONE, CONTAINS ERROR STATUS (0 = NONE )
DCB:NAME	RMB	2	POINTER TO DEVICE NAME STRING TERMINATED BY ZERO BYTE
DCB:NEXTDCB	RMB	2	POINTER TO NEXT DCB IN LIST OR ZERO
DCB:DRIVER	RMB	2	POINTER TO DRIVER ENTRY POINT LIST
*DCB:DVTYP	RMB	1	TYPE OF DEVICE
DCB:SIZE	; DEVICE SPECIFIC DATA EXTENDS DCB FROM HERE
	PAGE
*
*	DISKINFO TABLE DISPLACEMENTS
*
	ORG	DCB:SIZE
DSKINFO:NBPS	RMB	2	NUMBER OF BYTES PER SECTOR
DSKINFO:NSPT	RMB	2	NUMBER OF SECTORS PER TRACK
DSKINFO:NTPC	RMB	2	NUMBER OF TRACKS PER CYLINDER
DSKINFO:NCYL	RMB	2	NUMBER OF CYLINDERS PER DRIVE
*
*	THE FOLLOWING ARE FILLED FROM THE BOOT SECTOR
DSKINFO:NSPC	RMB	1	NUMBER OF SECTORS PER CLUSTER
DSKINFO:MINALLOC	RMB	LCN:SIZE	ALLOCATION MINIMUM FOR NEW FILES
DSKINFO:MIDALLOC	RMB	LCN:SIZE	ALLOCATION MIN FOR FILE EXTENSION
DSKINFO:MAPALGORITHM	RMB	2	CODE TO SELECT LOGICAL TO PHYSICAL SECTOR MAP ALGORITHM
BOOT:PARAMSIZE	EQU	*-DSKINFO:NSPC	SYSTEM DEPENDENT PARAMETERS IN BOOT BLOCK
*	END OF BOOT SECTOR DISK INFO
*DSKINFO:DISKID	RMB	BOOT:DISKIDSIZE	CONTAINS DISK ID FOR MOUNTED DISKS
*
DSKINFO:LOG2NBPS	RMB	1	LOG BASE 2 OF DSKINFO:NBPS
DSKINFO:NBPSM1	RMB	2	= NBPS-1 FOR USE AS MASK (QUICK "MOD NBPS")
DSKINFO:NLSN	RMB	LSN:SIZE	NUMBER OF LSNS FOR THIS DISK = NSPT*NTPC*NCYL
DSKINFO:NLCN	RMB	LCN:SIZE	NUMBER OF LCNS FOR THIS DISK = NLSN/NSPC
DSKINFO:NBPC	RMB	2	NUMBER OF BYTES PER CLUSTER
DSKINFO:RANDMAP	RMB	LCN:SIZE	"RANDOM" LCN TO DISTRIBUTE NEW FILES
DSKINFO:MAPLSN	RMB	LSN:SIZE	LSN OF 1ST SECTOR IN DISK...
*			ALLOCATION MAP CLUSTER
DSKINFO:DIRFCB	RMB	2	POINTER TO FCB FOR $DIRECTORY FILE
DSKINFO:MAPFCB	RMB	2	POINTER TO FCB FOR $DISKMAP FILE
DSKINFO:SECTORDB	RMB	2	POINTER TO RDSI CONTAINING LSN, ADDRESS PARAMETERS
DSKINFO:BADLSN	RMB	3	LSN OF LAST SECTOR THAT COULDN'T READ/WRITE/SEEK
DSKINFO:SEEKERRCNT	RMB	2	# SEEK ERRORS SINCE MOUNT
DSKINFO:SEEKERRSTS	RMB	2	16 BITS OF LAST "SEEK" STATUS IN ERROR
DSKINFO:WRITEERRCNT	RMB	2	# WRITE ERRORS SINCE MOUNT
DSKINFO:WRITEERRSTS	RMB	2	16 BITS OF LAST "WRITE" STATUS IN ERROR
DSKINFO:READERRCNT	RMB	2	# READ ERRORS SINCE MOUNT
DSKINFO:READERRSTS	RMB	2	16 BITS OF LAST "READ" STATUS IN ERROR
DSKINFO:OPSCOUNT	RMB	3	24 BITS OF # DRIVER OPERATIONS SINCEMOUNT
DSKINFO:ERRLSN	RMB	LSN:SIZE	LSN CAUSING ANY SOFT OR HARD ERROR
DSKINFO:WRITEPROTSTATE	RMB	1	0 --> WRITEABLE
DSKINFO:SIZE	EQU	*
	PAGE
*
*	SECTOR DESCRIPTOR BLOCK DISPLACEMENTS
*
	ORG	0
SECTORDB:DISKINFO	RMB	2	POINTER TO DISKINFO TABLE FOR DRIVE CONTAINING SECTOR
SECTORDB:LSN	RMB	LSN:SIZE	LOGICAL SECTOR NUMBER OF SECTOR
SECTORDB:ADDRESS	RMB	2	MEMORY ADDRESS FOR SECTOR
SECTORDB:SIZE	EQU	*
*
*	RESIDENT DISK SECTOR INFORMATION BLOCK DISPLACEMENTS
*
	ORG	0
RDSI:DISKINFO	RMB	2	POINTER TO DISKINFO TABLE FOR THIS DRIVE
RDSI:LSN	RMB	LSN:SIZE	LOGICAL SECTOR NUMBER OF SECTOR
RDSI:SECTORBASE	RMB	2	POINTER TO ACTUAL SECTOR CONTENTS
RDSI:FLINK	RMB	2	FORWARD LINK IN LRU CHAIN
RDSI:BLINK	RMB	2	BACKWARD LINK IN LRU CHAIN
RDSI:MODIFIED	RMB	1	"THIS SECTOR MODIFIED" FLAG
RDSI:STATE	RMB	1	STATE OF RDSI (READING, WRITING, VERIFYING, IDLE)
RDSI:RETRYCOUNT	RMB	1	NUMBER OF TRIES LEFT BEFORE ERROR REPORTED
RDSI:SECTOR	RMB	2	PHYSICAL SECTOR NUMBER OF LSN
RDSI:TRACK	RMB	2	PHYSICAL TRACK NUMBER OF LSN
RDSI:CYLINDER	RMB	2	PHYSICAL CYLINDER NUMBER OF LSN
RDSI:SIZE	EQU	*
*
*	RDSI STATE DEFINITIONS
*
RDSISTATE:IDLE	EQU	0	SECTOR TRANSFER IS COMPLETE
RDSISTATE:READING	EQU	1	SECTOR IS BEING READ INTO MEMORY
RDSISTATE:WRITING	EQU	2	SECTOR IS BEING WRITTEN FROM MEMORY
RDSISTATE:VERIFYING	EQU	3	SECTOR IS BEING VERIFIED AFTER WRITE
	PAGE
*
*	FILE CONTROL BLOCK DISPLACEMENTS
*
	ORG	0
FCB:DISKINFO	RMB	2	POINTER TO DISKINFO TABLE FOR THIS DRIVE
FCB:DIRLSN	RMB	LSN:SIZE	LSN OF DIRECTORY ENTRY
FCB:DIRDISP	RMB	2	DISPLACEMENT FOR DIRECTORY ENTRY FROM TOP OF SECTOR IN BYTES
FCB:HLSN	RMB	LSN:SIZE	= FCB:HLCN*DSKINFO:NSPC
FCB:FLAGS	RMB	1	FLAG BITS DESCRIBING FCB
FCB:REFCOUNT	RMB	1	NUMBER OF IOCBS USING THIS FCB
FCB:HLCN	RMB	LCN:SIZE	HEADER LOGICAL CLUSTER NUMBER OF FILE
FCB:HCSIC	RMB	1	HEADER CLUSTER INITIALIZED COUNT
FCB:NCLUSTERS	RMB	LCN:SIZE	NUMBER OF CLUSTERS ALLOCATED TO THE FILE
FCB:FILESIZE	RMB	4	SIZE OF THE FILE IN BYTES
FCB:PROT	RMB	1	PROTECTION BITS FROM DIRECTORY
FCB:DAY		RMB	1	DATE OF FILE CREATION
FCB:MONTH	RMB	1	MONTH OF FILE CREATION
FCB:YEAR	RMB	1	YEAR OF FILE CREATION MODULO 100
FCB:VERSION	RMB	1	VERSION # OF FILE (NOT USED IN 1.0)
FCB:SIZE	EQU	*
*
	IF	SYSTEMDEFS
FCBFLG::NEWFILE	EQU	$80	FCB:FLAGS --> THIS FILE WAS CREATED
FCBFLG::UPDATEDIR	EQU	$40	FCB:FLAGS --> COPY FCB DATA BACK TO DIRECTORY
FCBFLG::DELETED	EQU	$20	FCB:FLAGS --> THIS FILE WAS DELETED
FCBFLG::MODIFIED	EQU	$10	FCB:FLAGS --> THIS FILE WAS MODIFIED WHILE OPEN
	FIN	SYSTEMDEFS
*
*
*
NMAGICFCBS	EQU	2	FOR ERRMSGFCB, SYSFCB
	PAGE
*
*	IOCB DEFINITIONS
*
	ORG	0
IOCB:DCB	RMB	2	POINTER TO DEVICE CONTROL BLOCK
IOCB:CURLSN	RMB	LSN:SIZE	LOGICAL SECTOR # OF CURBYTE
IOCB:BUFFERP	RMB	2	ADDRESS OF 1ST BYTE TO TRANSFER
IOCB:FCB	RMB	2	POINTER TO FILE CONTROL BLOCK
IOCB:DRIVER	RMB	2	POINTER TO DRIVER VECTOR FOR DEVICE
IOCB:EOFFLAG	RMB	1	END OF FILE HIT FLAG
IOCB:COLCNT	RMB	1	COLUMN COUNTER
IOCB:CURBYTE	RMB	4	VIRTUAL BYTE # TO READ/WRITE FROM/TO NEXT
IOCB:LOCATEDF	RMB	1	0 --> NEED TO DO A LOCATECURBYTE
*			1 --> LOCATECURBYTE DONE
IOCB:DRDSI	RMB	2	POINTER TO DATA RESIDENT DISK SECTOR INFO
IOCB:NEXTBYTE	RMB	2	POINTER TO NEXT BYTE OF DISK SECTOR
IOCB:BYTECOUNT	RMB	2	NUMBER OF BYTES LEFT TO PROCESS IN SECTOR
IOCB:CURLCN	RMB	LCN:SIZE	CURRENT LOGICAL CLUSTER NUMBER BEING PROCESSED
IOCB:DRSN	RMB	1	RELATIVE DATA SECTOR NUMBER WITHIN CLUSTER
IOCB:RDCN	RMB	LCN:SIZE	RELATIVE DATA CLUSTER NUMBER W/ RESPECT TO DATA
*			CLUSTERS WITHIN THE FILE (0=HEADER CLUSTER)
IOCB:RBN	RMB	2	RELATIVE BYTE # WITHIN A CLUSTER
IOCB:HRDSI	RMB	2	POINTER TO RDSI FOR CURRENT HEADER BLOCK
IOCB:HRSN	RMB	1	RELATIVE SECTOR NUMBER OF HEADER SECTOR
*IOCB:SEGMENTRDCN	RMB	LCN:SIZE	RELATIVE DATA CLUSTER FOR START OF SEGMENT
*IOCB:SEGMENTBASELCN	RMB	LCN:SIZE	BASE LCN OF CONTIGUOUS SEGMENT
*IOCB:SEGMENTLENGTH	RMB	LCN:SIZE	NUMBER OF CLUSTERS IN CONTIGUOUS SEGMENT
*IOCB:ENCRYPTIONKEY	RMB	8	HOLDS ENCRYPT/DECRYPT KEY FOR CURRENTLY OPEN FILE
IOCB:SIZE	EQU	*

	IF	SYSTEMDEFS
IOCB:DISKWRITELOCKED	EQU	IOCB:LOCATEDF	1 --> DISK "DEVICE" IS WRITE LOCKED
	FIN	SYSTEMDEFS
	FIN	SYSTEMDEFS!IOPKDEFS
	PAGE
	IF	SYSTEMDEFS
*
*	SDOS LOADER FORMAT:  RECORD TYPE DEFINITIONS
*
LOAD:TYPE0	EQU	0	"SKIP" RECORD
	IF	M6800
LOAD:TYPE1	EQU	1	STARTUP RECORD
	ELSEIF	M6801
LOAD:TYPE1	EQU	3
	ELSEIF	M6809
LOAD:TYPE1	EQU	2
	FIN
LOAD:TYPE2	EQU	2	LOAD BYTES RECORD
LOAD:TYPE3	EQU	3	LOAD BYTES AND STOP RECORD
LOAD:ENCRYPTED	EQU	5	"THIS FILE IS ENCRYPTED" LOAD RECORD
*
*	BOOT SECTOR DISPLACEMENTS
*
	ORG	0
BOOT:IPLDATA	RMB	16	CONTAINS "JMP BOOTSIZE" OR OTHER BOOTSTRAP DATA
BOOT:DISKINFO	RMB	0	SPACE FOR DISKINFO TABLES
BOOT:DISKINFOLEN	EQU	16
BOOT:FILESYSTEMVERSION	RMB	1	SDOS FILE SYSTEM FORMAT VERSION NUMBER $AB = A.B
BOOT:NSPC	RMB	1	NUMBER OF SECTORS PER CLUSTER
BOOT:MINALLOC	RMB	LCN:SIZE	ALLOCATION MINIMUM FOR NEW FILES
BOOT:MIDALLOC	RMB	LCN:SIZE	ALLOCATION MIN FOR FILE EXTENSION
BOOT:MAPALGORITHM	RMB	2	LOGICAL TO PHYSICAL CONVERSION ALGORITHM #
BOOT:CREATIONDATE	RMB	3	DD/MM/YY IN HEX
BOOT:DIRLSN	RMB	LSN:SIZE	LSN OF DIRECTORY SECTOR CONTAINING "DIRECTORY.SYS"
	RMB	BOOT:DISKINFOLEN+BOOT:DISKINFO-*-1
BOOT:CHECKSUM	RMB	1	SUCH THAT SUM OF DISKINFO BYTES (INCL CKSUM) = $FF
BOOT:DISKIDSIZE	EQU	32	# BYTES RESERVED FOR ASCII DISK IDENTIFICATION
BOOT:DISKID	RMB	BOOT:DISKIDSIZE	TEXT NAME OF DISK (TRAILING BLANK PADDED)
BOOT:SIZE	EQU	*
	PAGE
*
*	DIRECTORY ENTRY DISPLACEMENTS
*

	ORG	0
DIR:NAMESIZE	EQU	16	LENGTH OF DIRECTORY NAME
DIR:FILENAME	RMB	DIR:NAMESIZE	FILENAME IN ASCII
DIR:FCBDATA	RMB	0	FCB DATA FOR FILE MANAGEMENT STARTS HERE
DIR:HLCN	RMB	LCN:SIZE	LCN OF HEADER CLUSTER
DIR:HCSIC	RMB	1	HEADER CLUSTER INITIALIZED COUNT
DIR:NCLUSTERS	RMB	LCN:SIZE	NUMBER OF CLUSTERS ALLOCATED TO FILE
DIR:FILESIZE	RMB	4	LOGICAL SIZE OF FILE IN BYTES
DIR:PROTECTION	RMB	1	PROTECTION BITS
DIR:DAY	RMB	1	CREATION DATE OF FILE
DIR:MONTH	RMB	1	MONTH OF FILE CREATION
DIR:YEAR	RMB	1	YEAR OF FILE CREATION
DIR:VERSION	RMB	1	VERSION NUMBER OF FILE (0-255)
DIR:FCBDATASIZE	EQU	*-DIR:FCBDATA	# BYTES REQUIRED TO MANAGE FILES IN FCBS
	RMB	32-*	SPACE FOR SLOP
DIR:ENTRYSIZE	EQU	*
	PAGE
*
*
*	DISKMAP DISPLACEMENTS
*
	ORG	0
DISKMAP:BYTE	RMB	1
NMBPB	EQU	8	# MAP BITS PER BYTE
*
SECTOR:BYTE	EQU	0	USED AS DISPLACEMENT ON SECTOR BYTE FETCH
*
READAHEADRDSIMIN	EQU	3	READ-AHEAD HAPPENS ONLY IF MORE BUFFERS AVAILABLE
DUMMYLCN	EQU	$FFFF	"NO LCN" CODE
*
*	HEADER CLUSTER DISPLACEMENTS
*
	ORG	0
HEADER:LCN	RMB	LCN:SIZE
*
SERIALNUMBER:SIZE	EQU	8	SIZE OF SERIAL NUMBERS
*
*	WEIRD CHANNEL DEFINITIONS
*
LOGCHANNEL	EQU	$FF	(LOG CHANNEL MUST BE LOWEST OF THESE)
SYSCHANNEL	EQU	$FE	SYSTEM I/O CHANNEL (RESERVED)
	FIN	SYSTEMDEFS
	IF	LISTDEFS
	PSR	1	WE TURNED THIS OFF, TURN IT BACK ON
	ELSE
	LIST	1	FORCE LISTING AGAIN
	FIN

        ORG     SYSCALL$
        ;JMP    SDOSINIT        SO BOOT'S EXIT SYSCALL RESETS SDOS
        JMP     SDOSINIT
*       THIS PLACE IS CHANGED TO A "JMP SYSCALLENTRY" BY INIT CODE
        page
        Org     $2000   BOOT.SYS owns $0-$1FFF when loading SDOS.SYS

SDOSINIT        EQU     *
*
*       SET UP SDOS STACK POINTER
*       ASSERT: DP REGISTER CONTAINS ZERO HERE!
*
        ;LDX    CODE+SDOS:CONFIGURATION    GET THE STACK POINTER
        LDX     CODE+SDOS:CONFIGURATION
        ;LDX    CNFG:DRIVERBASE,X
        LDX     CNFG:DRIVERBASE,X
        TXS             SO (S) POINTS TO 1ST BYTE BELOW DRIVER PACKAGE
        STS     SDOSSTACK AND SAVE FOR RE-USE BY EXIT
        LDAA      #$7E    ("JMP" OPCODE) SET UP I/O PACKAGE BASE...
        STAA      ,X      TO POINT TO SDOS ENTRY POINT
        ;LDD    #SYSCALLENTRY
        LDAB      #(SYSCALLENTRY)&$FF
        LDAA      #(SYSCALLENTRY)/256
        ;STD    1,X
        STAB      (1)+1,X
        STAA      1,X
        CLRA              MAKE SURE SDOSINIT CODE IS OK!
        ;LDX    #SDOSINIT       BASE OF AREA TO CHECKSUM
        LDX     #SDOSINIT
SDOSINITCKSUML   ; LOOP TO CHECKSUM BYTES
        ASLA              MAKE CHECKSUM DEPEND ON ORDER OF BYTES
        IF      M6800!M6801
        ADCA       0,X
        INX
        ELSE
        ADCA       ,X+
        FIN
        CPX      #SDOSINITEND
        BNE      SDOSINITCKSUML
        ;LDX    #ERR:SELFTESTCKSUM       ASSUME WE'RE SCREWED UP!
        LDX     #ERR:SELFTESTCKSUM
        ADDA      #$FF
        NOP 	;ZZZ BCS       *       CHECKSUM <> 0, I'M SICK!
        NOP	
        ;JSR    SDOSINITS       CALL THE INITIALIZING SUBROUTINE
        JSR     SDOSINITS
        BCS       *       B/ CROAKED IN CRITICAL INITIALIZATION CODE
        PAGE
*       Now test the ROM for proper construction.
*       If SERIALNUMBERLOCATION is zero,
*       Then: Follow Restart Vector to JMP around Serial number,
*       Verify presence of ROM serial number,
*       Restart-zeros-memory when RunningEncrypted code,
*       and NMI-is-nop code when RunningEncrypted.
*       Verify that all this stuff is in ROM so it cannot be turned off.
*
*       If SERIALNUMBERLOCATION is not zero, simply check
*       that serial number (as specified by SERIALNUMBERLOCATION) is in ROM.
*       Don't check SELECTBANK or NMI routine structure or operation;
*       don't fool with the RUNNINGENCRYPTED byte.  This allows SDOS
*       to operate in mass-produced, commercial micros such as
*       the Radio Shack Color Computer, which have Mask ROMs that cannot
*       be changed by SD (Sigh!)
*
*
        ;ldx    SerialNumberLocation    get pointer to S/N in mask-rom system
        LDX     SerialNumberLocation
        NOP	;ZZZ beq     VerifyRestartCode0       b/ Standard ROM structure
        NOP
        ;lda    #SerialNumber:Size      = size of serial number
        LDAA      #SerialNumber:Size
        ;jsr    WriteRandom     Verify serial number is in ROM
        JSR     WriteRandom
        ;jmp    FetchSerialNumberSys    All done with ROM checking
        JMP     FetchSerialNumberSys

VerifyRestartCode0 ; Check for standard ROM structure
        ;ldx    $fffe   follow restart vector to JMP around serial number
        LDX     $fffe
        stx     CopyofRestartVector
        ;ldx    $fffc   Get NMI vector pointer
        LDX     $fffc
        stx     CopyofNMIVector
        ;ldx    #$fffc  make sure NMI and RESTART vectors are ROM
        LDX     #$fffc
        ldaa    #4      = size of region to write on
        ;jsr    WriteRandom     write all over region
        JSR     WriteRandom
        ;ldx    $fffe   Get "trashed-if-RAM" Restart Vector
        LDX     $fffe
        cpx     CopyofRestartVector Did it get trashed?
        bne     IncorrectROM    b/ yes, so-called "ROM" is not.
        ldaa    #8+3    verify ROM serial number is in ROM.
        ;jsr    Writerandom     over region (X) thru (X+A)
        JSR     Writerandom
*
*       Verify presence of Reset code to zero memory if Encryted flag is set
*       Including checks for RunningEncrypted flag is in RAM,
*       that SelectBank subroutine actually works,
*       and that the entire thing is in ROM
*       Also verify that ROM causes NMI when encrypted to be ignored
*
        ;ldx    1,x     pointer to "Zero Memory if encrypted" code
        LDX     1,X
*
*
        ldaa    #DontZeroMemory-Restart = length of Zero Memory sequence
        ;jsr    writerandom     write randomly over region x thru x+a
        JSR     writerandom
        if      m6800!m6801
        ldaa    0,x     Must be LDS immediate opcode
        ;cmpa   #$8E
        CMPA      #$8E
        else    (m6809)
        ;ldd    0,x     Must be LDS immediate opcode
        LDAB      (0)+1,X
        LDAA      0,X
        ;cmpd   Restart
        CMPA      Restart
        BNE      MACRO:0001
        CMPB      Restart+1
MACRO:0001
        fin
        bne     IncorrectROM    b/ Nope.
        ldaa    LdaEncrypted-Restart,x This must be "ldaa" extended opcode
        ldab    LdaEncrypted+3-Restart,x and this must be "Beq" opcode
        ;cmpd   #$B627
        CMPA      #($B627)/256
        BNE      MACRO:0002
        CMPB      #($B627)&$FF
MACRO:0002
        bne     IncorrectROM    b/ its not...
        ldaa    LdaEncrypted+5-Restart,x        Must be "ldaa" immediate opcode
        ldab    EraseBank-Restart,x and this must be "Jsr" extended opcode
        ;cmpd   #$86BD   check...
        CMPA      #($86BD)/256
        BNE      MACRO:0003
        CMPB      #($86BD)&$FF
MACRO:0003
        bne     IncorrectROM    Wrong code --> won't run program
        ;ldd    LdaEncrypted+1-Restart,x = address of RunningEncrypted
        LDAB      (LdaEncrypted+1-Restart)+1,X
        LDAA      LdaEncrypted+1-Restart,X
        ;std    RunningEncryptedp
        STAB      RunningEncryptedp+1
        STAA      RunningEncryptedp
        ldab    #DontZeroMemory-EraseMem = # bytes to push before compare...
VerifyRestartCode1 ; push bytes from Restart-zeros-memory into stack...
        dex     back up to previous byte
        ldaa    DontzeroMemory-Restart,x push a byte...
        psha
        decb
        bne     VerifyRestartCode1 b/ didn't push enough bytes yet
        ;ldx    #EraseMem-1     = code to compare against
        LDX     #EraseMem-1
        ldab    #DontZeroMemory-EraseMem = # bytes to compare
VerifyRestartCodeloop
        inx             advance pointer to next byte to match
        pula            pop byte to compare
        ;cmpa   0,x
        CMPA      0,X
        bne     IncorrectROM    b/ contents of Restart-zeros-mem is wrong
        decb
        bne     VerifyRestartCodeloop b/ more bytes to compare
*
*       Reset code has correct structure.
*       Verify that RunningEncrypted byte is in RAM, and is thus not always 0.
*
        ;ldx    Runningencryptedp       Verify runningencrypted is in RAM
        LDX     Runningencryptedp
        ;clr    0,x     will it store a zero?
        CLR      0,X
        ldaa    0,x
        bne     IncorrectROM    b/ RunningEncrypted is not in RAM
        ldaa    #$39    Verify that RunningEncrypted byte is RAM
        staa    0,x     (Store an "RTS" instruction there!)
        ;cmpa   0,x     (SELECTBANK will blow up if zeros RunningEncrypted flag
        CMPA      0,X
        bne     IncorrectROM    b/ RunningEncrypted is not in RAM
        page
*
*       Now verify that SELECTBANK works properly.
*       Note: a theif could build a phony SelectBank that checks the
*       return address to see if it points to EraseMem (or the stack pointer
*       to see if it contains the Restart value - 2), and if so,
*       simply jumps to Dontzeromemory (see ROM descripton of Encrypted files)
*       That defeats our purpose. I hope nobody figures it out.
*       We can actually verify that for this machine, the Selectbank
*       routine is correct by examining the serial number, which tells us
*       the distributor, and therefore the machine organization;
*       this in turn tells us exactly what the SelectBank code should be.
*       But we don't do that yet, because a hole in I/O package is easier to
*       take advantage of, so fixing this wouldn't really help much.
*       We could also check (??) that select bank has no instructions
*       in it that reference the stack register. That is, instructions
*       that compare the stack pointer to anything, or copy the stack
*       pointer (i.e., push it, store it, etc.) (to prevent copying it and
*       THEN comparing), and indexed references to it
*       (to prevent the return address from being examined)]. This is
*       lots tougher! But DOABLE!
*
        ;ldd    #VerifyNMIisnop where to come back to...
        LDAB      #(VerifyNMIisnop)&$FF
        LDAA      #(VerifyNMIisnop)/256
        ;pshd           Call SelectBank to make sure it works!
        PSHB
        PSHA
        ;ldd    RunningEncryptedp       With Return address = RunningEncrypted-1
        LDAB      RunningEncryptedp+1
        LDAA      RunningEncryptedp
        ;pshd           Push "Return address" to byte on stack
        PSHB
        PSHA
        clra            Verify that Select Bank subroutine works..
        ;ldx    $fffe   Get address of RunningEncrypted routine
        LDX     $fffe
        ;ldx    1,x     = address of Reset-zeros-memory code
        LDX     1,X
        ;ldx    EraseBank-Restart+1,x    = pointer to SelectBank routine
        LDX     EraseBank-Restart+1,X
        ;jmp    0,x     invoke it to select bank 0
        JMP     0,X
        page
IncorrectROM ; Contents of Boot ROM is incorrect
        ;ldd    #SayInvalidROM-$1275 pass control to routine to print it...
        LDAB      #(SayInvalidROM-$1275)&$FF
        LDAA      #(SayInvalidROM-$1275)/256
        ;addd   #$1275  in a non-obvious way
        ADDB      #($1275)&$FF
        ADCA       #($1275)/256
        ;pshd           people with disassemblers will never get it
        PSHB
        PSHA
        rts
*
*       Verify that NMI routine acts as NOP when RunningEncrypted
*
VerifyNMIisnop
        ;ldx    $fffc   = address of NMI code
        LDX     $fffc
        cpx     CopyofNMIVector  Ensure NMI vector is in ROM
        bne     IncorrectROM    b/ its not.
        ldaa    #5      size of NMI code that we wish to test
        ;jsr    WriteRandom     all over the NMI code
        JSR     WriteRandom
        ldaa    0,x     this is sposd to be LDAA opcode
        ldab    3,x     and this is sposd to be "BNE" opcode
        ;cmpd   #$B626   check them both...
        CMPA      #($B626)/256
        BNE      MACRO:0004
        CMPB      #($B626)&$FF
MACRO:0004
        bne     IncorrectROM    b/ NMI routine is RAM or wrong
        ;ldd    1,x     sposd to be address of RunningEncrypted
        LDAB      (1)+1,X
        LDAA      1,X
        ;cmpd   RunningEncryptedp       heck it out...
        CMPA      RunningEncryptedp
        BNE      MACRO:0005
        CMPB      RunningEncryptedp+1
MACRO:0005
        bne     IncorrectROM    b/ pointers are different!
        ldab    4,x     = displacement to RTI in BNE instruction
        if      m6800!m6801
        tba
        asra            shift right, propogating the sign bit
        asra            shift right, propogating the sign bit
        asra            shift right, propogating the sign bit
        asra            shift right, propogating the sign bit
        asra            shift right, propogating the sign bit
        asra            shift right, propogating the sign bit
        asra            shift right, propogating the sign bit
        ;addd   $fffc   = address of RTI,-5
        ADDB      $fffc+1
        ADCA       $fffc
        ;tdx
        STAA      TEMPA
        STAB      TEMPB
        LDX     TEMPX
        else    (m6809)
        ;leax   b,x     = address of RTI,-5
        IF      b<0
        RPT     -b
        DEX
        ELSE
        RPT     b
        INX
        FIN
        fin
        ;clr    5,x     make sure RTI is in ROM
        CLR      5,X
        ldaa    5,x     should be an RTI opcode
        ;cmpa   #$3B     an RTI instruction?
        CMPA      #$3B
        ;lbne   IncorrectROM    b/ NMI routine is incorrect!
        BEQ      MACRO:0006
        JMP     IncorrectROM
MACRO:0006
*
*       End ROM checking
*       Assert: RunningEncrypted is now set!
        page
FetchSerialNumberSys ; Pass control to SERIALNUMBER.SYS
        ;LDX    #OPENSERIALNO.SYS        SEE IF SERIALNUMBER.SYS IS ENCRYPTED
        LDX     #OPENSERIALNO.SYS
        ;JSR    DOSYSCALL
        JSR     DOSYSCALL
        ;LDX    #READSERIALNUMBERFILETYPE  GO GET 1ST LOAD RECORD OF FILE
        LDX     #READSERIALNUMBERFILETYPE
        ;JSR    DOSYSCALL
        JSR     DOSYSCALL
        ;LDX    #CLOSESERIALNO.SYS        LEAVE THE SLATE CLEAN, CLOSE THE FILE
        LDX     #CLOSESERIALNO.SYS
        ;JSR    DOSYSCALL (WE MUST DO THIS BECAUSE FIRSTCHAIN DOESN'T CALL EXITS)
        JSR     DOSYSCALL
        ;LDX    #ERR:NOTALOADFILE ASSUME THE WORST...
        LDX     #ERR:NOTALOADFILE
        ;LDA     DECRYPTBUFFER     FETCH LOAD RECORD TYPE
        LDAA      DECRYPTBUFFER
        ;CMPA     #LOAD:ENCRYPTED   AN ENCRYPTED LOAD FILE ?
        CMPA      #LOAD:ENCRYPTED
        ;ZZZ 	BNE      INITIALIZEERR    B/ NOT ENCRYPTED, GO TELL USER AND DIE...
        NOP
        NOP
        ;LDX    #CHAINTOSERIALNO.SYS       GO GET SERIALNUMBER.SYS
        LDX     #CHAINTOSERIALNO.SYS
        STX     CODE+SDOS:IOBLOCKPTR       SET UP SYSCALL BLOCK POINTER LIKE SYSCALLENTRY
        ;INC     SDOSRECURSIVECALL  LIKE SYSCALL ENTRY
        INC      SDOSRECURSIVECALL
        ;JSR    FIRSTCHAIN        AVOID SYSCALL ENTRY SO "SAFEGAURD" NOT INVOKED FOR THIS CALL
        JSR     FIRSTCHAIN
        BCC        *       CAN'T COME BACK WITH CARRY CLEAR!
        CPX      #ERR:SERIALNOWRONG       WRONG MACHINE?
        BEQ      ERRWRONGSERIALNUMBER      B/ YES, TELL THE GUY.
*
*       If no SERIALNUMBER.SYS, or phony SERIALNUMBER.SYS,
*       then the Secret Long-term operation enabling signal...
*       will not be passed to SDOS, and so SDOS will die relatively quickly!
*
INITIALIZEERR    ; PROBLEM OCCURRED AFTER INITIALIZING SDOS
        STX     ERRORCODE        PROBLEM WASN'T WHAT I EXPECTED
        ;LDX    #SETINITERROR   SO TELL THE OPERATOR...
        LDX     #SETINITERROR
        ;JSR    SYSCALLENTRY
        JSR     SYSCALLENTRY
        BCS       *       B/ THIS ISN'T OUR DAY FOR THINGS TO GO RIGHT
        ;LDX    #DISPLAYINITERROR
        LDX     #DISPLAYINITERROR
        ;JSR    SYSCALLENTRY
        JSR     SYSCALLENTRY
        BCS       *
        BRA       *       IT CAN'T GET HERE, BUT I'M PARANOID ANYWAY...
        page
*
*       Copy of code that is required to be in ROM Restart Routine
*
Restart Lds     #$1234  Reset the stack pointer
LdaEncrypted
        Ldaa    $1234   "RunningEncrypted"
        Beq      DontzeroMemory  B/ don't have to erase the world
        Ldaa    #$12    Number of banks, -1
EraseBank
        ;Jsr    $1234   "JSR SelectBank" (1234 is dummy)
        JSR     $1234
EraseMem        ; This is copy of code that is required to be in ROM Restart routine
        ;Ldx    #$BFFF   (this code zeros memory)
        LDX     #$BFFF
EraseLoop
        ;Clr     0,x
        CLR      0,X
        Dex
        Bne      EraseLoop
        Deca            (decrements Bank number)
        bpl     Erasebank
DontzeroMemory ; end of code required to be in ROM Restart routine
        page
*
*       WriteRandom -- Write Random numbers over the Region (X) to (X)+(A)
*       Exits with (X) = value on entry
WriteRandom
        RTS	;ZZZ stx     tempx   preserve (X)
        NOP	
WriteRandomL
        ldab    seed    generate new random number
        beq     WriteRandom1    b/ zero seed, handle as special case
        bpl     WriteRandom2
WriteRandom1 ;  THIS ROUTINE NEEDS WORK!!!
        ;eorb   #$81
        EORB     #$81
WriteRandom2
        aslb
        adcb    #0
        stab    seed
        ;stb    ,x+     store random trash on the byte
        STAB      0,X
        INX
        deca            down count # bytes to trash
        bne     WriteRandomL
        ;ldx    tempx   restore x to original value
        LDX     tempx
        rts
        page
DoSyscall ; Execute syscall (X) and print error if failed
        ;jsr    syscallentry
        JSR     syscallentry
        bcs     initializeerr
        rts

ERRWRONGSERIALNUMBER ; print out serial no of CPU, SerialNumber.sys and die.
        ;jsr    getserialnumberaddress  get pointer to ROM serial number
        JSR     getserialnumberaddress
        ;ldd    #CPUSerialNumber Where to put converted serial number
        LDAB      #(CPUSerialNumber)&$FF
        LDAA      #(CPUSerialNumber)/256
        ;jsr    cvttohexserialno convert (X) to hexadecimal serial # string
        JSR     cvttohexserialno
        ;ldx    #openserialno.sys
        LDX     #openserialno.sys
        bsr     dosyscall
        ;ldx    #ReadSerialNumberFromFile       into DecryptBuffer
        LDX     #ReadSerialNumberFromFile
        bsr     dosyscall
        ;ldx    #decryptbuffer
        LDX     #decryptbuffer
        ;ldd    #SDOSSerialNumber where to put Ascii hex version of Serial #
        LDAB      #(SDOSSerialNumber)&$FF
        LDAA      #(SDOSSerialNumber)/256
        ;jsr    cvttohexserialno
        JSR     cvttohexserialno
        ;ldx    #PrintCantRun
        LDX     #PrintCantRun
        bsr     dosyscall
        page
WaitforMessagePrinted
        ldaa    #4*(CantRunMsgEnd-CantRunmsg)//10 max time to print message
delayloop ; wait for 8 * 65536 * .5 sec = .262 second
        dex
        bne     delayloop
        deca    down count # quarter-seconds to delay...
        bne     delayloop
        ;ldx    zapmemoryloop   copy zap memory routine to $100
        LDX     zapmemoryloop
        stx     $100
        ;ldx    zapmemoryloop+2
        LDX     zapmemoryloop+2
        stx     $102
        ;ldx    zapmemoryloop+4
        LDX     zapmemoryloop+4
        stx     $104
        ;ldx    zapmemoryloop+6
        LDX     zapmemoryloop+6
        stx     $106
        ;ldx    #$c000  erase memory (Paranoia strikes!)
        LDX     #$c000
        ldaa    #$3E    wait for interrupt opcode
        ;jmp    $100    go destory memory
        JMP     $100

zapmemoryloop ; destroy memory contents
        ;sta    ,-x     this loop will stop...
        DEX
        STAA      0,X
        ;sta    ,-x     when ZapLast is overwritten
        DEX
        STAA      0,X
        bra     zapmemoryloop
        page
PrintCantRun ; Syscall to print "Can't run on this CPU"
        fcb     Syscall:Writea,Writea:Sclen
        fcb     0,ignored
        fdb     CantRunMsg,CantRunMsgEnd-CantRunMsg

Cantrunmsg
        fcc     "Cannot run SDOS for CPU serial number "
SDOSSerialNumber
        fcc     "xxxxxxxxxxxxxxxx"
        fcb     ascii:cr
        fcc     "on this processor (CPU serial number "
CPUSerialNumber
        fcc     "xxxxxxxxxxxxxxxx)."
        fcb     ascii:cr
Cantrunmsgend

SayInvalidROM ; Tell would-be theif that ROM isn't right!
*       Transfers to this location must be via RTS with registers trashed...
*       So that a breakpoint here cannot be used to trace backwards...
*       to the code jumping here
        ;ldx    #PrintInvalidROM        Let the theif know
        LDX     #PrintInvalidROM
        ;jsr    dosyscall
        JSR     dosyscall
        ;jmp    WaitforMessagePrinted and then erase memory
        JMP     WaitforMessagePrinted

PrintInvalidROM ; Syscall to display "Invalid ROM"
        fcb     Syscall:Writea,Writea:Sclen
        fcb     0,ignored
        fdb     InvalidROMMsg,InvalidROMMsgEnd-InvalidROMMSG

InvalidROMMsg
        fcc     "Boot ROM not constructed properly for Serial Numbered SDOS Systems"
        fcb     ascii:cr
InvalidROMMsgEnd
        page
*
*       CvttoHexSerialNo -- Convert (X) for 8 bytes to Ascii serial number
*       (D) points to target string buffer
*
CvttoHexSerialNo
        ;std    topointer       save pointer to target
        STAB      topointer+1
        STAA      topointer
        ldab    #SerialNumber:Size      # bytes to convert
CvttoHexSerialNoloop ; convert a byte
        pshb
        ;lda    ,x+
        LDAA      0,X
        INX
        bsr     HextoD  Ascii of both nibbles to (D)
        stx     frompointer
        ;ldx    topointer       target buffer pointer
        LDX     topointer
        ;std    ,x++
        STAB      (0)+1,X
        STAA      0,X
        INX
        INX
        stx     topointer
        ;ldx    frompointer
        LDX     frompointer
        pulb
        decb
        bne     CvttoHexSerialNoLoop b/ more byte to convert
        rts

Hextod ; Convert (A) to Ascii Hex in (a,b)
        tab     duplicate byte so we can split into nibbles
        lsra    move upper nibble to lower part of (a)
        lsra
        lsra
        lsra
        andb    #$F     extract lower nibble
        adda    #'0     convert (a) to hex digit
        ;cmpa   #'9     valid digit?
        CMPA      #'9
        bls     Hextod1 b/ yep.
        adda    #'A-10-'0        no, convert to A-F hex.
Hextod1
        addb    #'0     convert (b) to hex ascii
        ;cmpb   #'9     valid digit?
        CMPB      #'9
        bls     Hextod2 b/ yep.
        addb    #'A-10-'0        no, convert to A-F hex
Hextod2
        rts

SDOSINITCKSUM    FCB       CHANGED   CHECKSUM OVER SDOSINIT CODE
*
*       SDOSINITCKSUM has a value such that the "sum" of all bytes...
*       between SDOSINIT and SDOSINITEND is zero.
*       Note that SDOSINITCKSUM is part of that sum.
SDOSINITERRED   EQU     *
        ;JMP    ERRORINX
        JMP     ERRORINX

SDOSINITS       ; INITIALIZING SUBROUTINE
*
*       WITH INTERRUPTS DISABLED, GO RESET ALL THE DEVICE DRIVERS
*
        ;LDX    CODE+SDOS:CONFIGURATION    SCAN THROUGH THE DEVICE LIST
        LDX     CODE+SDOS:CONFIGURATION
        ;LDX    CNFG:DEVICEDCBS,X   AND RESET EACH DEVICE FOUND IN THE LIST
        LDX     CNFG:DEVICEDCBS,X
        STX     DCBPOINTER        SAVE POINTER TO DCB LIST
        ;LDX    DCB:DRIVER,X      SAVE POINTER TO CONSOLE DRIVER FOR USE BY READA
        LDX     DCB:DRIVER,X
        STX     CONSOLEDRIVER
        ;LDX    DCBPOINTER        FIND OUT LENGTH OF CONSOLE DEVICE NAME
        LDX     DCBPOINTER
        ;LDX    DCB:NAME,X
        LDX     DCB:NAME,X
        STX     CONSOLENAMEPTR    SAVE ADDRESS OF CONSOLE NAME
SDOSINIT0       ; LOOP TO COMPUTE LENGTH OF CONSOLE DEVICE NAME
        INX             BUMP POINTER TO CONSOLE DEVICE NAME PAST NAME CHARACTER
        ;INC     CONSOLENAMELEN+1  BUMP # CHARACTERS IN CONSOLE NAME LENGTH
        INC      CONSOLENAMELEN+1
        LDAA      ,X      LOOK AT BYTE OF CONSOLE NAME
        BNE      SDOSINIT0       B/ NOT END OF CONSOLE DEVICE NAME
        BRA       SDOSINIT1A       GO RESET THE DEVICES IN THE LIST

SDOSINIT1       ; FIND END OF NEXT DEVICE NAME
        STX     DCBPOINTER        SAVE POINTER TO REST OF DEVICE NAME LIST
SDOSINIT1A       EQU     *
        ;LDX    DCBPOINTER        RESET A DEVICE
        LDX     DCBPOINTER
        ;LDX    DCB:DRIVER,X      WITH INTERRUPTS OFF....
        LDX     DCB:DRIVER,X
        STX     DRIVERVPOINTER  AND INTERRUPT SYSTEM NOT READY!
        ;JSR    [DRIVER:RESET,X]
        LDX     DRIVER:RESET,X
        JSR     0,X
        BCS       SDOSINITERRED   B/ DRIVER HAD AN ERROR!
        ;LDX    DCBPOINTER        GET ADDRESS OF REST OF DEVICE NAME LIST
        LDX     DCBPOINTER
        ;LDX    DCB:NEXTDCB,X       END OF LIST ?
        LDX     DCB:NEXTDCB,X
        BNE      SDOSINIT1       B/ NO, GO RESET THE NEXT DEVICE
        ;JSR    [DRIVER:RESET+DISKFILEDRIVER]   RESET THE DISK FILE DRIVER
        LDX     DRIVER:RESET+DISKFILEDRIVER
        JSR     0,X
        ;JSR    [DRIVER:RESET+DISKDEVICEDRIVER]  RESET THE DISK DEVICE DRIVER
        LDX     DRIVER:RESET+DISKDEVICEDRIVER
        JSR     0,X
*** NOTE: THE DISK DRIVERS ARE RESET LAST SO THAT THE INIT ROUTINES...
*** FOR ALL THE OTHER DEVICES CAN BE ASSEMBLED AND EXECUTED IN THE
*** DISK BUFFER AREA (SETTING UP THE DISK DRIVERS DESTROYS THE CONTENTS OF THE BUFFER AREA)
        PAGE
*
*       SET UP INTERRUPT SYSTEM
*
        ;LDX    CODE+SDOS:CONFIGURATION    SET UP THE INTERRUPT STACK POINTER...
        LDX     CODE+SDOS:CONFIGURATION
        ;LDX    CNFG:INTERRUPTSTACK,X      SO SCHEDULER CAN GRAB ITS VALUE QUICKLY
        LDX     CNFG:INTERRUPTSTACK,X
        STX     INTERRUPTSTACK
        ;LDX    CODE+SDOS:CONFIGURATION    MAKE A "JMP IOINTPOLL"...
        LDX     CODE+SDOS:CONFIGURATION
        ;LDX    CNFG:IOINTPOLL,X SO WE CAN GET TO DEVICE POLL ROUTINE QUICKLY
        LDX     CNFG:IOINTPOLL,X
        STX     JMPIOINT+1      THE "JMP" PART IS ASSEMBLED IN, ALREADY
        ;LDX    CODE+SDOS:CONFIGURATION    SET UP "INTDISABLE"
        LDX     CODE+SDOS:CONFIGURATION
        LDAA      CNFG:INTDISABLE,X  GRAB THE 3 BYTES FROM THE CONFIGURATION TABLE
        ;LDX    CNFG:INTDISABLE+1,X
        LDX     CNFG:INTDISABLE+1,X
        STAA      INTDISABLE        AND STORE THEM IN A MORE CONVENIENT PLACE
        STX     INTDISABLE+1
        ;LDX    CODE+SDOS:CONFIGURATION    SET UP "INTENABLE"
        LDX     CODE+SDOS:CONFIGURATION
        LDAA      CNFG:INTENABLE,X
        ;LDX    CNFG:INTENABLE+1,X
        LDX     CNFG:INTENABLE+1,X
        STAA      INTENABLE
        STX     INTENABLE+1
        ;LDX    CODE+SDOS:CONFIGURATION    SET UP "INTRTI"
        LDX     CODE+SDOS:CONFIGURATION
        LDAA      CNFG:INTRTI,X
        ;LDX    CNFG:INTRTI+1,X
        LDX     CNFG:INTRTI+1,X
        STAA      INTRTI
        STX     INTRTI+1
        ;LDX    CODE+SDOS:CONFIGURATION    SET UP NUMBER OF TIME OUT BLOCKS
        LDX     CODE+SDOS:CONFIGURATION
        ;LDD    CNFG:TIMEOUTLIST,X       GRAB POINTER TO LIST OF TIMEOUT BLOCKS
        LDAB      (CNFG:TIMEOUTLIST)+1,X
        LDAA      CNFG:TIMEOUTLIST,X
        ;STD    DELAYBLOCK+TIMEOUT:LINK    ATTACH TO DELAYBLOCK TIMEOUT BLOCK
        STAB      DELAYBLOCK+TIMEOUT:LINK+1
        STAA      DELAYBLOCK+TIMEOUT:LINK
        ;LDD    #DELAYBLOCK        MAKE CONFIGURATION TABLE POINT TO DELAY BLOCK
        LDAB      #(DELAYBLOCK)&$FF
        LDAA      #(DELAYBLOCK)/256
        ;STD    CNFG:TIMEOUTLIST,X       ASSERT: # TIMEOUT BLOCKS NOW >= 1!
        STAB      (CNFG:TIMEOUTLIST)+1,X
        STAA      CNFG:TIMEOUTLIST,X
        ;LDX    CNFG:TIMEOUTLIST,X       COUNT NUMBER OF TIMEOUT BLOCKS
        LDX     CNFG:TIMEOUTLIST,X

SDOSINIT1L      ; COUNT # TIMEOUT BLOCKS
        ;INC     NTIMEOUTBLKS     COUNT A TIMEOUT BLOCK
        INC      NTIMEOUTBLKS
        ;LDX    TIMEOUT:LINK,X  FIND ADDRESS OF NEXT TIMEOUT BLOCK
        LDX     TIMEOUT:LINK,X
        BNE      SDOSINIT1L      B/ ANOTHER TIMEOUT BLOCK FOUND!
SDOSINIT1B       EQU     *
        PAGE
*
*       SET UP TASKS
*
*       ADD TIMEOUT TASK AND USER TASK TO END OF TASK QUEUE
*
        ;LDD    CODE+SDOS:CONFIGURATION    COMPUTE POINTER TO "CNFG:TASKQUEUE"
        LDAB      CODE+SDOS:CONFIGURATION+1
        LDAA      CODE+SDOS:CONFIGURATION
        ;ADDD    #CNFG:TASKQUEUE
        ADDB      #(CNFG:TASKQUEUE)&$FF
        ADCA       #(CNFG:TASKQUEUE)/256
        ;TDX
        STAA      TEMPA
        STAB      TEMPB
        LDX     TEMPX
SDOSINITTCB1      ; FIND END OF TASK QUEUE SO WE CAN TACK ON SDOS TASKS
        STX     TEMPX   IN CASE THIS TCB IS THE LAST IN THE QUEUE
        ;LDX    TCB:LNK,X FOLLOW LINK TO NEXT TCB
        LDX     TCB:LNK,X
        BNE      SDOSINITTCB1      B/ NO, CHARGE!
        ;LDX    TEMPX   THIS GUY IS LAST IN QUEUE
        LDX     TEMPX
        ;LDD    #TIMEOUTTASKTCB    MAKE HIM POINT TO SDOS'S TWO TASKS
        LDAB      #(TIMEOUTTASKTCB)&$FF
        LDAA      #(TIMEOUTTASKTCB)/256
        ;STD    TCB:LNK,X
        STAB      (TCB:LNK)+1,X
        STAA      TCB:LNK,X
        ;LDX    CODE+SDOS:CONFIGURATION    INITIALIZE THE TASK CONTROL BLOCKS
        LDX     CODE+SDOS:CONFIGURATION
        ;LDX    CNFG:TASKQUEUE,X  GET POINTER TO FIRST TCB IN LIST
        LDX     CNFG:TASKQUEUE,X
SDOSINITTCBL      ; MARK TASK AS "EXECUTING"
        ;LDD    #EXECUTING
        LDAB      #(EXECUTING)&$FF
        LDAA      #(EXECUTING)/256
        ;STD    TCB:COND,X
        STAB      (TCB:COND)+1,X
        STAA      TCB:COND,X
        ;LDX    TCB:LNK,X FIND NEXT TASK
        LDX     TCB:LNK,X
        BNE      SDOSINITTCBL      B/ MORE TASKS TO MARK
        ;LDX    CODE+SDOS:CONFIGURATION    LET I/O PACKAGE SET UP ITS END OF INTERRUPT SYSTEM
        LDX     CODE+SDOS:CONFIGURATION
        ;JSR    [CNFG:INTSETUP,X]        THIS MUST BE LAST SO I/O PACK CAN TACK...
        LDX     CNFG:INTSETUP,X
        JSR     0,X
*       LOW PRIORITY TIMEOUT TASK ON TASK QUEUE
        ;LDX    #FORCESCHEDULE    TRIGGER INTERRRUPT
        LDX     #FORCESCHEDULE
        ;JSR    CODE+SDOS:STARTIO TO CAUSE ALL TASKS TO START RUNNING
        JSR     CODE+SDOS:STARTIO
*       INTERRUPTS ARE ON WHEN WE RETURN!
*
*       RESET THE I/O CONTROL BLOCKS
*
        ;JSR    INITIOCBS SO THEY ALL APPEAR TO BE CLOSED
        JSR     INITIOCBS
*
*       MAKE THE LOG AND THE SYS CHANNEL FREE
*
        ;LDX    #0
        LDX     #0
        STX     LOGIOCB+IOCB:DRIVER
        STX     SYSIOCB+IOCB:DRIVER
        PAGE
*
*       DOUBLE-CHECK CHECKSUM COMPUTED BY SDOSINIT
*       IF WRONG, ASSUME WE'VE BEEN TAMPERED WITH, AND GET EVEN!
*
        ;LDX    #SDOSINIT-26    NO POINT IN MAKING THIS OBVIOUS...
        LDX     #SDOSINIT-26
        CLRB              ZERO A CHECKSUM REGISTER
SDOSINITDBLCHECKL
        INX             DO THIS OUT OF ORDER TO MAKE CODE HARD TO RECOGNIZE
        ASLB
        ADCB       #0      DON'T DO "ADCB n,X" CAUSE THAT'S EASY TO FIND...
        ADDB      25,X    AND THIS HAS THE SAME EFFECT ANYWAY!
        CPX      #SDOSINITEND-25-1       DONE CHECKSUMMING?
        BNE      SDOSINITDBLCHECKL  B/ NO
        STS     TEMPX   NOW ADD (B) TO (S)...
        ADDB      TEMPX+1 (S) WON'T CHANGE IF CHECKSUM IS CORRECT (ZERO!)
        ;STB     TEMPX+1 OTHERWISE, IT WILL CHANGE BY SOME AMOUNT...
        STAB      TEMPX+1
        NOP	;ZZZ LDS     TEMPX   THAT WILL CAUSE "RTS" BELOW TO BLOW UP!
        NOP
        ;JSR    OPENCONSOLE      OPEN UP CHANNEL 0 TO THE CONSOLE
        JSR     OPENCONSOLE
        ;LDX    #EXITCOPYRIGHT   THEN SAY "HELLO!"
        LDX     #EXITCOPYRIGHT
        ;JSR    SYSCALLENTRY
        JSR     SYSCALLENTRY
*
*       PRINT DISK IDENTIFICATION
*
        ;LDX    DEFAULTDISKDCB     SET UP TO READ LSN 0 ON DRIVE 0
        LDX     DEFAULTDISKDCB
        STX     SYSSECTORDB+SECTORDB:DISKINFO
        ;LDX    #SYSSECTORDB      MAKE A ZEROED LSN
        LDX     #SYSSECTORDB
        ;CLR     SECTORDB:LSN,X
        CLR      SECTORDB:LSN,X
        ;CLR     SECTORDB:LSN+1,X
        CLR      SECTORDB:LSN+1,X
        ;CLR     SECTORDB:LSN+2,X
        CLR      SECTORDB:LSN+2,X
        ;JSR    READSECTOR        GO READ SECTOR ZERO
        JSR     READSECTOR
        ;LDX    RDSI:SECTORBASE,X  GET BASE OF SECTOR BUFFER
        LDX     RDSI:SECTORBASE,X
        LDAA      #BOOT:DISKID     FIND BEGINNING OF DISK ID MESSAGE
SDOSINIT2       EQU     *
        INX
        DECA
        BNE      SDOSINIT2       = BASE OF SECTOR + BOOT:DISKID
        STX     SDOSINITID+WRITEA:BUFFERP SAVE POINTER TO STRING
        ;JSR    WAITRDSI ...
        JSR     WAITRDSI
        ;LDX    RDSI:SECTORBASE,X  GET POINTER TO SECTOR ZERO BUFFER
        LDX     RDSI:SECTORBASE,X
        LDAA      BOOT:CREATIONDATE+1,X       DISPLAY CREATION DATE
        ;JSR    BCDTOASCII  CONVERT BCD DIGITS TO ASCII IN (A,B)
        JSR     BCDTOASCII
        ;STD    INITDATE STORE DAY INTO INITIALIZED DATE STRING
        STAB      INITDATE+1
        STAA      INITDATE
        LDAA      BOOT:CREATIONDATE+2,X       CONVERT YEAR
        ;JSR    BCDTOASCII
        JSR     BCDTOASCII
        ;STD    INITDATE+6
        STAB      INITDATE+6+1
        STAA      INITDATE+6
        LDAA      BOOT:CREATIONDATE,X GET BCD EQUIVALENT OF CREATION DATE
        ;JSR    BCDTOASCII
        JSR     BCDTOASCII
        ;STD    INITDATE+3
        STAB      INITDATE+3+1
        STAA      INITDATE+3
        ;LDX    #DISPLAYINITDATE
        LDX     #DISPLAYINITDATE
        ;JSR    SYSCALLENTRY      DISPLAY DATE THE DISK WAS INITIALIZED
        JSR     SYSCALLENTRY
        ;LDX    #SDOSINITID     AND GO PRINT THE DISK ID
        LDX     #SDOSINITID
        ;JSR    SYSCALLENTRY
        JSR     SYSCALLENTRY
        ;JSR    EXITCR   AND PRINT A TERMINATING "CR"
        JSR     EXITCR
        OKRTS           ALL DONE!
        PAGE
*
*       BCDTOASCII -- CONVERT BCD DIGIT PAIR IN (A)...
*               INTO ITS CONSTITUENT ASCII DIGITS IN (A,B)
*
BCDTOASCII  EQU     *
        TAB
        LSRA
        LSRA
        LSRA
        LSRA
        ANDB      #$F
        ;ADDD    #'0*256+'0
        ADDB      #('0*256+'0)&$FF
        ADCA       #('0*256+'0)/256
        RTS
*
*       DSKFRESET -- DISK FILE DRIVER RESET
*
DSKFRESET       EQU     *
        ;JSR    INITDISKINFO    SET UP ALL THE TABLES
        JSR     INITDISKINFO
        ;JSR    INITFCBS
        JSR     INITFCBS
        ;JSR    INITRDSI
        JSR     INITRDSI
        OKRTS
        PAGE
*
*       INITRDSI -- SETS UP RESIDENT DISK SECTOR INFO TABLE
*               ALLOCATES FROM CNFG:FREESPACE IN FOLLOWING WAY
*               1)  FIND FIRST WORD IN FREESPACE WHICH IS ON A SECTOR BOUNDARY
*               2)  COUNT # RDSIS ALLOCATABLE BELOW THAT
*               3)  COUNT # SECTOR BUFFERS ALLOCATABLE FROM FREESPACE REMAINING
*               4)  COUNT # RDSIS ALLOCATABLE FROM REMAINDER
*               5)  IF # RDSIS<# SECTOR BUFFS, USE A SECTOR BUFF FOR MORE RDSIS
*               6)  LOOP ON 5 UNTIL # RDSIS>=#SECTOR BUFFERS
*               7)  ALLOCATE RDSIS
*               8)  ALLOCATE SECTORS AS A LUMP
*               9)  ALLOCATE REST OF RDSIS
*               10) DISTRIBUTE SECTOR BUFFERS TO RDSIS
*               11) DONE
*
INITRDSI        EQU     *
* 1)  FIND FIRST WORD IN FREESPACE THAT CAN BE A SECTOR BOUNDARY
        ;LDX    CODE+SDOS:CONFIGURATION
        LDX     CODE+SDOS:CONFIGURATION
        ;LDD    CNFG:DSKBUFFERPOOL,X      FIND 1ST POWER OF 2 BOUNDARY
        LDAB      (CNFG:DSKBUFFERPOOL)+1,X
        LDAA      CNFG:DSKBUFFERPOOL,X
*       WHICH IS A MULTIPLE OF CNFG:SECSIZE
        ;ADDD    MAXSECTORSIZE
        ADDB      MAXSECTORSIZE+1
        ADCA       MAXSECTORSIZE
        ;SUBD    #1      ROUND UP TO NEXT BOUNDARY
        SUBB      #(1)&$FF
        SBCA       #(1)/256
        ;PSHD           SAVE POINTER INTO 1ST SECTOR BUFFER
        PSHB
        PSHA
        ;LDD    MAXSECTORSIZE     MAKE A BOUNDARY MASK
        LDAB      MAXSECTORSIZE+1
        LDAA      MAXSECTORSIZE
        ;SUBD    #1
        SUBB      #(1)&$FF
        SBCA       #(1)/256
        ;COMD
        COMB
        COMA
        ;ANDD    0,S     MASK TO OBTAIN FIRST SECTOR BOUNDARY
        TSX
        ANDB      (0)+1,X
        ANDA      0,X
        ;LEAS    2,S
        IF      2<0
        RPT     -2
        DES
        ELSE
        RPT     2
        INS
        FIN
        ;STD    FIRSTBUF
        STAB      FIRSTBUF+1
        STAA      FIRSTBUF
* 2) COUNT # RDSI'S ALLOCATABLE
        ;LDX    CODE+SDOS:CONFIGURATION
        LDX     CODE+SDOS:CONFIGURATION
        ;SUBD    CNFG:DSKBUFFERPOOL,X      COMPUTE # WORDS BETWEEN
        SUBB      (CNFG:DSKBUFFERPOOL)+1,X
        SBCA       CNFG:DSKBUFFERPOOL,X
        ;CMPD    CNFG:DSKPOOLSIZE,X       FIRST WORD OF FS AND FIRSTBUF
        CMPA      CNFG:DSKPOOLSIZE,X
        BNE      MACRO:0007
        CMPB      (CNFG:DSKPOOLSIZE)+1,X
MACRO:0007
        BHI      ERRNOTENOUGHPOOL        B/ >, ILLEGAL SPACE ALLOCATION
INITRDSI1       EQU     *
        ;STD    FIRSTSEGSIZE    SAVE 1ST SEGMENT SIZE
        STAB      FIRSTSEGSIZE+1
        STAA      FIRSTSEGSIZE
        ;CLR     NRDSIS  NRDSIS := 0
        CLR      NRDSIS
INITRDSI2       EQU     *
        ;INC     NRDSIS  ROOM FOR ONE MORE RDSI
        INC      NRDSIS
        BEQ      INITRDSI2A       B/ QUIT IF 255 RDSI'S AVAILABLE
        ;SUBD    #RDSI:SIZE
        SUBB      #(RDSI:SIZE)&$FF
        SBCA       #(RDSI:SIZE)/256
        BCC        INITRDSI2       B/ MORE SPACE AVAILABLE
INITRDSI2A       EQU     *
        ;DEC     NRDSIS  = ACTUAL # RDSI'S AVAILABLE SO FAR
        DEC      NRDSIS
* 3) COUNT # POTENTIAL SECTOR BUFFERS
        ;LDX    CODE+SDOS:CONFIGURATION
        LDX     CODE+SDOS:CONFIGURATION
        ;LDD    CNFG:DSKPOOLSIZE,X       ALL OF FREE SPACE - SIZE OF 1ST SEGMENT
        LDAB      (CNFG:DSKPOOLSIZE)+1,X
        LDAA      CNFG:DSKPOOLSIZE,X
        ;SUBD    FIRSTSEGSIZE
        SUBB      FIRSTSEGSIZE+1
        SBCA       FIRSTSEGSIZE
        ;CLR     NBUFFERS ASSUME 0 SECTOR BUFFERS AVAILABLE
        CLR      NBUFFERS
INITRDSI3       EQU     *
        ;INC     NBUFFERS COUNT A BUFFER
        INC      NBUFFERS
        BEQ      INITRDSI3A       B/ QUIT IF 255 BUFFERS AVAILABLE
        ;SUBD    MAXSECTORSIZE
        SUBB      MAXSECTORSIZE+1
        SBCA       MAXSECTORSIZE
        BCC        INITRDSI3       B/ MORE ROOM STILL
INITRDSI3A       EQU     *
        ;DEC     NBUFFERS = ACTUAL NUMBER OF BUFFERS AVAILABLE
        DEC      NBUFFERS
        BEQ      ERRNOTENOUGHPOOL        B/ NO BUFFERS AVAILABLE!
* 4) COUNT # RDSI'S AVAILABLE FROM REMAINDER
INITRDSI4L      EQU     *
        ;ADDD    MAXSECTORSIZE
        ADDB      MAXSECTORSIZE+1
        ADCA       MAXSECTORSIZE
INITRDSI4       EQU     *
        ;INC     NRDSIS  BUMP # RDSI'S AVAILABLE
        INC      NRDSIS
        BEQ      INITRDSI4A       B/ AT LEAST 255 AVAILABLE
        ;SUBD    #RDSI:SIZE
        SUBB      #(RDSI:SIZE)&$FF
        SBCA       #(RDSI:SIZE)/256
        BCC        INITRDSI4       B/ MORE SPACE!
        ;ADDD    #RDSI:SIZE      (A,B):= NUMBER OF BYTES LEFT OVER
        ADDB      #(RDSI:SIZE)&$FF
        ADCA       #(RDSI:SIZE)/256
INITRDSI4A       EQU     *
        ;DEC     NRDSIS  = ACTUAL # RDSI'S AVAILABLE
        DEC      NRDSIS
* 5) CHECK TO MAKE SURE # RDSI'S >= # SECTOR BUFFERS
        PSHA             SAVE (A)
        LDAA      NRDSIS
        ;CMPA     NBUFFERS
        CMPA      NBUFFERS
        PULA             RESTORE (A)
        BCC        INITRDSI7       B/ NRDSIS >= NBUFFERS
INITRDSI6       ; NRDSIS < NBUFFERS
        ;DEC     NBUFFERS THROW AWAY A BUFFER
        DEC      NBUFFERS
        BNE      INITRDSI4L      USE THROWN AWAY BUFFER AS SPACE FOR RDSI'S
ERRNOTENOUGHPOOL        EQU     *
        ;JSR    ERRET
        JSR     ERRET
        FDB      ERR:NOTENOUGHPOOL

INITRDSI7       ; NRDSIS >= NBUFFERS, USE NBUFFERS
        LDAA      NBUFFERS
        STAA      NRDSIS
        ;CMPA     #1      ENOUGH RDSIS TO MAKE SDOS RUN?
        CMPA      #1
        BLS      ERRNOTENOUGHPOOL        B/ NOPE, MUST BE AT LEAST 2!
        ;LDX    #LASTSECTORREADQ   NOW ALLOCATE RDSI'S FROM FIRST SEGMENT
        LDX     #LASTSECTORREADQ
        STX     LASTSECTORREADQ+RDSI:FLINK MAKE RDSI QUEUE EMPTY
        STX     LASTSECTORREADQ+RDSI:BLINK
        ;LDX    CODE+SDOS:CONFIGURATION
        LDX     CODE+SDOS:CONFIGURATION
        ;LDD    CNFG:DSKBUFFERPOOL,X      GET POINTER TO NEXT POSSIBLE RDSI
        LDAB      (CNFG:DSKBUFFERPOOL)+1,X
        LDAA      CNFG:DSKBUFFERPOOL,X
        BSR      ALLOCRDSIS        GO ALLOCATE SOME RDSI'S
* 8) SKIP OVER SECTOR BUFFERS AS A LUMP
        LDAA      NRDSIS  = # BUFFERS TO SKIP (>=1)
        STAA      COUNT
        ;LDD    FIRSTBUF
        LDAB      FIRSTBUF+1
        LDAA      FIRSTBUF
INITRDSI8       ; SKIP A SECTOR BUFFER
        ;ADDD    MAXSECTORSIZE
        ADDB      MAXSECTORSIZE+1
        ADCA       MAXSECTORSIZE
        ;DEC     COUNT    DOWN COUNT # BUFFERS TO SKIP
        DEC      COUNT
        BNE      INITRDSI8       B/ MORE BUFFERS TO SKIP
        ;LDX    #$FFFF  SET SEGMENT SIZE = "BIGGEST"
        LDX     #$FFFF
        STX     FIRSTSEGSIZE    (A,B) = POINTER TO REST OF RDSI'S
        BSR      ALLOCRDSIS        AND ALLOCATE REST OF RDSI'S
* 9) NOW DISTRIBUTE SECTOR BUFFERS TO RDSI'S
        ;LDX    LASTSECTORREADQ+RDSI:FLINK 1ST RDSI
        LDX     LASTSECTORREADQ+RDSI:FLINK
        ;LDD    FIRSTBUF STORE SECTOR BUFFER ADDRESS
        LDAB      FIRSTBUF+1
        LDAA      FIRSTBUF
INITRDSI9       EQU     *
        ;STD    RDSI:SECTORBASE,X
        STAB      (RDSI:SECTORBASE)+1,X
        STAA      RDSI:SECTORBASE,X
        ;CLR     RDSI:DISKINFO,X SET DRIVE = "SECTOR NOT IN BUFFER"
        CLR      RDSI:DISKINFO,X
        ;CLR     RDSI:DISKINFO+1,X       SO A LDX DETECTS THAT IT IS ZERO!
        CLR      RDSI:DISKINFO+1,X
        STAA      RDSI:LSN+2,X    MAKE LSN <> 0 SO IT IS NOT THE MAGIC "0" SECTOR!!
        ;CLR     RDSI:MODIFIED,X TAG "SECTOR NOT MODIFIED"
        CLR      RDSI:MODIFIED,X
        ;CLR     RDSI:STATE,X     MARK RDSI AS "IDLE"
        CLR      RDSI:STATE,X
* NOTE: RDSI:TRACK is GARBAGE if RDSI:DSKINFO=0
        ;ADDD    MAXSECTORSIZE     FIND NEXT SECTOR BUFFER
        ADDB      MAXSECTORSIZE+1
        ADCA       MAXSECTORSIZE
        ;LDX    RDSI:FLINK,X    FIND NEXT RDSI
        LDX     RDSI:FLINK,X
        CPX      #LASTSECTORREADQ   ALL RDSI'S INITZD?
        BNE      INITRDSI9       B/ NO
        OKRTS           YES, LET'S SPLIT!!
        PAGE
*
*       ALLOCRDSIS -- AND ADD TO LASTSECTORREADQ
*               (A,B) POINTS TO NEXT POSSIBLE RDSI
*               FIRSTSEGSIZE CONTAINS CONTIGUOUS SPACE REMAINING
*               ALLOCATES NO MORE THAN "NRDSIS" RDSI'S
*
ALLOCRDSIS        EQU     *
        ;STD    RDSIPOINTER     SAVE NEXT POTENTIAL RDSI ADDRESS
        STAB      RDSIPOINTER+1
        STAA      RDSIPOINTER
        ;LDD    FIRSTSEGSIZE    GET SIZE OF REMAINING SEGMENT
        LDAB      FIRSTSEGSIZE+1
        LDAA      FIRSTSEGSIZE
        ;SUBD    #RDSI:SIZE      ENOUGH SPACE LEFT TO ALLOCATE?
        SUBB      #(RDSI:SIZE)&$FF
        SBCA       #(RDSI:SIZE)/256
        BCS       ALLOCRDSISRTS     B/ NOT ENOUGH ROOM LEFT
        ;STD    FIRSTSEGSIZE
        STAB      FIRSTSEGSIZE+1
        STAA      FIRSTSEGSIZE
        LDAA      NBUFFERS GET # RDSI'S TO ALLOCATE
        BEQ      ALLOCRDSISRTS     B/ DON'T ALLOCATE ANY MORE
        ;DEC     NBUFFERS = ONE PER BUFFER
        DEC      NBUFFERS
        ;LDX    RDSIPOINTER     GET POINTER TO RDSI TO ALLOCATE
        LDX     RDSIPOINTER
        ;JSR    ENQUELASTSECTORREAD        ADD TO LASTSECTORREADQ
        JSR     ENQUELASTSECTORREAD
        ;LDD    #RDSI:SIZE      FIND NEXT RDSI
        LDAB      #(RDSI:SIZE)&$FF
        LDAA      #(RDSI:SIZE)/256
        ;ADDD    RDSIPOINTER
        ADDB      RDSIPOINTER+1
        ADCA       RDSIPOINTER
        BRA       ALLOCRDSIS        GO ALLOCATE ANOTHER

ALLOCRDSISRTS     EQU     *
        RTS
        PAGE
*
*       INITFCBS -- COMPUTES NUMBER OF FCBS AND STORES IN NFCBS
*               THEN SCANS ALL FCBS ZEROING FCB:REFCOUNT
*
INITFCBS  EQU     *
        ;LDX    CODE+SDOS:CONFIGURATION    COMPUTE # OF FCBS...
        LDX     CODE+SDOS:CONFIGURATION
        LDAA      CNFG:NIOCHANNELS,X = 1 PER I/O CHANNEL
        ADDA      NDRIVES +2 PER DISK DRIVE
        ADDA      NDRIVES
        ADDA      #NMAGICFCBS + ODDBALL ASSORTMENT
        STAA      NFCBS     FOR USE BY FINDFREEFCBS, SEARCHFCBS
        STAA      COUNT    SO WE KNOW HOW MANY TO ZAP
        ;LDD    [CNFG:IOCBPOINTERS,X] GET ADDRESS OF 1ST IOCB
        LDX     CNFG:IOCBPOINTERS,X
        LDAB      1,X
        LDAA      0,X
INITFCBL  EQU     *
        ;SUBD    #FCB:SIZE FIND PREVIOUS FCB = THIS FCB - SIZE OF FCB
        SUBB      #(FCB:SIZE)&$FF
        SBCA       #(FCB:SIZE)/256
        ;TDX            COPY ADDRESS TO (X)
        STAA      TEMPA
        STAB      TEMPB
        LDX     TEMPX
        ;CLR     FCB:REFCOUNT,X     ZAP THE REFERENCE COUNT
        CLR      FCB:REFCOUNT,X
        ;DEC     COUNT
        DEC      COUNT
        BNE      INITFCBL  B/ MORE TO INIT
        ;LDX    #0      RESET POINTER TO ERROR MESSAGE FCB
        LDX     #0
        STX     ERRFCBPOINTER
        RTS
        PAGE
*
*       INITDISKINFO -- INITIALIZES ALL DISKINFO TABLES TO "DISMOUNTED"
*       COMPUTE MAXSECTORSIZE = MAX OF ALL SECTOR SIZES
*       COUNT # DRIVES
*
INITDISKINFO    EQU     *
        ;LDX    #0      ZERO MAX SECTOR SIZE FOUND SO FAR
        LDX     #0
        STX     MAXSECTORSIZE
        ;CLR     NDRIVES ASSUME NO DISK DRIVES IN THIS SYSTEM (A LITTE FUNNY)
        CLR      NDRIVES
        ;LDX    CODE+SDOS:CONFIGURATION    FIND ADDRESS OF 1ST DISKINFO TABLE
        LDX     CODE+SDOS:CONFIGURATION
        ;LDX    CNFG:DISKDCBS,X
        LDX     CNFG:DISKDCBS,X
        STX     DEFAULTDISKDCB     SO WE KNOW WHICH DISK TO DEFAULT TO
INITDISKINFOL   EQU     *
        STX     DCBPOINTER        SAVE THIS A MOMENT
        ;INC     NDRIVES COUNT # DISKINFO TABLES (NOT TO EXCEED 255)
        INC      NDRIVES
        ;CLR     DSKINFO:DIRFCB,X  MARK "NO DIRFCB SET UP" (DISMOUNTED)
        CLR      DSKINFO:DIRFCB,X
        ;CLR     DSKINFO:DIRFCB+1,X
        CLR      DSKINFO:DIRFCB+1,X
        ;CLR     DSKINFO:MAPFCB,X   DITCH MAP FCB...
        CLR      DSKINFO:MAPFCB,X
        ;CLR     DSKINFO:MAPFCB+1,X
        CLR      DSKINFO:MAPFCB+1,X
        ;CLR     DSKINFO:SECTORDB,X        MARK THIS DRIVE AS "NOT DOING ANY I/O"
        CLR      DSKINFO:SECTORDB,X
        ;CLR     DSKINFO:SECTORDB+1,X
        CLR      DSKINFO:SECTORDB+1,X
        LDAA      #-1     SET BAD LSN TO "NO BAD LSN"
        STAA      DSKINFO:BADLSN,X
        STAA      DSKINFO:BADLSN+1,X
        STAA      DSKINFO:BADLSN+2,X
        STAA      DSKINFO:ERRLSN,X        RESET LAST ERRORING LSN, TOO!
        STAA      DSKINFO:ERRLSN+1,X
        STAA      DSKINFO:ERRLSN+2,X
        ;LDD    DSKINFO:NBPS,X   COMPARE SECTOR SIZE FOR THIS DISK...
        LDAB      (DSKINFO:NBPS)+1,X
        LDAA      DSKINFO:NBPS,X
        ;CMPD    MAXSECTORSIZE     TO BIGGEST SECTOR SIZE FOUND SO FAR
        CMPA      MAXSECTORSIZE
        BNE      MACRO:0008
        CMPB      MAXSECTORSIZE+1
MACRO:0008
        BCS       INITDISKINFO2   B/ SMALLER
        ;STD    MAXSECTORSIZE     KEEP BIGGEST SECTOR SIZE FOUND SO FAR
        STAB      MAXSECTORSIZE+1
        STAA      MAXSECTORSIZE
INITDISKINFO2   EQU     *
        ;CLR     DSKINFO:LOG2NBPS,X       NOW COMPUTE LOG(2) OF NBPS
        CLR      DSKINFO:LOG2NBPS,X
        ;DEC     DSKINFO:LOG2NBPS,X       (INIT TO -1)
        DEC      DSKINFO:LOG2NBPS,X
INITDISKINFO2L  EQU     *
        ;INC     DSKINFO:LOG2NBPS,X       LOG2 = LOG2 + 1
        INC      DSKINFO:LOG2NBPS,X
        ;LSRD           DIVIDE SECTOR SIZE BY POWER OF TWO
        LSRA
        RORB
        BCC        INITDISKINFO2L  B/ STILL >= 1, KEEP COUNTING!
        ;TSTD           ALL SIGNIFICANCE SHOULD BE SHIFTED OUT
        TSTA
        ;BNED    ERRSECTORSIZE2   B/ SECTOR SIZE NOT A POWER OF 2!
        BNE      ERRSECTORSIZE2
        TSTB
        BNE      ERRSECTORSIZE2
        ;LDD    DSKINFO:NBPS,X   SET DSKINFO:NBPSM1 := DSKINFO:NBPS-1
        LDAB      (DSKINFO:NBPS)+1,X
        LDAA      DSKINFO:NBPS,X
        ;SUBD    #1      FOR EVERYONE ELSE'S CONVENIENCE
        SUBB      #(1)&$FF
        SBCA       #(1)/256
        ;STD    DSKINFO:NBPSM1,X
        STAB      (DSKINFO:NBPSM1)+1,X
        STAA      DSKINFO:NBPSM1,X
*
*       NOW COMPUTE NLSN = (NSPT*NTPC*NCYL)
*
        ;LDD    DSKINFO:NCYL,X   SET NLSN:=NCYL
        LDAB      (DSKINFO:NCYL)+1,X
        LDAA      DSKINFO:NCYL,X
        ;CLR     DSKINFO:NLSN,X
        CLR      DSKINFO:NLSN,X
        ;STD    DSKINFO:NLSN+1,X
        STAB      (DSKINFO:NLSN+1)+1,X
        STAA      DSKINFO:NLSN+1,X
        ;LDD    DSKINFO:NTPC,X   THEN SET NLSN:=NLSN*NTPC
        LDAB      (DSKINFO:NTPC)+1,X
        LDAA      DSKINFO:NTPC,X
        BSR      MULNLSNBYAB
        ;LDD    DSKINFO:NSPT,X  AND THEN SET NLSN:=NLSN*NSPT
        LDAB      (DSKINFO:NSPT)+1,X
        LDAA      DSKINFO:NSPT,X
        BSR      MULNLSNBYAB
*
*       NOW RESET THE DISK DEVICE
*
        ;LDX    DCB:DRIVER,X      CALL THE DISK DRIVER RESET ROUTINE
        LDX     DCB:DRIVER,X
        ;LDD    DRIVER:DISKRESET,X
        LDAB      (DRIVER:DISKRESET)+1,X
        LDAA      DRIVER:DISKRESET,X
        ;JSR    SECTORDRIVER     WHICH SETS (X) = DCBPOINTER
        JSR     SECTORDRIVER
        BCS       INITDISKERRED   B/ OOPS...
        ;LDX    DCBPOINTER        NOW FIND NEXT DISK INFO TABLE
        LDX     DCBPOINTER
        ;LDX    DCB:NEXTDCB,X
        LDX     DCB:NEXTDCB,X
        BNE      INITDISKINFOL
        OKRTS

INITDISKERRED   EQU     *
        ;JMP    ERRORINX
        JMP     ERRORINX
        PAGE
ERRSECTORSIZE2   EQU     *
        ;JSR    ERRET
        JSR     ERRET
        FDB      ERR:SECTORSIZE2  SECTOR SIZE IS NOT A POWER OF 2!
*
*       MULNLSNBYAB -- MULTIPLY DSKINFO:NLSN BY (A,B)
*       (X) POINTS TO DCB FOR DISK; (X) IS PRESERVED
*       PLACES PRODUCT IN DSKINFO:NLSN
*       OKRET IF PRODUCT < 2^24
*       ERRET IF PRODUCT >= 2^24
*
********* SHOULD THIS BE DONE USING "MUL" INSTRUCTION???
*
MULNLSNBYAB        EQU     *
        ;STD    TEMP.MPCND       SAVE MULTIPLICAND
        STAB      TEMP.MPCND+1
        STAA      TEMP.MPCND
        LDAA      #25     # MULTIPLIER BITS (THE 25TH BIT IS GAURANTEED = 0)
        STAA      COUNT    SET UP LOOP COUNT
        CLRA              ZERO THE PARTIAL PRODUCT
        CLRB              AND THE CARRY OUT OF THE PARTIAL PRODUCT
MULNLSNBYABL       ; PROCESS NEXT MULTIPLIER BIT
        ;RORD           PRESERVE CARRY OUT OF PARTIAL PRODUCT
        RORA
        RORB
*                       RIGHT SHIFT PARTIAL PRODUCT...
        ROR     DSKINFO:NLSN,X  INTO MULTIPLIER
        ROR     DSKINFO:NLSN+1,X
        ROR     DSKINFO:NLSN+2,X        AND SHIFT OUT MULTIPLIER BIT
        BCC        MULNLSNBYAB1       B/ DON'T ADD (SET CARRY OUT OF PARTIAL PRODUCT TO 0)
        ;ADDD    TEMP.MPCND       ADD MULTIPLICAND TO PARTIAL PRODUCT
        ADDB      TEMP.MPCND+1
        ADCA       TEMP.MPCND
MULNLSNBYAB1       EQU     *
        ;DEC     COUNT    DOWN COUNT # MULTIPLIER BITS
        DEC      COUNT
        BNE      MULNLSNBYABL       B/ MORE MULTIPLIER BITS TO PROCESS
        BCS       ERRNLSNGE224    B/ PRODUCT >= 2^24
        ;TSTD           UPPER 2 BYTES OF 5 BYTE PRODUCT <> 0 ?
        TSTA
        ;BNED    ERRNLSNGE224    B/ YES, PRODUCT TOO BIG
        BNE      ERRNLSNGE224
        TSTB
        BNE      ERRNLSNGE224
        OKRTS

ERRNLSNGE224    EQU     *
        ;JSR    ERRET
        JSR     ERRET
        FDB      ERR:NLSNGE224
        PAGE
*
*       INITIOCBS -- SETS UP IOCBS FOR USE BY DISKFILE DRIVERS,
*               DISKDEVICEDRIVERS
*
INITIOCBS EQU     *
        ;LDX    CODE+SDOS:CONFIGURATION    SCAN ALL THE IOCBS
        LDX     CODE+SDOS:CONFIGURATION
        LDAA      CNFG:NIOCHANNELS,X
        STAA      INITCOUNTER
        ;LDX    CNFG:IOCBPOINTERS,X
        LDX     CNFG:IOCBPOINTERS,X
INITIOCBL ; INIT NEXT IOCB
        STX     INITX
        ;LDX    ,X      GET IOCB ADDRESS
        LDX     0,X
        BSR      INITIOCB  DUH
        ;LDX    INITX   FIND NEXT IOCB POINTER
        LDX     INITX
        ;LEAX    2,X
        IF      2<0
        RPT     -2
        DEX
        ELSE
        RPT     2
        INX
        FIN
        ;DEC     INITCOUNTER
        DEC      INITCOUNTER
        BNE      INITIOCBL B/ MORE IOCBS
        ;LDX    #SYSIOCB  INIT THE SYSTEM IOCB
        LDX     #SYSIOCB
        BSR      INITIOCB
        ;LDX    #LOGIOCB  INIT THE LOG FILE IOCB
        LDX     #LOGIOCB
        BSR      INITIOCB
        OKRTS           AND EXIT
*
*       INITIOCB -- RESET IOCB(X)
*
INITIOCB  EQU     *
        ;CLR     IOCB:DRIVER,X
        CLR      IOCB:DRIVER,X
        ;CLR     IOCB:DRIVER+1,X
        CLR      IOCB:DRIVER+1,X
        RTS
        page
*
*       TimeoutTask Initialization
*
ExitScanPtr     Equ     2       Pointer used to Scan Exit code for checking
ExitPartialChksum        Equ     4       Partially computed checksum

TimeouttaskSetup        ; Timeout Task initializing code
        ;Clr     ExitPartialChksum        zero initial value of checksum
        CLR      ExitPartialChksum
        ;Ldx    #Exitchksumbase-15      don't make base of checksum obvious
        LDX     #Exitchksumbase-15
        Stx     Exitscanptr
        ;Jmp    Timeouttaskbored
        JMP     Timeouttaskbored

SDOSINITEND     ; END OF SDOSINIT CHECKSUMMED CODE
        page
*       The following routine is used by SD personnel after SDOS is assembled or patched...
*       to compute the various checksum values required to make SDOS operate.
*       Control is transferred here (instead of to SDOSINIT);
*       the checksum bytes are modified until the correct checksums are obtained
*       (this process presumes that the memory of the computer works!)
*       The values in the checksum bytes must then be patched into SDOS with BMP.
*       The code is a little obscure because we don't want it accidentally found
*
        Fcb     $BF      Red herring for would-be disassemblers
ComputeChecksums; Compute checksums over SDOS
*       Note: Exit Checksum must be computed before MainChecksum!
ComputeExitChecksum ; loop back here until SDOSEXITCHKSUM gives zero
        ;ldx    #EXITCODECHKSUM-51        don't make it obvious where checksum byte is
        LDX     #EXITCODECHKSUM-51
        ;inc    51,x    old value didn't work, try this one!
        INC      51,X
        ;ldx    #EXITCHKSUMBASE-41 don't make it obvious where checksum byte is
        LDX     #EXITCHKSUMBASE-41
        clrb            zero the checksum accumulator
ComputeExitChecksuml      ; loop here to checksum a byte
        aslb            make checksum depend on order of the data
        adcb    41,x
        inx
        cpx     #EXITCHKSUMEND-41        done?
        bne     ComputeExitChecksuml      b/ no
        negb            did we get proper checksum?
        bne     ComputeExitChecksum
ComputeMainChecksum ; loop back here until main SDOS checksum gives zero
        ;ldx    #SDOSCODECHKSUM-49        don't make it obvious where checksum byte is
        LDX     #SDOSCODECHKSUM-49
        ;inc    49,x    old value didn't work, try this one!
        INC      49,X
        ;ldx    #SDOSCHKSUMBASE-7  where to start checksumming over SDOS
        LDX     #SDOSCHKSUMBASE-7
        clrb            zero the checksum accumulator
ComputeMainChecksuml ; loop here to checksum a byte
        aslb            make checksum depend on order of the data
        adcb    7,x
        inx
        cpx     #SDOS:END-7
        bne     ComputeMainChecksuml      b/ more bytes to checksum
        addb    #0      did checksum come up zero?
        bne     ComputeMainChecksum       b/ no, try a new value!
        page
ComputeInitChecksum ; loop back here until SDOSINIT checksum gives zero
        ;ldx    #SDOSINITCKSUM-22        don't make it obvious where checksum byte is
        LDX     #SDOSINITCKSUM-22
        ;inc    22,x    old value didn't work, try this one!
        INC      22,X
        ;ldx    #SDOSINIT-75    don't make it obvious where checksum byte is
        LDX     #SDOSINIT-75
        clrb            zero the checksum accumulator
ComputeInitChecksuml      ; loop here to checksum a byte
        aslb            make checksum depend on order of the data
        inx             do this one first to be confusing!
        adcb    74,x
        cpx     #SDOSINITEND-74-1       done?
        bne     ComputeInitChecksuml      b/ no
        negb            did we get proper checksum?
        bne     ComputeInitChecksum
        rti             if you let it get here, you don't know what you're doing...
        PAGE
*
*       STORAGE USED ONLY BY INITIALIZATION ROUTINES
*
FIRSTBUF RMB      2       POINTER TO 1ST SECTOR BUFFER
FIRSTSEGSIZE    RMB      2       SIZE OF 1ST REGION FROM WHICH TO ALLOCATE RDSI'S
NBUFFERS RMB      1       # OF SECTOR BUFFERS AVAILABLE
INITCOUNTER      RMB      1
INITX   RMB      2
*
EXITCOPYRIGHT    ; USED TO DISPLAY SDOS BANNER, COPYRIGHT MESSAGE
        FCB       SYSCALL:WRITEA     FUNCTION
        FCB       WRITEA:SCLEN
        FCB       0       CHANNEL
        RMB      1       ANY GARBAGE
        FDB      SDOSMSG BUFFER ADDRESS
        FDB      COPYRIGHTEND-SDOSMSG     REQUESTED COUNT
*
SDOSINITID      ; USED TO DISPLAY DISK IDENTIFICATION STRING
        FCB       SYSCALL:WRITEA     FUNCTION
        FCB       WRITEA:SCLEN
        FCB       0       CHANNEL
        RMB      1       ANY OLD GARBAGE FOR 2ND PARAMETER BYTE
        RMB      2       POINTER TO ID STRING IN BOOT SECTOR
        FDB      BOOT:SIZE-BOOT:DISKID     LENGTH OF ID STRING
*
DISPLAYINITDATE   ; SYSCALL USED TO DISPLAY DISK INITZ DATE
        FCB       SYSCALL:WRITEA
        FCB       WRITEA:SCLEN
        FCB       0       CHANNEL NUMBER
        RMB      1       ANY GARBAGE BYTE
        FDB      INITDATE STRING TO DISPLAY
        FDB      INITDATELEN      SIZE OF STRING TO DISPLAY

INITDATE FCC       "00/00/00 "
INITDATELEN      EQU     *-INITDATE
        PAGE
CHAINTOSERIALNO.SYS ; SYSTEM CALL TO CHAIN TO SERIALNUMBER.SYS
        FCB       SYSCALL:CHAIN,CHAIN:SCLEN
        FCB       IGNORED,IGNORED
        FDB      SERIALNUMBER.SYS,SERIALNUMBER.SYSL
        FDB      CHANGED
        FDB      SCRATCH,4

SERIALNUMBER.SYS  ;ZZZ 	FCC       "SERIALNUMBER.SYS"
	FCC "DEFAULTPROGRAM  "
SERIALNUMBER.SYSL EQU     *-SERIALNUMBER.SYS

OPENSERIALNO.SYS ; SYSTEM CALL TO OPEN SERIALNUMBER.SYS
        FCB       SYSCALL:OPEN,OPEN:SCLEN
        FCB       1,IGNORED
        FDB      SERIALNUMBER.SYS,SERIALNUMBER.SYSL
        FDB      CHANGED
        FDB      SCRATCH,4

SCRATCH    RMB      4

CLOSESERIALNO.SYS ; SYSTEM CALL TO CLOSE SERIALNUMBER.SYS
        FCB       SYSCALL:CLOSE,CLOSE:SCLEN
        FCB       1

SETINITERROR    ; SYSCALL TO TELL SDOS WHAT ERROR CODE WE WANT DISPLAYED
        FCB       SYSCALL:SETERROR,SETERROR:SCLEN
ERRORCODE        FDB      CHANGED

DisplayInitError        ; Syscall to display error code last set
        Fcb     Syscall:Disperror,Disperror:Sclen

ReadSerialNumberFromFile        ; Syscall to read Serial number from encrypted file
        fcb     Syscall:Readb,RWposition:sclen
        fcb     1,ignored
        fdb     ignored,ignored
        fdb     changed expected value of 8
        fdb     DecryptBuffer,SerialNumber:Size  where to read serial number
        fdb     $0000,$0008     file position to start reading at

ReadSerialNumberFileType ; Syscall to read type of 1st load record of file
        fcb     Syscall:Readb,Readb:Sclen
        fcb     1,ignored
        fdb     ignored,ignored
        fdb     changed expected value of 1
        fdb     DecryptBuffer,1  where to read load record type byte to

seed    rmb     1       self-initializes with garbage

RunningEncryptedp       rmb     2       Pointer to Running Encrypted byte

CopyofNMIVector ; save copy of NMI vector for NMI-vector-not-in-RAM test
        fdb     changed
CopyofRestartVector ; copy of Restart vector for Restart-vector-not-in-RAM test
        fdb     changed

        IF      *>/CODE
        ?SDOS INITIALIZATION CODE OVERLAPS SDOS?
        FIN
        PAGE     --- SDOS FRONT END ---
*       SDOS ENTRY POINTS, AND DATA SHARED WITH I/O PACKAGE
*               (SEE SDOS:XXX DISPLACEMENTS)
*
        ORG     CODE     BASE OF SDOS
        FCB       SDOSVERSION     FOR REFERENCE PURPOSES
LASTERROR        FDB      0       LAST ERROR ENCOUNTERED BY SDOS
        RMB      2       POINTER TO CONFIGURATION LIST
        RMB      2       TO IDENTIFY WHICH USER WE SOLD IT TO
*
*       THIS AREA CONTAINS THE VARIABLES THAT ARE PASSED
*       TO THE DRIVERS
*
        RMB      2       POINTER TO THE I/O CALL BLOCK
IOCBPOINTER       RMB      2       POINTER TO I/O CONTROL BLOCK SPECIFIED BY SYSCALL CHANNEL NUMBER
        RMB      3       CLOCK: 100THS OF A SECOND (0..100*60*60*24)
        RMB      3       CLOCK: DD/MM/YY (BCD)
        FCB       -1      STACKSWITCHED: -1 --> RUNNING UNDER TASK'S STACK
*                       >= 0 --> RUNNING UNDER INTERRUPT STACK
        ;JMP    IOINTERRUPT     IN SIMPLE INTERRRUPT SCHEME, I/O INTERRUPT GOES HERE FIRST
        JMP     IOINTERRUPT
        ;JMP    IORTI   RTI WITHOUT EVENT
        JMP     IORTI
        ;JMP    FORCESCHEDULE     RTI WITH EVENT
        JMP     FORCESCHEDULE
        ;JMP    CLOCKTICKED        ENTRY POINT FOR "CLOCKTICKED" SUBROUTINE
        JMP     CLOCKTICKED
        FDB      USERTASKTCB        POINTER TO CURRENTLY ACTIVE TASK'S CONTROL BLOCK
        FCB       1       0 --> KILLABLE; <>0 --> UNKILLABLE (KILLPROOFFLAG)
*       INITIALLY KILLPROOF TO PREVENT "SDOSINIT" FROM BEING STOPPED
        ;JMP    KILLUSERPROGRAM  ENTRY POINT FOR "KILL USER PROGRAM" SUBROUTINE
        JMP     KILLUSERPROGRAM
        ;JMP    STARTIO$ (TASK) SIMULATE INTERRUPT TO (X)
        JMP     STARTIO$
        ;JMP    WAIT$    (TASK) WAIT FOR CONDITION (A,B)
        JMP     WAIT$
        ;JMP    WAITEVENT$       (TASK) WAIT FOR EVENT (X)
        JMP     WAITEVENT$
        ;JMP    ERRET   ENTRY POINT FOR ERROR SIGNALING ROUTINE
        JMP     ERRET
        ;JMP    ERRORSAVE        ENTRY POINT TO SAVE ERROR CODE IN (X)
        JMP     ERRORSAVE
        ;JMP    ERRORED ENTRY POINT TO SIGNAL "I CAN'T HANDLE THAT ERROR"
        JMP     ERRORED
        ;JMP    CHECKRDLEN        ENTRY POINT FOR "CHECK REPLY DATA LENGTH"
        JMP     CHECKRDLEN
        ;JMP    CHECKWRLEN        ENTRY POINT FOR "CHECK WRITE DATA LENGTH"
        JMP     CHECKWRLEN
        ;JMP    CHECKSCLEN ENTRY POINT FOR "CHECK SYSCALL BLOCK LENGTH"
        JMP     CHECKSCLEN
        ;JMP    TABLEBRANCH  ENTRY POINT FOR "BRANCH THRU TABLE" ROUTINE
        JMP     TABLEBRANCH
        ;JMP    BLOCKMOVE ENTRY POINT FOR "FAST BLOCK MOVE"
        JMP     BLOCKMOVE
        ;JMP    GETRUNNINGENCRYPTED      ENTRY POINT TO GET ADDRESS OF RUNNING ENCRYPTED FLAG
        JMP     GETRUNNINGENCRYPTED
        RMB      SDOS:ENTRYSIZE-(*-CODE)
        PAGE
*       TEMPS FOR SDOS FRONT END
*
STARTADDRESS      RMB      2       EXECUTION START ADDRESS
LOADCOUNT RMB      2       COUNTER FOR LOADER

DEFAULTDISKDCB     RMB      2       POINTER TO DISK INFO TABLE FOR DEFAULT DISK
NAMESCANPTR        RMB      2       USED TO SCAN USER-SUPPLIED DEVICE NAME
NAMESIZE RMB      2       SIZE OF USER-SUPPLIED DEVICE NAME
CONSOLEDRIVER    RMB      2       POINTER TO CONSOLE DEVICE DRIVER (SET UP BY SDOSINIT)
DRIVERVPOINTER  RMB      2       POINTER TO DEVICE DRIVER ENTRY VECTOR
ERRORADDRESS     RMB      2       HOLDS LAST ERROR ADDRESS (CONVENIENCE FOR SYSTEMS PROGRAMMERS)
*
*       CLOCKTICK AND TIMEOUT ROUTINE DATA STORAGE
*
DAYSPERMONTHX    FDB      DAYSPERMONTH&$FF00       USED TO ACCESS DAYS PER MONTH GIVEN MONTH
NTIMEOUTBLKS     FCB       0       SET BY SDOSINIT TO # TIMEOUT BLOCKS
CLOCKTICKEDEVENT   FCB       0       # CLOCK TICKS FOR TIMEOUT TASK TO PROCESS
TIMEOUTLEPTR    RMB      2       TIMEOUT LIST ENTRY POINTER

DELAYBLOCK ; TIMEOUT BLOCK USED BY SYSCALL:DELAY ROUTINE
        FDB      CHANGED   to point to rest of timeout blocks (TIMEOUT:LINK)
        FDB      $FFFF   Timeout:fuse, initialized to 18.2 minutes
        FDB      SDOSNOTREGISTERED       WHERE TO GO IF SECRET DELAY CALL NOT ISSUED!

DELAYCOMPLETE     FCB       0       EVENT MARKING COMPLETION OF DELAY SYSCALL TIMEOUT
        PAGE
*
*       TIMEOUT AND USER TASK STUFF
*
        IF      M6800!M6801
        RMB      MINSTACK-CONTEXTBLOCK:SIZE   STACK SPACE FOR TIMEOUT TASK
TIMEOUTTASKSTKINIT       EQU     *-1      INITIAL VALUE FOR TIMEOUT TASK'S STACK
        FCB       0,IGNORED,IGNORED,IGNORED,IGNORED       ZERO CC SO INTERRUPTS ARE ENABLED
        FDB      TIMEOUTTASKSETUP INITIAL PC OF TIMEOUT TASK
        ELSE    (M6809)
        RMB      MINSTACK-CONTEXTBLOCK:SIZE   STACK SPACE FOR TIMEOUT TASK
TIMEOUTTASKSTKINIT       EQU     *       INITIAL VALUE FOR TIMEOUT TASK'S STACK
        FCB       $80,IGNORED,IGNORED,0   CC WITH INTS ENABLED, GARBAGE (D), (DP) = 0
        FDB      IGNORED GARBAGE (X)
        FDB      IGNORED GARBAGE (Y)
        FDB      IGNORED GARBAGE (U)
        FDB      TIMEOUTTASKSETUP INITIAL PC OF TIMEOUT TASK
        FIN

TIMEOUTTASKTCB     EQU     *
        FDB      USERTASKTCB        TCB:LNK POINTS TO USER TASK
        FDB      TIMEOUTTASKSTKINIT       TCB:STACK INITIAL VALUE
        RMB      TCB:SIZE-(*-TIMEOUTTASKTCB)

USERTASKTCB        ; USER TASK CONTROL BLOCK
        FDB      0       END OF TCB CHAIN
        RMB      TCB:SIZE-(*-USERTASKTCB)
        PAGE     WORKING STORAGE FOR DISK FILE DRIVERS
*
*       VARIABLE STORAGE FOR DISK FILE DRIVER
*
*       SCRATCH PAD VARIABLES (USE TO SHORTEN/SPEED UP INSTRUCTIONS IN SDOS)
*
TOPOINTER       EQU     0       COPY TARGET
FROMPOINTER     EQU     2       COPY SOURCE
COUNT    EQU     4       1 BYTE COUNTER, GP

TEMP.MPCND       EQU     TEMPX   MULTIPLICAND
TEMP.DIVISOR    EQU     TEMPX   DIVISOR
TEMP.QUOTIENT   EQU     0       QUOTIENT (2 BYTES)
TEMP.DIVIDEND   EQU     2       DIVIDEND (2 BYTES)
TEMP.MPR        EQU     5       MULTIPLIER (1 BYTE)
*
*       HIGH RAM SCRATCH AREA
*
WRITEFLAG        RMB      1       0--> READ; 1--> WRITE REQUEST
BUFFERPOINTER    RMB      2       POINTER INTO USER'S BUFFER
TRANSFERCOUNT     RMB      2       # BYTES AVAILABLE TO BE TRANSFERRED FROM SECTOR
USEDCOUNT        RMB      2       # BYTES ACTUALLY TRANSFERRED
COLUMNCOUNT       RMB      1       COLUMN COUNTER
USERIOCBPOINTER   RMB      2       HOLDS REAL IOCBPOINTER DURING A SEARCHDIR
RDSIPOINTER     RMB      2       POINTER TO RDSI OF LAST SECTOR READ
FCBPOINTER        RMB      2       POINTER TO FCB FOR CURRENT IOCB
DIRENTRY        RMB      2       POINTER TO DIRECTORY ENTRY FOUND BY SEARCHDIR
DIRENTRYDISP    RMB      2       DISPLACEMENT FROM SECTORBASE OF DIRENTRY
*
SEARCHNAMEP        RMB      2       POINTER TO 16 BYTE FILENAME TO SEARCH FOR
SEARCHSAVEP        RMB      2       SAVED VALUE OF SEARCHNAMEP
SEARCHSTARTLSN     RMB      LSN:SIZE        STARTING LSN OF DIRECTORY SEARCH
FREEDIRLSN      RMB      LSN:SIZE        LSN OF FREE DIRECTORY SLOT
FREEDIRENTRYDISP        RMB      2       DISPLACEMENT FROM SECTORBASE OF FREE ENTRY
DIRSECTOREND     RMB      2       ADDRESS OF BYTE PAST END OF DIRECTORY SECTOR
*
FILENAMEBUF       RMB      DIR:NAMESIZE     BUFFER TO HOLD PARSED FILENAME
FILENAMEFILL     RMB      2       POINTER USED TO FILL FILENAMEBUF
FILENAMELENGTH   RMB      1       LENGTH OF FILENAME
FILESIZERQSTD   RMB      4       REQUESTED FILE SIZE IN BYTES
FILESIZE2       FCB       0,0,0,CHANGED     TEMP TO HOLD 32 BIT DIGIT
PARSECOUNT        RMB      2       UNUSED LENGTH OF NAME TO BE PARSED
FILEPROT        RMB      1       REQUESTED FILE PROTECTION BITS
*
ALLOCATIONCOUNT     RMB      LCN:SIZE NUMBER OF CLUSTERS TO ALLOCATE TO A FILE
ALLOCATIONPLCN      RMB      LCN:SIZE PREVIOUS LCN ALLOCATED TO FILE
DIVIDEPOINTLCN   RMB      LCN:SIZE DIVIDES $DISKMAP FOR FWD/BKWD SEARCH
SEARCHLCN  RMB      LCN:SIZE LCN OF CURRENT MAP BIT
AVAILABLELCN RMB      LCN:SIZE LCN OF FREE CLUSTER
AVAILABLECOUNT       RMB      LCN:SIZE NUMBER OF FREE CLUSTERS STARTING AT AVAILABLELCN
DESIREDLCN       RMB      LCN:SIZE VALUE OF LCN WHICH WE'D LIKE TO ALLOCATE
LCNGROUPLENGTH   RMB      LCN:SIZE LENGTH OF GROUP OF FREE CLUSTERS WE'RE LOOKING AT
DISKMAPSECTORSTART RMB      2       POINTER TO 1ST BYTE OF $DISKMAP SECTOR
DISKMAPSECTOREND  RMB      2       POINTER TO BYTE PAST END OF $DISKMAP SECTOR
DISKMAPBYTEPOINTER        RMB      2       POINTER TO $DISKMAP BYTE CONTAINING LCN BIT
DISKMAPMASK       RMB      1       MASK REPRESENTING BIT IN BYTE CONTTAINING LCN
*
LASTSECTORREADQ    ; QUEUE OF RDSI'S IN LRU ORDER
        RMB      RDSI:SIZE       ONLY RDSI:FLINK,RDSI:BLINK ARE VALID
*
READFLAG  RMB      1       WHICH ENTRY: INVENTSECTOR OR READSECTOR
READSECTORDBP      RMB      2       POINTER TO SECTORDB BLOCK FOR READSECTOR
REMOVESECTORCNT   RMB      1       IOCB COUNTER FOR REMOVERDSI
REMOVEIOCBPTR     RMB      2       POINTER FOR REMOVERDSI
*
NRDSIS  RMB      1       # RDSI'S ACTUALLY SET UP (255 MAX)
NFCBS     RMB      1       NUMBER OF FCBS TO SEARCH (SEARCHFCBS)
NDRIVES RMB      1       NUMBER OF DISKINFO TABLES
*
ERRFCBPOINTER     FDB      0       POINTER TO ERROR MESSAGE FCB
*       INIT AS ZERO IN CASE OF ERROR DURING INIT PROCESS
MAXSECTORSIZE     RMB      2       SIZE OF LARGEST SECTOR
SYSFCBPOINTER     RMB      2       POINTER TO SPECIAL SYSTEM FCB (USED BY DELETE)
SYSSECTORDB       RMB      SECTORDB:SIZE     SPECIAL SYSTEM SECTORDB
*
LOCATERDCNX        RMB      2       TEMP FOR LOCATERDCN
DCBPTRSAVE RMB      2       SAVED COPY OF DCBPOINTER (USED BY DISKxxx)
*
LOADSYSCALLPTR     RMB      2       POINTER TO LOAD SYSCALL BLOCK
        PAGE     SDOS FRONT END VARIABLE STORAGE
SYSCALLX  FDB      OPCODES&$FF00    USED BY "SYSCALL$" TO JUMP INDEXED ON OPCODE
        ORG     (*+1)/2*2       ENSURES EVEN ADDRESS FOR SDOSSTACK
SDOSSTACK RMB      2       POINTER TO BASE OF STACK USED BY SDOS
        RMB      2       THIS HOLE MUST FOLLOW SDOSSTACK
*                       BECAUSE IT'S USED BY THE COPYRIGHT CHECK
USERSLASTERROR   RMB      2
EXITDAMAGEPTR     FCB       ((EXITDAMAGE-22)/2)&$FF
        FCB       ((EXITDAMAGE-22)/2)/256
DECBUF    RMB      3       CONVERSION BUFFER FOR DISPLAYERROR
ERRORNUMBER      RMB      2       THIS MUST FOLLOW DECBUF
STRINGBUFFER     RMB      6       ASCII BUFFER FOR DISPLAYERROR
LOGIOCB   RMB      IOCB:SIZE
SYSIOCB   RMB      IOCB:SIZE
*
*       TASKING SYSTEM VARIABLES
*
DONTSTOPME      FCB       0       0 --> OK TO SCHEDULE
*                       1 --> IN TASK CRITICAL REGION; DON'T RESCHEDULE!
SURPRISE        RMB      1       <> 0 --> SCHEDULING DECISION IS OK
*
SCHEDX   RMB      2       TEMPORARY X STORAGE FOR SCHEDULING ROUTINES

*       THE FOLLOWING ARE SET UP BY SDOSINIT FROM THE CONFIGURATION TABLE
*
INTDISABLE        ;JMP    INTDISABLE        DISABLE ALL INTERRUPTS SUBROUTINE (PRESERVES (X))
        JMP     INTDISABLE
INTENABLE ;JMP    INTENABLE ENABLE ALL INTERRUPTS SUBROUTINE (PRESERVES (X))
        JMP     INTENABLE
INTRTI  ;JMP    INTRTI  SET PRIORITY INTERRUPT MASK AND DO RTI (CODE)
        JMP     INTRTI
INTERRUPTSTACK    RMB      2       COPY OF CNFG:INTERRUPTSTACK
JMPIOINT        ;JMP    JMPIOINT        JUMPS TO I/O DEVICE POLL CHAIN
        JMP     JMPIOINT
*
*       STUFF NEEDED TO KILL USER PROGRAMS
*
KILLREQUESTEDF  FCB       1       0 --> KILL WAS REQUESTED WHILE UNKILLABLE
KILLEDF FCB       1       0 --> ALREADY KILLED; 1--> NOT KILLED
SDOSRECURSIVECALL  FCB       0       0 --> SDOS NOT CALLED
*                       > 0 --> SDOS CALLED, USERRETAPTR IS VALID
USERRETAPTR      RMB      2       USER PROGRAM'S STACK REGISTER CONTENTS ON ENTRY TO SDOS
*                       POINTS TO HIS RETURN ADDRESS (USED BY "KILLUSERPROGRAM")
USERSYSCALLPTR    RMB      2       POINTS TO USER'S LAST SYSCALL BLOCK
        PAGE
*
*       INTERNAL SYSCALL CONTROL BLOCKS
*
CONSOLEOPEN      FCB       SYSCALL:OPEN      USED TO OPEN CONSOLE WHEN EOF HIT ON "DO" FILE
        FCB       OPEN:SCLEN
        FCB       0       CHANNEL
        FCB       IGNORED 2ND PARAMETER BYTE
CONSOLENAMEPTR    FDB      CHANGED   POINTER TO CONSOLE NAME (SET BY SDOSINIT)
CONSOLENAMELEN    FDB      CHANGED   LENGTH OF CONSOLE NAME (SET BY SDOSINIT)
        FDB      CHANGED   EXPECTED VALUE OF 2
        FDB      BUFFER   WHERE TO PUT # BYTES OF FILENAME USED
        FDB      2       SIZE OF EXPECTED RESPONSE
*
ACKCONTROLC FCB       SYSCALL:STATUS     SYSCALL USED TO ACK ^C^C
        FCB       STATUS:SCLEN
        FCB       0,SC:GETLINEFLAGSHINT
        FDB      IGNORED,IGNORED
        FDB      CHANGED
        FDB      BUFFER,1 READ LINE FLAGS TO GET ^C ERROR
*
LOGOUT  FCB       SYSCALL:WRITEA     USED TO COPY CONSOLE OUTPUT TO LOG FILE
        FCB       WRITEA:SCLEN
        FCB       LOGCHANNEL        CHANNEL
        FCB       IGNORED 2ND PARAM
        FDB      CHANGED   BUFFER ADDRESS
        FDB      CHANGED   REQUESTED COUNT
        FDB      CHANGED   REPLY COUNT -- ALWAYS ZEROED
        FDB      IGNORED,IGNORED REPLY BUFFER AND LENGTH
        FDB      CHANGED,CHANGED     = DESIRED FILE POSITION
*
DISPOUT FCB       SYSCALL:WRITEA     USED TO WRITE ERROR NUMBER ON CONSOLE
        FCB       WRITEA:SCLEN
        FCB       0       CHANNEL
        FCB       IGNORED
        FDB      STRINGBUFFER     BUFFER ADDRESS
        FDB      CHANGED   REQUESTED COUNT
*
DISPREADB3        FCB       SYSCALL:READB       USED TO READ POINTER FROM $ERRORMSGS FILE
        FCB       READB:SCLEN
        FCB       SYSCHANNEL        CHANNEL
        FCB       IGNORED
        FDB      IGNORED,IGNORED WRBUF,WRLEN
        FDB      CHANGED   REPLY LENGTH: EXPECTED VALUE OF 3
        FDB      DISPPOS1+1      BUFFER ADDRESS
        FDB      3       REQUESTED COUNT
DISPPOS1        ; THESE 4 BYTES GET MODIFIED BY DISPREADB3, DISPUSERERROR
        FCB       0,CHANGED,CHANGED,CHANGED
*
DISPGETCHAR       FCB       SYSCALL:READA       USED TO READ ERROR MESSAGE FROM $ERRORMESSAGES
        FCB       READA:SCLEN
        FCB       SYSCHANNEL        CHANNEL
        FCB       0       LINE MODE FLAG: NOT LINE MODE
        FDB      IGNORED,IGNORED WRBUF,WRLEN
        FDB      CHANGED   RPLEN: EXPECTED VALUE OF 1
        FDB      BUFFER   BUFFER ADDRESS
        FDB      1       REQUESTED COUNT
*
BUFFER   FDB      CHANGED,CHANGED     4 BYTE SCRATCH AREA
*
EXITCHAIN ; USED TO CHAIN TO "DEFAULTPROGRAM"
        FCB       SYSCALL:CHAIN
        FCB       CHAIN:SCLEN
        FCB       IGNORED,IGNORED PARAMS
        FDB      DEFAULTPROG,DEFAULTPROGL  WRBUF,WRLEN
        FDB      CHANGED   RESULT SIZE: EXPECTED VALUE OF 4
        FDB      LOADFILEPOS,4    READ-BACK BUFFER DEFINITION
*
EXITSCLOSE       ; USED BY EXITS TO CLOSE THE I/O CHANNELS
        FCB       SYSCALL:CLOSE
        FCB       CLOSE:SCLEN
        FCB       CHANGED   CHANNEL NUMBER TO BE CLOSED
*
IOBLOCK   ; ADJUSTED I/O REQUEST GETS COPIED HERE
        RPT     SCBLK:DATA
        FCB       CHANGED
        PAGE
*       SDOS SAFEGUARD CODE
*       THIS CODE IS USED TO ENSURE THAT SD'S VERSION OF SERIALNUMBER.SYS...
*       WAS TRULY EXECUTED PROPERLY.  OUR VERSION PASSES A SECRET SIGNAL
*       TO "CHAIN" IN THE SYSCALL:PARAMS FEILD; THIS CODE IS PASSED TO
*       THIS ROUTINE IN THE (X) REGISTER.  ANY OTHER CODE PASSED IN (X)
*       WILL CAUSE SDOS TO EVENTUALLY BLOW UP (I.E., LONG TERM UNRELIABLE).
*       THIS CODE IS INTENDED TO BE EXTREMELY OBTUSE, TO PREVENT WOULD-BE
*       PIRATES FROM UNDERSTANDING (A DISASSEMBLY OF) IT, AND THEREFORE
*       BREAKING OUR PROTECTION.  WE HOPE IT WORKS!
*
        NOP             FORCE DISASSEMBLER IN SYNC WITH THE WRONG STUFF
        NOP
        NOP
        FCB       $F7     STAB EXTENDED OPCODE, TO KEEP DISASSEMBLER IN FALSE SYNC
        IF      M6800!M6801
SAFEGAURD ; ENTRY POINT TO SDOS SAFEGAURDING CODE
	DES
        INS
        RTS
        RTI
        RTI
        RTI
        RTI

;ZZZ        FCB       $FF     STX EXTENDED ONTO ADDRESS PART OF INSTRUCTION...
;ZZZ        FDB      *       THEREBY SETTING UP SECRET MESSAGE AS EXECUTABLE CODE
SAFEGAURD1
;ZZZ        ROLA             RED HERRING INSTRUCTION
;ZZZ        LDX     #$3B3B    "RTI, RTI" OPCODES
        LDAA     #$34    "DES" OPCODE
        STX     SAFEGAURD1        PLANT RTI, RTI AFTER SDOS ENABLING KEY
        ;STA     SAFEGAURD PLANT "DES" AT SAFEGAURD ENTRY POINT
        STAA      SAFEGAURD
        RTS             CHAINING TO INITIALIZE.SYS OR DEFAULTPGM...
*       WILL ZERO USER SPACE BECAUSE OF INCOMPATIBLE DECRYPTION KEYS!
        PAGE
*       AFTER EXECUTION WITH "INS, RTS" SDOS ENABLING KEY IN (X),
*       THE SAFEGAURD CODE CONVERTS ITSELF INTO THE FOLLOWING:
*
*       SAFEGAURD
*               DES
*               INS
*               RTS
*               RTI
*               RTI
*               RTI
*               RTI
*
*       IF THE PROPER ENABLING KEY IS NOT GIVEN, THE "DES" ... "RTI" SEQUENCE
*       WILL BLOW UP ON SUCCESSIVE CALLS TO SAFEGAURD!
        ELSE    (M6809)
SAFEGAURD ; ENTRY POINT TO SDOS SAFEGAURDING CODE
        ;LDD    #$7F32  = BYTES OF "LEAS -1,S" REVERSED (WHEEE!)
        LDAB      #($7F32)&$FF
        LDAA      #($7F32)/256
        STX     *       STORE USER'S PURPORTED "(LEAS) 1,S/RTS"
        ;LDX    #$3B3B    "RTI","RTI" OPCODES
        LDX     #$3B3B
        STX     SAFEGAURD+5       PLANT "RTI","RTI"
        ;STD    SAFEGAURD+1       PLANT "    ...-1,S/LEAS ..."
        STAB      SAFEGAURD+1+1
        STAA      SAFEGAURD+1
        ;STB     SAFEGAURD PLANT "LEAS..."
        STAB      SAFEGAURD
        RTS
        FIN
        page
LOADGETPOS       FCB       SYSCALL:STATUS     USED BY LOADER TO PERFORM A "SKIP N BYTES" LOADER COMMAND
        FCB       STATUS:SCLEN
        FCB       SYSCHANNEL
        FCB       SC:GETPOS
        FDB      IGNORED,IGNORED WRBUF,WRLEN
        FDB      CHANGED   RPLEN: EXPECTED VALUE OF 4
        FDB      LOADFILEPOS      PLACE TO PUT LOAD FILE POSITION
        FDB      4       SIZE OF LOAD FILE POSITION BUFFER
*
LOADFILEPOS      ; CURRENT POSITION OF LOAD FILE
        FCB       CHANGED,CHANGED,CHANGED,CHANGED
*
FILLDECRYPTBUFFER ; SYSCALL BLOCK TO READ 8 BYTES INTO DECRYPTBUFFER
         FCB       SYSCALL:READB,READB:SCLEN
         FCB       SYSCHANNEL,IGNORED
         FDB      IGNORED,IGNORED
         FDB      CHANGED   EXPECTED VALUE IS 8
         FDB      DECRYPTBUFFER,8

LOADMULTIPLEOF8   ; SYSCALL BLOCK TO LOAD MULTIPLE OF 8 BYTES
         FCB       SYSCALL:READB,READB:SCLEN
         FCB       SYSCHANNEL,IGNORED
         FDB      IGNORED,IGNORED
         FDB      CHANGED   EXPECTED VALUE = OPTIMIZEDLOADCOUNT
LOADADDRESS ; THIS IS WHERE LOADER WILL PLACE NEXT LOADED BYTE
         FDB      CHANGED   REPLY BUFFER
OPTIMIZEDLOADCOUNT ; THIS IS NUMBER OF BYTES TO LOAD
         FDB      CHANGED   ALWAYS A MULTIPLE OF 8

GET1BYTE ; SYSCALL BLOCK USED TO READ 1 BYTE FROM SYSCHANNEL INTO BUFFER
        FCB       SYSCALL:READB,READB:SCLEN
        FCB       SYSCHANNEL,IGNORED
        FDB      IGNORED,IGNORED
        FDB      CHANGED   RPLEN: EXPECTED VALUE OF 1
        FDB      BUFFER,1 WHERE TO PLACE REPLY

DECRYPTBUFPTR FDB DECRYPTBUFFER POINTER TO SCAN DECRYPTBUFFER

DECRYPTBUFFER     ; THIS IS WHERE CHUNKS OF 8 BYTES GET READ FOR DECRYPTION
        fcb     0,1,2,3,4,5,6,7 Loader decryption area
DECRYPTBUFFEREND  ; END OF DECRYPT BUFFER

NKEYS   FCB       CHANGED   TYPE 5 RECORD: KEY COUNT

RUNNINGENCRYPTEDFLAG      FCB       1       HOLDS RUNNINGENCRYPTED FLAG IF MASK ROM
;                       initially TRUE so VTDRIVER will not recognize ^D during boot process

OKTODECRYPTFLAG   FCB       CHANGED   1 --> OK TO DECRYPT THIS MODULE

OLDKEYENCRYPTED  ; ENCRYPTED VERSION OF LAST DECRYPTION KEY USED
        FCB       0,0,0,0,0,0,0,0 SPACE TO HOLD KEY (8 BYTES)

NEWKEYENCRYPTED  ; ENCRYPTED VERSION OF KEY USED TO LOAD THIS FILE
        FCB       0,0,0,0,0,0,0,0 SPACE TO HOLD 8 BYTE KEY
        page
*        Encryption Subroutine
*        Encrypts 8 data bytes pointed to by (X)...
*            according to 8 byte key stored in locations KEY
*        Result is stored as 8 byte string at (X)
*
*        Encryption algorithm is logically as follows:
*        (Some minor modifications make it fast enough to run on a 6800)
*            Result:=ValuetobeEncrypted
*            For bit=64 to 1 -- one iteration per bit
*                If MSB(Result) -- Inspect MSB of Result to decide what to do
*                Then
*                    -- Encrypt step: XOR with KEY
*                    Result:=(Result XOR KEY)*2+[MSB(Result) XOR MSB(KEY)]
*                Else
*                    -- Randomize step: XOR with Randomizing constant
*                    Result:=(Result XOR RNDIZER)*2+[MSB(Result) XOR MSB(KEY)]
*                Fi
*            Endloop -- Encrypted result is in Result
*
*       Decryption algorithm is logically as follows:
*            Result:=ValuetobeDecrypted
*            For bit=64 to 1 -- one iteration per bit
*                If LSB(Result) XOR MSB(KEY) -- Decrypt LSB to decide how undo
*                Then -- Decrypt step
*                     Result:=[INT(Result/2)+LSB(Result)*2^63] XOR KEY
*                Else -- "UnRandomize" step
*                     Result:=INT([Result XOR (Randomizer*2)]/2)
*                Fi
*             Endloop -- Decrypted result is in "Result"
        page
*
*        Randomizer constant is as follows (random 64 bit string):
*        To prevent loss of this string due to accidental damage to this text,
*        it is repeated 5 times here:
*        %0101010110100110000010101001110011100011010101111010110000111001
*        %0101010110100110000010101001110011100011010101111010110000111001
*        %0101010110100110000010101001110011100011010101111010110000111001
*        %0101010110100110000010101001110011100011010101111010110000111001
*        %0101010110100110000010101001110011100011010101111010110000111001
*
*        The Hex equivalent of the randomizer string is:
*
*        $55 A6 0A 9C E3 57 AC 39
*
*
*        KEY is a buffer of 8 bytes; it should be in page zero for speed!
*        We have chosen to put it inline in EORA #.. instructions instead
*        in the Decrypt routine.  Encrypt simply references the decrypt bytes.
*
*       NOTE: IT MIGHT BE POSSIBLE TO SPEED UP THIS CODE FOR 6801/6809!
        page
decrypt1        ; do "decrypt step"
        staa    0,x
        ldaa    1,x     EOR with this byte of key
        rora            shift right, saving carry from left
Key1    equ     *+1
        ;eora   #$16    $16 is red herring
        EORA     #$16
        staa    1,x
        ldaa    2,x     EOR with this byte of key
        rora            shift right, saving carry from left
Key2    equ     *+1
        ;eora   #$73    $73 is red herring
        EORA     #$73
        staa    2,x
        ldaa    3,x     EOR with this byte of key
        rora            shift right, saving carry from left
Key3    equ     *+1
        ;eora   #$F6    $F6 is red herring
        EORA     #$F6
        staa    3,x
        ldaa    4,x     EOR with this byte of key
        rora            shift right, saving carry from left
Key4    equ     *+1
        ;eora   #$09    $09 is red herring
        EORA     #$09
        staa    4,x
        ldaa    5,x     EOR with this byte of key
        rora            shift right, saving carry from left
Key5    equ     *+1
        ;eora   #$56    $56 is red herring
        EORA     #$56
        staa    5,x
        ldaa    6,x     EOR with this byte of key
        rora            shift right, saving carry from left
Key6    equ     *+1
        ;eora   #$ED    $ED is red herring
        EORA     #$ED
        staa    6,x
        ldaa    7,x     EOR with this byte of key
        rora            shift right, saving carry from left
Key7    equ     *+1
        ;eora   #$41    $41 is red herring
        EORA     #$41
        staa    7,x
        decb            down count # iterations
        bne     decryptloop     b/ more to do
        ;jmp    decryptrts      all done, go clean up and exit!
        JMP     decryptrts
        page
*       Decrypt -- Undoes Encrypt
*       Decryption key is stored inline in locations KEY0, KEY1, ... KEY7
*       Block of 8 bytes at (X) is decrypted in place
*
Decrypt ; Do the encryption in reverse, literally
*       ldab    #64     64 iterations of reverse encryption required
        ldab    key7    do 8 + 2 lsb of key iterations
        andb    #3
        addb    #8
        ;jsr    eorall8bytes    unscramble least significant byte
        JSR     eorall8bytes
        staa    7,x     do first decryption iteration
decryptloop ; right shift current value and EOR with key
        rora            Shift encrypted "encrypt" bit into carry...
        ldaa    0,x     EOR with this byte of key
        rora            shift right, saving carry from left
Key0    equ     *+1
        ;eora   #$92    92 is red herring
        EORA     #$92
SDOSCHKSUMBASE     ; ALL CODE FROM HERE TO END OF SDOS IS CHECKSUMMED!!
        bmi     decrypt1        b/ encrypt bit was 1, go do "decrypt step"
decrypt0 ; "encrypt" bit was 0, right shift current value and EOR with randomizer
        ;eora   key0    undo "eora key" done by decryptloop
        EORA     key0
        anda    #$7F    force MSB to be zero
        ;eora   #$55    EOR with randomizer byte
        EORA     #$55
        staa    0,x     (Note: MSB(Randomizer) must be zero)
        ldaa    1,x     EOR with this byte of key
        rora            shift right, saving carry from left
        ;eora   #$A6
        EORA     #$A6
        staa    1,x
        ldaa    2,x     EOR with this byte of key
        rora            shift right, saving carry from left
        ;eora   #$0A
        EORA     #$0A
        staa    2,x
        ldaa    3,x     EOR with this byte of key
        rora            shift right, saving carry from left
        ;eora   #$9C
        EORA     #$9C
        staa    3,x
        ldaa    4,x     EOR with this byte of key
        rora            shift right, saving carry from left
        ;eora   #$E3
        EORA     #$E3
        staa    4,x
        ldaa    5,x     EOR with this byte of key
        rora            shift right, saving carry from left
        ;eora   #$57
        EORA     #$57
        staa    5,x
        ldaa    6,x     EOR with this byte of key
        rora            shift right, saving carry from left
        ;eora   #$AC
        EORA     #$AC
        staa    6,x
        ldaa    7,x     EOR with this byte of key
        rora            shift right, saving carry from left
        ;eora   #$39
        EORA     #$39
        staa    7,x
        decb            down count # iterations
        bne     decryptloop     b/ more iterations to try
decryptrts
        ;jsr    eorall8bytes    now unscramble Most significant byte
        JSR     eorall8bytes
        staa    0,x
        rts             decryption complete, result is in Result
        page
Eorall8bytes ; Compute XOR of all 8 bytes
        ldaa    4,x     Why are the index displacements all mixed up?
        ;eora   7,x     Because it puzzles the hell out of whoever...
        EORA     7,X
        ;eora   5,x     attempts to dis-assemble it!
        EORA     5,X
        ;eora   0,x
        EORA     0,X
        ;eora   2,x
        EORA     2,X
        ;eora   6,x
        EORA     6,X
        ;eora   1,x
        EORA     1,X
        ;eora   3,x     so Most sig byte of result depends on all 64 bits
        EORA     3,X
        rts

        if      0       Encrypt is not needed by this version of SDOS
EncryptLSB ; Set MSB to XOR of all 8 bytes
*       think about this, someday...
*       Dennis Painter sez: put key just below (S) and run with
*       Interrupts disabled.    Then it cannot be damaged unless an
*       NMI occurs, which will erase it.
Encrypt ; And now it begins
*       ldab    #64     = # iterations to execute (too slow!)
        ldab    key+7   do 8 + 2 lsb of key iterations
        andb    #3
        addb    #8
        ;jsr    Eorall8bytes    scramble MSB
        JSR     Eorall8bytes
        staa    0,x     examine sign bit to decide what to do
        bpl     encryptrandomize b/ MSB is zero, go do randomize step
encryptstep ; MSB is one, perform encryption step
*       EOR current value with key, shift left
        ldaa    7,x     EOR this byte with key byte
        ;eora   key+7
        EORA     key+7
        asla            shift left, forcing LSB=0
        staa    7,x
        ldaa    6,x     EOR this byte with key byte
        ;eora   key+6
        EORA     key+6
        rola            shift left, saving carry from byte to right
        staa    6,x
        ldaa    5,x     EOR this byte with key byte
        ;eora   key+5
        EORA     key+5
        rola            shift left, saving carry from byte to right
        staa    5,x
        ldaa    4,x     EOR this byte with key byte
        ;eora   key+4
        EORA     key+4
        rola            shift left, saving carry from byte to right
        staa    4,x
        ldaa    3,x     EOR this byte with key byte
        ;eora   key+3
        EORA     key+3
        rola            shift left, saving carry from byte to right
        staa    3,x
        ldaa    2,x     EOR this byte with key byte
        ;eora   key+2
        EORA     key+2
        rola            shift left, saving carry from byte to right
        staa    2,x
        ldaa    1,x     EOR this byte with key byte
        ;eora   key+1
        EORA     key+1
        rola            shift left, saving carry from byte to right
        staa    1,x
        ldaa    0,x     EOR this byte with key byte
        ;eora   key+0
        EORA     key+0
        rola            shift left, saving carry from byte to right
        bcc     encryptstep0    b/ encrypted MSB is now zero
        ;inc    7,x     remember that encrypted MSB is a one
        INC      7,X
encryptstep0 ; encrypted MSB has been recorded in LSB of result
        decb            down count # iterations to perform
        beq     encryptrts      b/ done encrypting
        staa    0,x
        bmi     encryptstep     b/ new MSB is one, go do encrypt step
encryptrandomize ; MSB is zero, perform randomize step
        ldaa    7,x     EOR this byte with randomizer byte
        ;eora   #$39
        EORA     #$39
        asla            shift left, forcing LSB to be zeroed
        staa    7,x
        ldaa    6,x     EOR this byte with randomizer byte
        ;eora   #$AC
        EORA     #$AC
        rola            shift left, saving carry from byte to right
        staa    6,x
        ldaa    5,x     EOR this byte with randomizer byte
        ;eora   #$57
        EORA     #$57
        rola            shift left, saving carry from byte to right
        staa    5,x
        ldaa    4,x     EOR this byte with randomizer byte
        ;eora   #$E3
        EORA     #$E3
        rola            shift left, saving carry from byte to right
        staa    4,x
        ldaa    3,x     EOR this byte with randomizer byte
        ;eora   #$9C
        EORA     #$9C
        rola            shift left, saving carry from byte to right
        staa    3,x
        ldaa    2,x     EOR this byte with randomizer byte
        ;eora   #$0A
        EORA     #$0A
        rola            shift left, saving carry from byte to right
        staa    2,x
        ldaa    1,x     EOR this byte with randomizer byte
        ;eora   #$A6
        EORA     #$A6
        rola            shift left, saving carry from byte to right
        staa    1,x
        ldaa    key     EOR MSB of result with MSB of key
        anda    #$80    (Note: this requires that MSB(randomizer) be zero)
        ;eora   0,x     EOR MSB with MSB of key
        EORA     0,X
        ;eora   #$55    and EOR rest with randomizer
        EORA     #$55
        rola            shift left, saving carry from byte to right
        bcc     encryptrand0    b/ encrypted MSB=0
        ;inc    7,x     record that encrypted MSB is 1
        INC      7,X
encryptrand0 ; encrypted MSB is now saved in LSB of result
        decb            down count # iterations to perform
        beq     encryptrts      b/ done encrypting
        staa    0,x
        bpl     encryptrandomize b/ next bit is zero
        ;jmp    encryptstep
        JMP     encryptstep

encryptrts ; encryption is complete
        staa    0,x     store MSB of final result
        ;jsr    eorall8bytes    scramble lsbyte
        JSR     eorall8bytes
        staa    7,x
        rts
        fin
        PAGE     SDOS FRONT END CODE
SDOSMSG FCB       ASCII:FF,ASCII:CR
        FCC       'SDOS Version '
        FCB       '0+((SDOSVERSION/$10)&$F)
        FCB       '.
        FCB       '0+((SDOSVERSION/$1)&$F)
        FCB       SDOSSUBREVISION
        FCC       '2, '			; ZZZ this is the sub-sdossubrevision 2
					; as it have all the serial/checksum validations 
					; disabled (commented out)

COPYRIGHTCHECKSUM  EQU     $36
COPYRIGHT        FCC       'Copyright (C) 1978 Software Dynamics'
        FCB       ASCII:CR
COPYRIGHTEND     EQU     *
        PAGE
*
*       SYSCALL MINIMUM SIZE, N-WAY OPCODE BRANCH TABLE
*
OPCODES  OPEN:SCLEN,#OPEN OPEN FILE
        CREATE:SCLEN,#CREATE CREATE A NEW FILE
        CLOSE:SCLEN,#CLOSE CLOSE A FILE
        RENAME:SCLEN,#RENAME       RENAME A FILE
        DELETE:SCLEN,#DELETE     DELETE A FILE
        LOAD:SCLEN,#LOAD   LOAD A FILE INTO MEMORY
        CHAIN:SCLEN,#CHAIN   CHAIN TO A FILE
        CREATELOG:SCLEN,#CREATELOG   CREATE A FILE FOR OUTPUT ON LOG CHANNEL
        CLOSELOG:SCLEN,#CLOSELOG   CLOSE LOG OUTPUT FILE
        DISKDEFAULT:SCLEN,#DISKDEFAULT     SET DISK DEFAULT DEVICE
        READA:SCLEN,#READA   READ ASCII BYTES FROM A FILE
        READB:SCLEN,#READB   READ BINARY BYTES FROM A FILE
        WRITEA:SCLEN,#WRITEA       WRITE ASCII BYTES TO A FILE
        WRITEB:SCLEN,#WRITEB       WRITE BINARY BYTES TO A FILE
        CONTROL:SCLEN,#CONTROL     PERFORM A CONTROL OPERATION ON AN I/O CHANNEL
        STATUS:SCLEN,#STATUS       READ STATUS FROM AN I/O CHANNEL
        WAITDONE:SCLEN,#WAITDONE   WAIT FOR I/O CHANNEL OPERATION DONE
        EXIT:SCLEN,#EXIT GIVE CONTROL BACK TO THE OPERATING SYSTEM
        ERROREXIT:SCLEN,#ERROREXIT       EXIT TO SYSTEM WITH ERROR CODE
        SETERROR:SCLEN,#SETERROR REPORT AN ERROR TO THE SYSTEM
        GETERROR:SCLEN,#GETERROR RETURN THE LAST ERROR CODE
        DISPERROR:SCLEN,#DISPLAYERROR     DISPLAY USER'S LAST ERROR
        KILLPROOF:SCLEN,#KILLPROOF       MAKE USER PROGRAM KILL-PROOF
        KILLENABLE:SCLEN,#KILLENABLE MAKE USER PROGRAM KILLABLE
        DEBUG:SCLEN,#DEBUG CALL SYSTEM DEBUGGER
        ATTNCHECK:SCLEN,#ATTNCHECK     OPERATOR ATTENTION CHECK
        ISCONSOLE:SCLEN,#ISCONSOLE IS CHANNEL ZERO OPEN TO CONSOLE PREDICATE
        INTERLOCK:SCLEN,#INTERLOCK OPERATE ON INTERLOCK OBJECT
        DELAY:SCLEN,#DELAY DELAY FOR SPECIFIED NUMBER OF CLOCK TICKS
        READLUNNAME:SCLEN,#READLUNNAME       READ NAME OF LOGICAL UNIT
        GETSERIALNUMBER:SCLEN,#GETSERIALNUMBER       GET SERIAL NUMBER OF COMPUTER
OPCODEMAX EQU     (*-OPCODES)/3-1
        PAGE
*       THE FOLLOWING POINTER CAN BE USED TO LOCATE THE SDOS:XXX TABLE
*       IT IS INTENDED TO BE USED IN DIAGNOSING SYSTEM FAILURES;
*       ($FC,$FD) POINT TO I/O PAK, WHICH HAS 3 BYTE JMP TO SYSCALLENTRY
*       THE SDOS:XXX TABLE CONTAINS THE LAST ERROR DETECTED BY SDOS
*
        FDB      CODE     POINTER TO SDOS:XXX TABLE
*
SYSCALLENTRY      EQU     *
        LDAA      SDOSRECURSIVECALL  CHECK # TIMES SDOS HAS BEEN RECURSIVELY CALLED
        BNE      SYSCALL1  B/ NOT FIRST TIME SDOS WAS CALLED
        STS     USERRETAPTR      SAVE STACK SO WE CAN KILL USER PROGRAM IF NEEDED
        STX     USERSYSCALLPTR    SAVE POINTER TO USER'S SYSCALL
SYSCALL1  EQU     *
        STX     CODE+SDOS:IOBLOCKPTR
        LDAB      SCBLK:OPCODE,X     GET THE OPCODE
        ;CMPB     #OPCODEMAX        IS THE OPCODE LEGAL?
        CMPB      #OPCODEMAX
        BHI      ERRILLSYSCALL     B/ NO
        ASLB              MULTIPLY OPCODE VALUE BY 3
        ADDB      SCBLK:OPCODE,X     N*2+N = N*3
        IF      OPCODEMAX*3>>255
        +ERROR  OPCODE INDEXING WON'T WORK
        FIN
        STAB      SYSCALLX+1        LOCATE OPCODE TABLE SLOT CORRESPONDING TO OPCODE
        LDAA      SCBLK:WLEN,X      COPY SYSCALL BLOCK LENGTH TO (A)
        ANDA      #%01111111      MASK OFF WAIT FLAG
        ;CMPA     #SCBLK:RPLEN+1    DOES SYSCALL BLOCK INCLUDE SPACE FOR REPLY LENGTH ?
        CMPA      #SCBLK:RPLEN+1
        BLS      SYSCALL2  B/ NO, LEAVE SCBLK:RPLEN ALONE
        ;CLR     SCBLK:RPLEN,X     YES, ZERO IT (CONVENIENCE FOR SYSCALL PROCESSORS)
        CLR      SCBLK:RPLEN,X
        ;CLR     SCBLK:RPLEN+1,X
        CLR      SCBLK:RPLEN+1,X
*       CHECK TO SEE IF SCBLK:RDBUF POINTS INTO SCRATCHPAD ?
SYSCALL2  EQU     *
*       CMPA      SCBLK:WLEN,X      COPY WAIT FLAG TO CARRY BIT
        ;LDX    SYSCALLX  GRAB POINTER TO OPCODE TABLE SLOT
        LDX     SYSCALLX
        ;CMPA     OPCODES&$FF,X    IS SIZE OF SYSCALL BLOCK >= NECESSARY MINIMUM ?
        CMPA      OPCODES&$FF,X
        BCS       ERRSYSCALLTOOSHORT        B/ NO, YOU DIE!
        ;INC     SDOSRECURSIVECALL  NOW THAT USERRETAPTR IS VALID,...
        INC      SDOSRECURSIVECALL
*                       LET KILLUSER PROGRAM KNOW ABOUT IT
        ;JSR    [(OPCODES&$FF)+1,X]      GO DO THE SYSCALL FUNCTION
        LDX     (OPCODES&$FF)+1,X
        JSR     0,X
        BCS       *+2     MAKE SURE WE GET CONTROL EVEN IF ERROR OCCURS
        ;DEC     SDOSRECURSIVECALL  DOWN COUNT # RECURSIVE CALLS TO SDOS
        DEC      SDOSRECURSIVECALL
        BCS       ERRORED B/ SOME ERROR DID HAPPEN, ABORT!
        RTS             RETURN TO CALLER
*
ERRILLSYSCALL     BSR      ERRET
        FDB      ERR:ILLEGALSYSCALL

ERRSYSCALLTOOSHORT        EQU     *
        BSR      ERRET
        FDB      ERR:SYSCALLTOOSHORT
        PAGE
*       SDOS ERROR HANDLING
*
*       ERRET -- CALLED VIA A JSR WITH IN-LINE 2-BYTE ERROR CODE
*               ERROR CODE IS LOADED INTO (X)
*               CARRY IS SET TO INDICATE ERROR CONDITION
*               AND A RTS IS PERFORMED
*               IF CALLING ROUTINE HAS NO BCS/BCC AFTER JSR,
*               ERRET AUTOMATICALLY POPS THE STACK ONE SUBROUTINE LEVEL
*               AND LOOKS AGAIN FOR A BCS
*               ***NOTE: THIS MEANS TOP LEVEL (USER!) MUST HAVE BCC/BCS!***
*               This routine places error code in TEMPX while unwinding stack
*
ERRET   ;PULX           GET RETURN ADDRESS TO (X)
        TSX
        LDX     0,X
        INS
        INS
        STX     ERRORADDRESS     THIS HELPS WHEN WE'RE DEBUGGING SDOS
        ;LDX    ,X      GET ERROR CODE INTO (X)
        LDX     0,X
ERRORINX        ; ENTRY POINT IF ERROR CODE IS ALREADY IN (X)
        STX     LASTERROR        SAVE THE ERROR CODE IN CASE OF CRASH
        STX     TEMPX   SAVE ERROR CODE IN RE-ENTRANT WAY
        BRA       ERRORED SKIP INTO BCC/BCS STACK POP LOOP

ERRETL  ; POP RETURN ADDRESS FROM THE STACK
        ;LEAS    2,S
        IF      2<0
        RPT     -2
        DES
        ELSE
        RPT     2
        INS
        FIN
ERRORED ; NOW FAKE "RTS" UNTIL BCC/BCS ENCOUNTERED
        ;LDX    0,S     GRAB RETURN ADDRESS
        TSX
        LDX     0,X
        LDAA      ,X      DOES RETURN ADDRESS POINT TO BCS/BCC ?
        IF      M6800!M6801
*       SIMULATED LONG BRANCHES START WITH BCC/BCS!
        ELSE    (M6809)
        ;CMPA     #$10    EXTENDED OPCODE?
        CMPA      #$10
        BNE      ERRORED1        B/ NO
        LDAA      1,X     YES, GET 2ND BYTE OF OPCODE
ERRORED1        ; (A) CONTAINS OPCODE TO INSPECT
        FIN
        ANDA      #\%1    (MASK OFF "INVERT BRANCH CONDITION" BIT)
        ;CMPA     #$24    (BCS OPCODE FOR 6800/6801 AND 6809)
        CMPA      #$24
        BNE      ERRETL  NO, SIMULATE "BCS TO A RTS"
        ;LDX    TEMPX   GET THE ERROR CODE AGAIN
        LDX     TEMPX
        ERRORRTS        SET THE CARRY AND EXIT

ERRORSAVE        ; SAVE THE ERROR CODE IN (X)
        STX     LASTERROR        SAVE CODE IN CASE OF CRASH
        STX     TEMPX   SAVE ERROR CODE IN RE-ENTRANT FASHION
        ERRORRTS        AND EXIT
        PAGE     SYSCALL:ISCONSOLE HANDLER
*
*       ISCONSOLE -- PERFORM "SYSCALL:ISCONSOLE"
*
ISCONSOLE        EQU     *
        ;LDX    CODE+SDOS:CONFIGURATION    FIND IOCB POINTER FOR CHANNEL 0
        LDX     CODE+SDOS:CONFIGURATION
        ;LDX    [CNFG:IOCBPOINTERS,X]      (GET POINTER TO LIST OF IOCB POINTERS)
        LDX     CNFG:IOCBPOINTERS,X
        LDX     0,X
        ;LDX    IOCB:DRIVER,X     GET POINTER TO DRIVER FOR DEVICE
        LDX     IOCB:DRIVER,X
        BEQ      ERRCLOSED        B/ CHANNEL IS NOT OPEN
        CPX      CONSOLEDRIVER    OPEN TO CONSOLE DRIVER ?
        BEQ      ISCONSOLEOKRTS   B/ YES, TAKE "OK" EXIT
        BSR      ERRET   NO
        FDB      ERR:NOTOPENTOCONSOLE

ERRCLOSED        EQU     *
        BSR      ERRET
        FDB      ERR:CLOSED

ERRCHBUSY EQU     *
        BSR      ERRET
        FDB      ERR:CHBUSY

ERRCHTOOBIG       EQU     *
        BSR      ERRET
        FDB      ERR:CHTOOBIG
        PAGE     CHANNEL NUMBER CHECKING/IOCB DETERMINATION
*       CHECKCHANNELOPEN -- CHECK THAT CHANNEL SPECIFIED BY SYSCALL IS OPEN
*       RETURNS POINTER TO IOCB FOR CHANNEL IN IOCBPOINTER
*       ALSO SETS UP DRIVERVPOINTER, DCBPOINTER FROM IOCB IF CHANNEL IS OPEN
*
CHECKCHANNELOPEN    EQU     *
        BSR      GETIOCBPOINTER    FIRST, LOCATE THE IOCB FOR THE DESIRED CHANNEL
        ;LDX    IOCB:DRIVER,X     GRAB POINTER TO DEVICE DRIVER FOR CHANNEL
        LDX     IOCB:DRIVER,X
        BEQ      ERRCLOSED        B/ CHANNEL IS NOT OPEN!
        STX     DRIVERVPOINTER  FOR LATER USE
        ;LDX    IOCBPOINTER       SET UP DCB POINTER FROM IOCB, ALSO
        LDX     IOCBPOINTER
        ;LDX    IOCB:DCB,X
        LDX     IOCB:DCB,X
        STX     DCBPOINTER
        ;LDX    DRIVERVPOINTER  FOR CONVENIENCE OF CALLERS
        LDX     DRIVERVPOINTER
ISCONSOLEOKRTS   EQU     *
        OKRTS
*
*       CHECKCHANNELCLOSED -- CHECK THAT CHANNEL SPECIFIED BY SYSCALL IS CLOSED
*       SETS IOCBPOINTER TO POINTER TO I/O CONTROL BLOCK FOR SPECIFIED CHANNEL
*
CHECKCHANNELCLOSED   EQU     *
        BSR      GETIOCBPOINTER    FIRST, LOCATE THE PROPER IOCB
CHECKCHANNELCL1      ; ENTRY POINT FOR CREATELOG
        ;LDX    IOCB:DRIVER,X     GRAB POINTER TO DEVICE DRIVER
        LDX     IOCB:DRIVER,X
        BNE      ERRCHBUSY B/ CHANNEL IS ALREADY BUSY!
        OKRTS
        PAGE
*
*       GETIOCBPOINTER -- SETS IOCBPOINTER USING SCBLK:PARAMS AS CHANNEL NUMBER
*       ALSO RETURNS IOCBPOINTER IN (X)
*
GETIOCBPOINTER    EQU     *
        ;LDX    CODE+SDOS:IOBLOCKPTR       GRAB POINTER TO SYSCALL BLOCK
        LDX     CODE+SDOS:IOBLOCKPTR
        LDAB      SCBLK:PARAMS,X      THIS IS WHERE ***ALL*** CHANNEL NUMBERS MUST BE!
        ;LDX    CODE+SDOS:CONFIGURATION    VALID CHANNEL NUMBER ?
        LDX     CODE+SDOS:CONFIGURATION
        ;CMPB     CNFG:NIOCHANNELS,X ...?
        CMPB      CNFG:NIOCHANNELS,X
        BCC        GETIOCB1  B/ NO!
        CLRA              MAKE CHANNEL NUMBER INTO 16 BIT QUANTITY
        ;ASLD            DOUBLE TO MAKE INDEX INTO CHANNEL POINTER TABLE
        ASLB
        ROLA
        ;ADDD    CNFG:IOCBPOINTERS,X        COMPUTE POINTER TO IOCB POINTER
        ADDB      (CNFG:IOCBPOINTERS)+1,X
        ADCA       CNFG:IOCBPOINTERS,X
        ;TDX            GRAB POINTER TO IOCB
        STAA      TEMPA
        STAB      TEMPB
        LDX     TEMPX
        ;LDX    0,X
        LDX     0,X
GETIOCBX  EQU     *
        STX     IOCBPOINTER
        OKRTS

GETIOCB1  ; INVALID CHANNEL NUMBER FOUND
        LDAA      SDOSRECURSIVECALL  USER SYSCALL?
        DECA              (NESTING = 1?)
        BEQ      ERRCHTOOBIG       B/ YES, REALLY IS INVALID CHANNEL NUMBER
        ;LDX    #LOGIOCB  ASSUME LOG IOCB WAS MEANT
        LDX     #LOGIOCB
        ;CMPB     #LOGCHANNEL       ASSUMPTION CORRECT ?
        CMPB      #LOGCHANNEL
        BEQ      GETIOCBX  B/ YES
        ;LDX    #SYSIOCB  NO, ALL OTHERS GET TURNED INTO SYSIOCB CHANNELS
        LDX     #SYSIOCB
        BRA       GETIOCBX
        PAGE
*
*       ISDIG -- IS (A) A DIGIT ?
*       RETURNS CARRY RESET IF YES
*       RETURNS CARRY SET IF NO
*       (A) LEFT UNDISTURBED
*
ISDIG   EQU     *
        ;CMPA     #'9     DIGIT ?
        CMPA      #'9
        BHI      ISDNO   B/ NOPE
        ;CMPA     #'0     ...?
        CMPA      #'0
        RTS             WITH CARRY SET PROPERLY

ISDNO   EQU     *
        SEC              MEANING "NOPE..."
        RTS
*
*       ISALPHANUM -- IS (A) AN ALPHA OR NUMERIC CHARACTER ?
*       RETURNS CARRY RESET IF TRUE; LOWER CASE LETTER FOLDED INTO UPPER CASE
*       OTHERWISE, RETURNS CARRY SET
*       (A) IS UNDISTURBED
*
ISALPHANUM        EQU     *
        BSR      ISDIG   TRY FOR A DIGIT, FIRST...
        BCC        ISALPHANUMRTS     B/ ITS A DIGIT, GET OUT NOW!
        ;CMPA     #'Z+32  LOWER CASE ALPHA ?
        CMPA      #'Z+32
        BHI      ISDNO   B/ NO, AND ITS NOT UPPER CASE, EITHER
        ;CMPA     #'A+32   ...?
        CMPA      #'A+32
        BCS       ISALPHANUM1       B/ NO, MIGHT BE UPPER CASE
        ANDA      #%01011111      IS LOWER CASE, CONVERT TO UPPER CASE
ISALPHANUMRTS     ; CHEAP EXIT
        RTS             WITH THE CARRY RESET

ISALPHANUM1       ; MIGHT BE UPPER CASE
        ;CMPA     #'Z     ...?
        CMPA      #'Z
        BHI      ISDNO   B/ NOPE
        ;CMPA     #'A      ...?
        CMPA      #'A
        RTS
        PAGE
*
*       FINDDRIVER -- CONVERT DEVICE NAME TO DRIVER ENTRY POINTER VECTOR ADDRESS
*               ALSO FILLS IN DCBPOINTER
*       SYSCALL POINTED TO BY FNAMESYSCALLPTR SELECTS FILENAME AND SIZE
*       RETURNS (X) POINTING TO DRIVER
*       SETS RDBUF TO LENGTH OF PREFIX OF USER-SUPPLIED FILENAME THAT MATCHES DEVICE NAME
*
FINDDRIVER      EQU     *
        ;LDX    CODE+SDOS:IOBLOCKPTR       CHECK FOR DEVICE NAME GIVEN
        LDX     CODE+SDOS:IOBLOCKPTR
        ;LDX    SCBLK:WRLEN,X     GET LENGTH OF FILENAME
        LDX     SCBLK:WRLEN,X
        STX     TEMPX   SAVE AS LOOP COUNTER
        ;LDX    CODE+SDOS:IOBLOCKPTR       GET ADDRESS OF FILE NAME
        LDX     CODE+SDOS:IOBLOCKPTR
        ;LDX    SCBLK:WRBUF,X
        LDX     SCBLK:WRBUF,X
        STX     FROMPOINTER     SAVE STRING SCAN POINTER
FINDDRIVER1L    ; CHECK NEXT CHARACTER TO SEE IF VALID DEVICE NAME
        ;LDX    TEMPX   GET REMAINING STRING COUNT
        LDX     TEMPX
        BEQ      FINDDEFAULT      B/ NO BYTES LEFT, VALID DEVICE NAME NOT SEEN
        DEX             DOWN COUNT # BYTES REMAINING
        STX     TEMPX
        ;LDX    FROMPOINTER     GET BYTE FROM STRING
        LDX     FROMPOINTER
        ;LDA     ,X+
        LDAA      0,X
        INX
        STX     FROMPOINTER
        BSR      ISALPHANUM        ALPHANUMERIC CHARACTER ?
        BCC        FINDDRIVER1L    B/ YES, CONTINUE SCAN FOR ":"
FINDDRIVER2     ; END OF ALPHANUMERIC DEVICE NAME PREFIX FOUND
        ;CMPA     #':     MUST HAVE ":" OR A DEVICE NAME IS NOT SPECIFIED
        CMPA      #':
        BNE      FINDDEFAULT      NO ":", MUST BE FILE NAME ON DEFAULT DISK
        PAGE
*       FOUND SOMETHING THAT LOOKS LIKE A DEVICE NAME
*
        ;LDX    CODE+SDOS:CONFIGURATION    FIRST, LOOK FOR A DISK DEVICE NAME
        LDX     CODE+SDOS:CONFIGURATION
        ;LDX    CNFG:DISKDCBS,X
        LDX     CNFG:DISKDCBS,X
FINDDISK        EQU     *
        STX     DCBPOINTER        POINTER TO DISK INFO ENTRY
        ;LDX    DCB:NAME,X GET POINTER TO DEVICE NAME STRING
        LDX     DCB:NAME,X
        BSR      CMPDVNAME COMPARE AGAINST FILENAME STRING
        BCC        FOUNDDISK       B/ THAT'S IT!
        ;LDX    DCBPOINTER        GET ADDRESS OF NEXT DISK INFO ENTRY
        LDX     DCBPOINTER
        ;LDX    DCB:NEXTDCB,X
        LDX     DCB:NEXTDCB,X
        BNE      FINDDISK        B/ NOT END OF LIST
        ;LDX    DEFAULTDISKDCB     ASSUME DEFAULT DISK CHOSEN
        LDX     DEFAULTDISKDCB
        STX     DCBPOINTER        REMEMBER IT...
        ;LDX    #DEFAULTDISKNAME  CHECK TO MAKE SURE...
        LDX     #DEFAULTDISKNAME
        BSR      CMPDVNAME CHECK DEFAULT DISK NAME AGAINST GIVEN DEVICE NAME
        BCC        FOUNDDISK       B/ IT MATCHES, FAKE IT FROM HERE!
*
*       SEARCH THE NON-DISK LIST
*
        ;LDX    CODE+SDOS:CONFIGURATION
        LDX     CODE+SDOS:CONFIGURATION
        ;LDX    CNFG:DEVICEDCBS,X   GET POINTER TO LIST OF NON-DISK DEVICES
        LDX     CNFG:DEVICEDCBS,X
FINDDEVICEL      ; SEE IF THIS IS IT
        STX     DCBPOINTER        SAVE POINTER TO NON-DISK DCB
        ;LDX    DCB:DRIVER,X      GET DEVICE DRIVER ADDRESS IN CASE OF MATCH
        LDX     DCB:DRIVER,X
        STX     DRIVERVPOINTER  AND SAVE
        ;LDX    DCBPOINTER        NOW COMPARE DEVICE NAME STRINGS
        LDX     DCBPOINTER
        ;LDX    DCB:NAME,X GET ADDRESS OF NON-DISK DEVICE NAME
        LDX     DCB:NAME,X
        BSR      CMPDVNAME GO SEE IF DEVICE NAME IS IN LIST
        BCC        FOUNDDEVICE      B/ WE FOUND IT!
        ;LDX    DCBPOINTER        NO MATCH, FIND NEXT ENTRY IN DCB LIST
        LDX     DCBPOINTER
        ;LDX    DCB:NEXTDCB,X       END OF DCB LIST HIT ?
        LDX     DCB:NEXTDCB,X
        BNE      FINDDEVICEL      B/ NO
        ;JSR    ERRET   NOT A VALID DEVICE NAME
        JSR     ERRET
        FDB      ERR:NOSUCHDEVICE
        PAGE
*
*       NO DEVICE NAME, ASSUME A FILE ON DEFAULT DISK DRIVE
*
FINDDEFAULT      EQU     *
        ;LDX    CODE+SDOS:IOBLOCKPTR       SET NAMESIZE BACK TO USER-SUPPLIED SIZE
        LDX     CODE+SDOS:IOBLOCKPTR
        ;LDX    SCBLK:WRLEN,X
        LDX     SCBLK:WRLEN,X
        STX     NAMESIZE (INDICATES 0 BYTES MATCHED A DEVICE NAME)
        ;LDX    DEFAULTDISKDCB     GET POINTER TO DEFAULT DISK INFO TABLE
        LDX     DEFAULTDISKDCB
        STX     DCBPOINTER
FOUNDDISK1      EQU     *
        ;LDX    #DISKFILEDRIVER SET UP POINTER TO SDOS DISK FILE DRIVER
        LDX     #DISKFILEDRIVER
FOUNDDISK2      EQU     *
        STX     DRIVERVPOINTER  AND SAVE WHICH DISK DRIVER TO USE!
FOUNDDEVICE      EQU     *
        ;LDX    CODE+SDOS:IOBLOCKPTR       COMPUTE LENGTH OF DEVICE PREFIX
        LDX     CODE+SDOS:IOBLOCKPTR
        ;LDD    SCBLK:WRLEN,X     = USER SUPPLIED LENGTH - # OF BYTES REMAINING AFTER MATCH
        LDAB      (SCBLK:WRLEN)+1,X
        LDAA      SCBLK:WRLEN,X
        ;SUBD    NAMESIZE
        SUBB      NAMESIZE+1
        SBCA       NAMESIZE
        ;LDX    SCBLK:RDBUF,X      PUT SIZE OF SCANNED DEVICE NAME IN REPLY BUFFER
        LDX     SCBLK:RDBUF,X
        ;STD    0,X
        STAB      (0)+1,X
        STAA      0,X
        RTS
*
FOUNDDISK       EQU     *
        ;LDX    NAMESIZE NULL FILENAME?
        LDX     NAMESIZE
        BEQ      FOUNDDISK3      B/ YES, HE SPECIFIED ONLY A DISK
        ;LDX    NAMESCANPTR        LOOK AT 1ST BYTE FOLLOWING DISK NAME
        LDX     NAMESCANPTR
        LDAA      0,X
        ;CMPA     #ASCII:SPACE        A NON-BLANK PRINTING CHARACTER?
        CMPA      #ASCII:SPACE
        BHI      FOUNDDISK1      B/ YES, FILENAME HAS BEEN SPECIFIED
FOUNDDISK3      ; ONLY NAME OF DISK DEVICE SPECIFIED
        ;LDX    #DISKDEVICEDRIVER
        LDX     #DISKDEVICEDRIVER
        BRA       FOUNDDISK2

DEFAULTDISKNAME   FCC       "DISK:"
        FCB       0
        PAGE
*       CMPDVNAM -- COMPARE FILENAME TO DEVICE NAME
*       (X) POINTS TO DEVICE NAME ENDED BY 0
*       FILENAME TO MATCH AGAINST IS SELECTED BY SYSCALL
*       EXIT WITH CARRY RESET IF FOUND
*       NAMESCANPTR IS ADVANCED PAST DEVICE NAME IF FOUND
*       CARRY SET IF NOT FOUND
*       SETS NAMESIZE TO # BYTES OF FILENAME GIVEN MINUS SIZE OF DEVICE NAME PREFIX
*
CMPDVNAME ; COMPARE FILENAME TO DEVICE NAME
        STX     TEMPX   SAVE POINTER TO NAME IN DCB
        ;LDX    CODE+SDOS:IOBLOCKPTR       GET SIZE OF USER-SPECIFIED FILE NAME
        LDX     CODE+SDOS:IOBLOCKPTR
        ;LDX    SCBLK:WRLEN,X
        LDX     SCBLK:WRLEN,X
        STX     NAMESIZE
        BEQ      CMPDVNAMENF       B/ ZERO LENGTH --> NOT FOUND!
        ;LDX    CODE+SDOS:IOBLOCKPTR       GET POINTER TO USER-SPECIFIED FILE NAME
        LDX     CODE+SDOS:IOBLOCKPTR
        ;LDX    SCBLK:WRBUF,X
        LDX     SCBLK:WRBUF,X
        STX     NAMESCANPTR
CMPDVNAML ; COMPARE NEXT BYTE OF USER-SPECIFIED NAME WITH DEVICE NAME
        ;LDX    NAMESCANPTR        GET BYTE FROM USER-SPECIFIED NAME
        LDX     NAMESCANPTR
        ;LDA     ,X+
        LDAA      0,X
        INX
        STX     NAMESCANPTR
        ;CMPA     #$60    FOLD TO UPPER CASE IF LOWER CASE
        CMPA      #$60
        BLS      CMPDVNAML1        B/ NOT LOWER CASE
        ;CMPA     #$7A
        CMPA      #$7A
        BHI      CMPDVNAML1        B/ NOT LOWER CASE
        ANDA      #%01011111      FOLD IT!
CMPDVNAML1 ; FOLDED CHARACTER OF USER SPECIFIED NAME IN (A)
        ;LDX    TEMPX   COMPARE TO NEXT BYTE OF DCB NAME
        LDX     TEMPX
        ;CMPA     ,X      CHARACTERS MATCH?
        CMPA      0,X
        BNE      CMPDVNAMENM       B/ NO, END OF DCB NAME ?
        INX             BUMP POINTER
        STX     TEMPX   UPDATE DCB NAME SCAN POINTER
        ;LDX    NAMESIZE EXHAUSTED USER-SPECIFIED NAME?
        LDX     NAMESIZE
        DEX             (REMEMBER THAT WE HAVE LOOKED AT ANOTHER BYTE)
        STX     NAMESIZE
        BNE      CMPDVNAML B/ NO, COMPARE NEXT BYTE
CMPDVNAMEZ        ; USER-SPECIFIED NAME IS EXHAUSTED
        ;LDA     [TEMPX] AT END OF DCB-SPECIFIED NAME ?
        LDX     TEMPX
        LDAA      0,X
        BNE      CMPDVNAMENF       B/ NO, USER NAME DOESN'T MATCH DCB NAME
        ;LDX    NAMESCANPTR        YES, GET POINTER TO UNSCANNED PART OF USER NAME
        LDX     NAMESCANPTR
        OKRTS           AND SIGNAL 'MATCH!'

CMPDVNAMENF       ; USER FILE NAME DOESN'T START WITH THIS DEVICE NAME
        ERRORRTS                SAY "NO MATCH"

CMPDVNAMENM       ; NAME DOESN'T MATCH
        ;LDX    NAMESCANPTR        BACK UP THE SCAN POINTER
        LDX     NAMESCANPTR
        DEX
        STX     NAMESCANPTR
        BRA       CMPDVNAMEZ
        PAGE     SYSCALL:INTERLOCK/SYSCALL:DELAY HANDLERS
*
*       INTERLOCK -- PERFORM SYSCALL:INTERLOCK
*       (EXECUTE A NO-OP SINCE SINGLE USER SYSTEMS CANNOT INTERLOCK!)
*
INTERLOCK
        ;JSR    CHECKWRLEN        MAKE SURE WRITE BUFFER IS SUPPLIED
        JSR     CHECKWRLEN
        FDB      16      AND THAT IT IS THE PROPER LENGTH
        ;LDA     INTERLOCK:FUNCTION+1,X    GET INTERLOCK OPCODE
        LDAA      INTERLOCK:FUNCTION+1,X
        ;CMPA     #IC:CREATE A CREATE CALL?
        CMPA      #IC:CREATE
        BNE      INTERLOCKOKRTS   B/ NO, JUST EXIT
        ;JSR    CHECKRDLEN        YES, MAKE SURE A REPLY BUFFER IS GIVEN
        JSR     CHECKRDLEN
        FDB      16
INTERLOCKOKRTS
        OKRTS
*
*       DELAY -- PERFORM SYSCALL:DELAY
*
DELAY
        ;LDX    CODE+SDOS:IOBLOCKPTR       FETCH DELAY PERIOD
        LDX     CODE+SDOS:IOBLOCKPTR
        ;LDX    DELAY:PERIOD,X
        LDX     DELAY:PERIOD,X
        BNE      DELAY1   B/ DON'T DEFUSE 12 HOUR DELAY
        ;LDX    #DELAYDONE       SECRET DELAY SIGNAL PASSED, DEFUSE 12 HOUR TIMEOUT BOMB
        LDX     #DELAYDONE
        STX     DELAYBLOCK+TIMEOUT:ROUTINE
        OKRTS

DELAY1   ;CLR     DELAYCOMPLETE     RESET DELAY COMPLETED EVENT
        CLR      DELAYCOMPLETE
        STX     DELAYBLOCK+TIMEOUT:FUSE    SET FUSE TO DESIRED DELAY
        ;LDX    #DELAYCOMPLETE    NOW WAIT FOR DELAY COMPLETE EVENT
        LDX     #DELAYCOMPLETE
        ;JSR    WAITEVENT$
        JSR     WAITEVENT$
        OKRTS
*
*       SDOS NOT REGISTERED TIME BOMB
*
SDOSNOTREGISTERED
        ;LDX    #$FFFF  SET UP 18.2 MINUTE TIMEOUT AGAIN
        LDX     #$FFFF
        STX     DELAYBLOCK+TIMEOUT:FUSE
        ;LDA     DELAYCOMPLETE     HAVE 12 HOURS PASSED YET ?
        LDAA      DELAYCOMPLETE
        ;CMPA     #12*60//18      (= THIS MANY 18.5 MINUTE TIMEOUTS ?)
        CMPA      #12*60//18
        BLS      DELAYDONE        B/ ...TICK... NOT YET
        ;LDX    #EXITCHAIN-9      *** BANG! **** MODIFY EXIT TO DISPLAY ERROR NEXT TIME
        LDX     #EXITCHAIN-9
        ;LDD    #ERR:SDOSNOTREGISTERED+1206     WHAT TO DISPLAY ON NEXT EXIT
        LDAB      #(ERR:SDOSNOTREGISTERED+1206)&$FF
        LDAA      #(ERR:SDOSNOTREGISTERED+1206)/256
        ;SUBD    #1206   FIX UP NON-OBVIOUS CONSTANT TO CORRECT VALUE
        SUBB      #(1206)&$FF
        SBCA       #(1206)/256
        ;STD    ERROREXIT:CODE+9,X       MAKE "CHAIN DEFPGM" INTO "ERROREXIT"
        STAB      (ERROREXIT:CODE+9)+1,X
        STAA      ERROREXIT:CODE+9,X
        ;SUBD    #ERR:SDOSNOTREGISTERED-(SYSCALL:ERROREXIT*256+ERROREXIT:SCLEN)
        SUBB      #(ERR:SDOSNOTREGISTERED-(SYSCALL:ERROREXIT*256+ERROREXIT:SCLEN))&$FF
        SBCA       #(ERR:SDOSNOTREGISTERED-(SYSCALL:ERROREXIT*256+ERROREXIT:SCLEN))/256
        ;STD    SCBLK:OPCODE+9,X
        STAB      (SCBLK:OPCODE+9)+1,X
        STAA      SCBLK:OPCODE+9,X
DELAYDONE ; DELAY IS DONE, SIGNAL COMPLETION OF DELAY EVENT
        ;INC     DELAYCOMPLETE     MARK THE EVENT
        INC      DELAYCOMPLETE
        ;JMP    IORTI
        JMP     IORTI
        PAGE     MAJOR CHANNEL OPERATIONS
*       OPEN -- PERFORM "SYSCALL:OPEN"
*
OPEN    EQU     *
*
*       HERE'S WHERE WE DO THE COPYRIGHT CHECK
*
        ;LDX    #COPYRIGHTEND-1-98       COMPUTE CHECKSUM BACKWARDS
        LDX     #COPYRIGHTEND-1-98
        LDAA      #(-COPYRIGHTCHECKSUM)&$FF
OPEN1   ADDA      98,X
        DEX
        CPX      #COPYRIGHT-98-1
        BNE      OPEN1
*
*       IF A USER CHANGED THE COPYRIGHT STRING CHECKSUM...
*       WE WILL COMPUTE AN ADDRESS CORRESPONDING TO SDOSSTACK
*       IF THE CHECKSUM IS OK, WE WILL COMPUTE AN ADDRESS
*       CORRESPONDING TO SDOSSTACK+2
*
*       INTO THIS MAGIC COMPUTED ADDRESS, WE WILL
*       PLACE THE MANUFACTURED ADDRESS OF EXITDAMAGE (A CRITICAL PLACE)
*       THE RESULT IS TO HAVE EXIT AND CHAIN LOAD UP A BAD STACK POINTER
*       WHICH WILL EVENTUALLY DESTROY EXITDAMAGE
*       WHICH WILL EVENTUALLY BRING DOWN THE SYSTEM (WE HOPE)
*       ALL OF THIS IS TO TRY TO PREVENT THEFT
*
        SUBA      #1      IF YOU DON'T UNDERSTAND THIS, IMAGINE A GUY DISASSEMBLING IT!
        LDAA      #0      USE THE Z-BIT TO FORM AN ADDRESS
        LDAA      #1	  ;ZZZ ADCA       #0      = 1 IF CHECKSUM OK, = 0 OTHERWISE
        CLRB
        ADDA      #((SDOSSTACK-34)/2)&$FF   THIS IS PURPOSELY DONE WIERD
        ADCB       #((SDOSSTACK-34)/2)/256   TO DEFEAT WOULD BE DISASSEMBLERS AND THEIVES
        ASLA
        ROLB
        PSHA
        PSHB
        ;LDD    EXITDAMAGEPTR
        LDAB      EXITDAMAGEPTR+1
        LDAA      EXITDAMAGEPTR
        ASLA              THIS CODE DOES FUNNY THINGS...
        ROLB             TO CONFUSE WOULD-BE DISASSEMBLERS AND THEIVES
        ADDA      #22
        ADCB       #0
        ;LDX    ,S++
        TSX
        LDX     0,X
        INS
        INS
        STAA      35,X
        STAB      34,X
*
*       END OF COPYRIGHT CHECK
*
        ;JSR    FNAMEPROCESS      PROCESS THE FILE NAME TO GET THE DRIVER ADDRESS
        JSR     FNAMEPROCESS
        ;JSR    [DRIVER:OPEN,X] GO OPEN THE FILE
        LDX     DRIVER:OPEN,X
        JSR     0,X
        BCS       OPENERRED       B/ DRIVER GOT AN ERROR ON OPEN
OPEN2   EQU     *
        ;LDD    DRIVERVPOINTER  GET PTR TO DEVICE DRIVER VECTOR
        LDAB      DRIVERVPOINTER+1
        LDAA      DRIVERVPOINTER
        ;LDX    IOCBPOINTER
        LDX     IOCBPOINTER
        ;STD    IOCB:DRIVER,X     SAVE IN OPEN CHANNEL TABLE
        STAB      (IOCB:DRIVER)+1,X
        STAA      IOCB:DRIVER,X
*
*       PLANTDCBINIOCB -- SET DCB POINTER INTO IOCB
*
PLANTDCBINIOCB       EQU     *
        ;LDX    IOCBPOINTER       GET IOCB ADDRESS
        LDX     IOCBPOINTER
        ;LDD    DCBPOINTER        SAVE DCB ADDRESS IN IOCB, TOO!
        LDAB      DCBPOINTER+1
        LDAA      DCBPOINTER
        ;STD    IOCB:DCB,X
        STAB      (IOCB:DCB)+1,X
        STAA      IOCB:DCB,X
        CLC
OPENERRED
        RTS
        PAGE
*
*       CREATELOG -- PERFORM "SYSCALL:CREATELOG"
*
CREATELOG EQU     *
        ;LDX    #LOGIOCB  SET UP IOCBPOINTER...
        LDX     #LOGIOCB
        STX     IOCBPOINTER       AS THOUGH "CHECKCHANNELCLOSED" HAD BEEN CALLED
        ;JSR    CHECKCHANNELCL1      MAKE SURE THAT LOG CHANNEL IS CLOSED
        JSR     CHECKCHANNELCL1
        BSR      FNAMEPROCESS1     TO FIND DRIVER ADDRESS
        BRA       CREATE1   AND GO CREATE THE FILE
*
*       CREATE -- PERFORM "SYSCALL:CREATE"
*
CREATE    EQU     *
        BSR      FNAMEPROCESS      PROCESS CHANNEL NUMBER AND FILE NAME
CREATE1   EQU     *
        ;JSR    [DRIVER:CREATE,X] GO CREATE THE FILE
        LDX     DRIVER:CREATE,X
        JSR     0,X
        BCC        OPEN2   OPEN THE CHANNEL
        RTS             OOPS, EXIT WITH ERROR
*
*       DELETE -- PERFORM "SYSCALL:DELETE"
*
DELETE  EQU     *
        ;JSR    FNAMEPROCESS1     GO PARSE FILENAME TO DETERMINE DRIVER ADDRESS
        JSR     FNAMEPROCESS1
        ;JMP    [DRIVER:DELETE,X]       NOW DELETE THE FILE
        LDX     DRIVER:DELETE,X
        JMP     0,X
*
*       READB -- PERFORM "SYSCALL:READB"
*
READB     ;JSR    CHECKCHANNELOPEN
        JSR     CHECKCHANNELOPEN
        ;JMP    [DRIVER:READB,X]  INVOKE THE DRIVER TO DO THE WORK
        LDX     DRIVER:READB,X
        JMP     0,X
*
*       WRITEB -- PERFORM "SYSCALL:WRITEB"
*
WRITEB   ;JSR    CHECKCHANNELOPEN
        JSR     CHECKCHANNELOPEN
        CPX      CONSOLEDRIVER    DON'T WRITE IF CHANNEL 0 AND NOT CONSOLE!
        BEQ      WRITEB1  B/ OK TO WRITE
        ;LDX    CODE+SDOS:IOBLOCKPTR       ISN'T CONSOLE, IS THIS CHANNEL ZERO ?
        LDX     CODE+SDOS:IOBLOCKPTR
        ;LDA     WRITEB:CHANNEL,X   ...?
        LDAA      WRITEB:CHANNEL,X
        BEQ      WRITEBOKRTS      B/ YES, DON'T DO THE WRITE!
        ;LDX    DRIVERVPOINTER  NOPE, MUST DO THE WRITE
        LDX     DRIVERVPOINTER
WRITEB1
        ;JMP    [DRIVER:WRITEB,X]
        LDX     DRIVER:WRITEB,X
        JMP     0,X
        PAGE
*       FNAMEPROCESS -- CHECK TO MAKE SURE CHANNEL IS CLOSED
*       LOCATE DRIVER AND STRIP OFF DEVICE NAME
*       BUILDS COPY OF SYSCALL IN IOBLOCK
*       EXCEPT THAT FILENAME POINTER HAS BEEN STEPPED PAST DEVICE NAME PREFIX
*       ASSUMES THAT A FILENAME SYSCALL WITH SCLEN=SCLEN:DATA WAS PASSED BY USER
*
FNAMEPROCESS      ; ENTRY POINT FOR OPEN/CREATE
        ;JSR    CHECKCHANNELCLOSED   AND LOCATE THE IOCB FOR THE SPECIFIED CHANNEL
        JSR     CHECKCHANNELCLOSED
FNAMEPROCESS1     ; ENTRY POINT FOR OTHER FILENAME SYSCALLS
        ;JSR    CHECKRDLEN        MAKE SURE READ-BACK BUFFER HAS AT LEAST 2 BYTES
        JSR     CHECKRDLEN
        FDB      2       TO PLACE SIZE OF FILENAME INTO
        ;JSR    FINDDRIVER      SPECIFIED BY FILENAME STRING
        JSR     FINDDRIVER
        ;LDX    DRIVERVPOINTER  FOR CONVENIENCE OF EVERYBODY ELSE
        LDX     DRIVERVPOINTER
WRITEBOKRTS
        OKRTS           AND EXIT
        PAGE
*       DISKDEFAULT -- PERFORM "SYSCALL:DISKDEFAULT"
*
DISKDEFAULT      EQU     *
        BSR      FNAMEPROCESS1     GO PROCESS FILE NAME TO GET DEVICE NAME
        CPX      #DISKDEVICEDRIVER        THIS IS ONLY LEGAL DRIVER THAT CAN RESULT
        BNE      ERRMUSTBEDISK    B/ SPECIFIED OTHER THAN DISK DEVICE
        ;LDX    DCBPOINTER        USE THIS DISK INFO TABLE FOR DEFAULT FROM NOW ON
        LDX     DCBPOINTER
        STX     DEFAULTDISKDCB     !
        OKRTS           HOW EASY!
CLOSERTS EQU     *-1

ERRMUSTBEDISK    EQU     *
        ;JSR    ERRET
        JSR     ERRET
        FDB      ERR:MUSTBEDISK
*
*       CLOSE -- PERFORM "SYSCALL:CLOSE"
*
CLOSE    ;JSR    CHECKCHANNELOPEN
        JSR     CHECKCHANNELOPEN
        ;JSR    [DRIVER:CLOSE,X]
        LDX     DRIVER:CLOSE,X
        JSR     0,X
        BCC        CLOSE1   B/ NO ERROR
        ;JSR    ERRORSAVE        GO SET THE ERROR
        JSR     ERRORSAVE
*       THE FOLLOWING CODE DOES NOT FIDDLE THE CARRY BIT
*       DON'T FOOL AROUND WITH IT, OR ELSE...
CLOSE1   ;LDX    IOCBPOINTER
        LDX     IOCBPOINTER
        LDAA      #0
        STAA      IOCB:DRIVER,X
        STAA      IOCB:DRIVER+1,X
        BCC        CLOSERTS (OKRTS)
        ;JMP    ERRORED
        JMP     ERRORED
*
*       CLOSELOG -- PERFORM "SYSCALL:CLOSELOG"
*
CLOSELOG ;LDX    #LOGCLOSE
        LDX     #LOGCLOSE
        ;JMP    SYSCALLENTRY
        JMP     SYSCALLENTRY
*
LOGCLOSE FCB       SYSCALL:CLOSE      FUNCTION
        FCB       CLOSE:SCLEN
        FCB       LOGCHANNEL        CHANNEL
        PAGE
*
*       RENAME -- PERFORM "SYSCALL:RENAME"
*
RENAME   EQU     *
        ;JSR    CHECKCHANNELOPEN    OR YOU'RE DEAD!
        JSR     CHECKCHANNELOPEN
        ;JSR    FNAMEPROCESS1     TO FIND OUT THE DEVICE DRIVER
        JSR     FNAMEPROCESS1
        ;LDX    IOCBPOINTER       RENAME TO SAME DEVICE ?
        LDX     IOCBPOINTER
        ;LDX    IOCB:DRIVER,X     ...?
        LDX     IOCB:DRIVER,X
        CPX      DRIVERVPOINTER  ...?
        BNE      ERRRENAMEDEVICE   B/ TO DIFFERENT DEVICE, I CAN'T ALLOW THAT...
        CPX      #DISKFILEDRIVER IS THIS THE DISK FILE DRIVER ?
        BNE      RENAME1  B/ NO
        ;LDX    IOCBPOINTER       RENAME A FILE ON ONE DISK TO ANOTHER DISK ?
        LDX     IOCBPOINTER
        ;LDX    IOCB:DCB,X  ...?
        LDX     IOCB:DCB,X
        CPX      DCBPOINTER        ...?
        BNE      ERRRENAMEDEVICE   B/ YES, THAT'S ILLEGAL TOO!
RENAME1  EQU     *
        ;LDX    DRIVERVPOINTER  GO DO THE RENAME
        LDX     DRIVERVPOINTER
        ;JMP    [DRIVER:RENAME,X]
        LDX     DRIVER:RENAME,X
        JMP     0,X

ERRRENAMEDEVICE   EQU     *
        ;JSR    ERRET
        JSR     ERRET
        FDB      ERR:RENAMEDEVICE
        PAGE
READAEOF  ; RE-CAUSE EOF ERROR
        ;JSR    ERRET
        JSR     ERRET
        FDB      ERR:EOFHIT
*
*       READA -- PERFORM "SYSCALL:READA"
*
READA     ;JSR    CHECKCHANNELOPEN
        JSR     CHECKCHANNELOPEN
        ;JSR    [DRIVER:READA,X]  ISSUE THE READ
        LDX     DRIVER:READA,X
        JSR     0,X
        ;LBCC      READALOG  B/ ALL OK, SEE IF WE LOG IT
        BCS       MACRO:0009
        JMP     READALOG
MACRO:0009
        ;PSHX           SAVE THE ERROR CODE
        STX     TEMPX
        LDAB      TEMPB
        PSHB
        LDAB      TEMPA
        PSHB
        ;JSR    READALOG  LOG WHAT WAS COLLECTED SO FAR
        JSR     READALOG
        BCS       *+2     WE CAN ONLY RECOVER FROM 1 ERROR, LOSE THE 2ND
        ;PULX           GET ORIGINAL ERROR CAUSE
        TSX
        LDX     0,X
        INS
        INS
        CPX      #ERR:EOFHIT     DID WE HIT EOF?
        ;LBNE    ERRORINX        B/ NO, SOME OTHER ERROR
        BEQ      MACRO:000A
        JMP     ERRORINX
MACRO:000A
        ;LDX    USERSYSCALLPTR    EOF ON CHANNEL 0 ?
        LDX     USERSYSCALLPTR
        LDAA      READA:CHANNEL,X     (GRAB THE CHANNEL NUMBER)
        BNE      READAEOF  B/ NO, EOF ON A NON-ZERO CHANNEL!
        ;JSR    ISCONSOLE        IS CHANNEL ZERO OPEN TO THE CONSOLE?
        JSR     ISCONSOLE
        BCC        READAEOF  B/ YES, PASS EOF ERROR BACK TO CALLER
        ;LDX    #CLOSECHANNEL0     CLOSE CHANNEL 0
        LDX     #CLOSECHANNEL0
        ;JSR    SYSCALLENTRY
        JSR     SYSCALLENTRY
        ;LDX    LOGIOCB+IOCB:DRIVER IS LOG CHANNEL OPEN ?
        LDX     LOGIOCB+IOCB:DRIVER
        BEQ      READA2    B/ NO, LEAVE IT ALONE!
        CPX      CONSOLEDRIVER    YES, OPEN TO THE CONSOLE ?
        BNE      READA2    B/ NO, LEAVE IT ALONE!
        ;JSR    CLOSELOG YES, CLOSE THE LOG FILE!
        JSR     CLOSELOG
READA2    EQU     *
        ;JSR    OPENCONSOLE      RE-OPEN CHANNEL 0 TO THE CONSOLE
        JSR     OPENCONSOLE
*
*       BUILD NEW "READA" REQUEST IN "IOBLOCK" TO...
*       READ REMAINDER OF INPUT REQUEST
*
        ;LDX    #SYSCALL:READA*256+READA:SCLEN SET UP SYSCALL OPCODE AND LENGTH
        LDX     #SYSCALL:READA*256+READA:SCLEN
        STX     IOBLOCK+SCBLK:OPCODE
        ;LDX    USERSYSCALLPTR    COMPUTE NEW BUFFER POINTER
        LDX     USERSYSCALLPTR
        ;LDD    READA:ACTUALCOUNT,X
        LDAB      (READA:ACTUALCOUNT)+1,X
        LDAA      READA:ACTUALCOUNT,X
        ;ADDD    READA:BUFFERP,X
        ADDB      (READA:BUFFERP)+1,X
        ADCA       READA:BUFFERP,X
        ;STD    IOBLOCK+READA:BUFFERP
        STAB      IOBLOCK+READA:BUFFERP+1
        STAA      IOBLOCK+READA:BUFFERP
        ;LDD    READA:MAXCOUNT,X    COMPUTE NEW MAX COUNT
        LDAB      (READA:MAXCOUNT)+1,X
        LDAA      READA:MAXCOUNT,X
        ;SUBD    READA:ACTUALCOUNT,X
        SUBB      (READA:ACTUALCOUNT)+1,X
        SBCA       READA:ACTUALCOUNT,X
        ;STD    IOBLOCK+READA:MAXCOUNT
        STAB      IOBLOCK+READA:MAXCOUNT+1
        STAA      IOBLOCK+READA:MAXCOUNT
        LDAA      READA:LMFLAG,X
        ;LDX    #IOBLOCK
        LDX     #IOBLOCK
        STAA      READA:LMFLAG,X
        ;CLR     READA:CHANNEL,X
        CLR      READA:CHANNEL,X
        ;CLR     READA:ACTUALCOUNT,X   ZERO THE ACTUAL # BYTES MOVED
        CLR      READA:ACTUALCOUNT,X
        ;CLR     READA:ACTUALCOUNT+1,X
        CLR      READA:ACTUALCOUNT+1,X
        STX     CODE+SDOS:IOBLOCKPTR
        ;LDX    DRIVERVPOINTER  STILL VALID BECAUSE OF OPENCONSOLE
        LDX     DRIVERVPOINTER
        ;JSR    [DRIVER:READA,X]  ISSUE READ TO CONSOLE
        LDX     DRIVER:READA,X
        JSR     0,X
        ;LBCS     ERRORINX        ERROR IN FINISHING THE READ!
        BCC        MACRO:000B
        JMP     ERRORINX
MACRO:000B
READA1    ;LDX    USERSYSCALLPTR    DOCTOR UP THE ORIGINAL I/O BLOCK
        LDX     USERSYSCALLPTR
        ;LDD    READA:ACTUALCOUNT,X   (ADJUSTS THE # BYTES XFERRED BY 2ND AND LATER "READAS"...
        LDAB      (READA:ACTUALCOUNT)+1,X
        LDAA      READA:ACTUALCOUNT,X
        ;ADDD    IOBLOCK+READA:ACTUALCOUNT       DONE BECAUSE OF "EOFHIT"S ON CHANNEL ZERO)
        ADDB      IOBLOCK+READA:ACTUALCOUNT+1
        ADCA       IOBLOCK+READA:ACTUALCOUNT
        ;STD    READA:ACTUALCOUNT,X
        STAB      (READA:ACTUALCOUNT)+1,X
        STAA      READA:ACTUALCOUNT,X
*
*       LOG THE CHANNEL ZERO ACTIVITY
*
READALOG  EQU     *
        ;LDX    CODE+SDOS:IOBLOCKPTR       SET UP WRITE BUFFER DATA...
        LDX     CODE+SDOS:IOBLOCKPTR
        ;LDD    READA:ACTUALCOUNT,X   FOR LOG SYSCALL BLOCK...
        LDAB      (READA:ACTUALCOUNT)+1,X
        LDAA      READA:ACTUALCOUNT,X
        ;LDX    READA:BUFFERP,X    IN CASE WE ARE LOGGING
        LDX     READA:BUFFERP,X
WRITEALOG        ; ENTRY POINT FOR WRITEA TO HANDLE LOGGING
        ;STD    LOGOUT+WRITEA:COUNT       SAVE LENGTH OF STUFF TO WRITE TO LOG
        STAB      LOGOUT+WRITEA:COUNT+1
        STAA      LOGOUT+WRITEA:COUNT
        STX     LOGOUT+WRITEA:BUFFERP     SAVE LOCATION OF DATA TO LOG
        BSR      DOWELOG OUTPUT DUPLICATE OF READ/WRITE DATA TO LOG DEVICE ?
        BCC        READARTS  B/ NOT LOGGING
        ;LDX    CODE+SDOS:IOBLOCKPTR       SET UP TO WRITE TO LOG DEVICE
        LDX     CODE+SDOS:IOBLOCKPTR
        ;LDA     SCBLK:WLEN,X      COPY LENGTH OF SYSCALL BLOCK
        LDAA      SCBLK:WLEN,X
        ANDA      #$7F    MASK OFF "NO WAIT" BIT
        ;CMPA     #RWPOSITION:SCLEN        LONGER THAN LONGEST REASONABLE ?
        CMPA      #RWPOSITION:SCLEN
        BLS      READALOG0 B/ NOPE
        ;LDA     #RWPOSITION:SCLEN        YES, SHORTEN TO SIZE SET ASIDE FOR LOG BLOCK
        LDAA      #RWPOSITION:SCLEN
READALOG0
        ;STA     LOGOUT+SCBLK:WLEN SET SIZE OF LOG REQUEST
        STAA      LOGOUT+SCBLK:WLEN
        ;LDD    RW:POSITION,X   COPY POSITION FROM ORIGINAL BLOCK...
        LDAB      (RW:POSITION)+1,X
        LDAA      RW:POSITION,X
        ;STD    LOGOUT+RW:POSITION      IN CASE IT WAS SUPPLIED
        STAB      LOGOUT+RW:POSITION+1
        STAA      LOGOUT+RW:POSITION
        ;LDX    RW:POSITION+2,X
        LDX     RW:POSITION+2,X
        STX     LOGOUT+RW:POSITION+2
        ;LDX    #LOGOUT SEND COPY TO LOG CHANNEL
        LDX     #LOGOUT
        ;JMP    SYSCALLENTRY
        JMP     SYSCALLENTRY

CLOSECHANNEL0      FCB       SYSCALL:CLOSE
        FCB       CLOSE:SCLEN
        FCB       0       CHANNEL
        PAGE
*       CHECK IF WE ARE LOGGING
*       C SET IF YES, CLEAR IF NO
*
DOWELOG ;LDX    CODE+SDOS:IOBLOCKPTR
        LDX     CODE+SDOS:IOBLOCKPTR
        IF      READA:CHANNEL#WRITEA:CHANNEL
        ?DOWELOG WON'T WORK?
        FIN
        LDAA      READA:CHANNEL,X     IS IT CHANNEL 0?
        BNE      DONTLOG B/ NO, DON'T LOG
        ;LDX    LOGIOCB+IOCB:DRIVER IS THE LOG FILE OPEN?
        LDX     LOGIOCB+IOCB:DRIVER
        BEQ      DONTLOG B/ NO, DON'T LOG
        SEC              "WE ARE LOGGING"
        RTS
DONTLOG CLC               "WE ARE NOT LOGGING"
READARTS  RTS
        PAGE
*
*       WRITEA -- PERFORM "SYSCALL:WRITEA"
*
WRITEA   ;JSR    CHECKCHANNELOPEN
        JSR     CHECKCHANNELOPEN
        CPX      CONSOLEDRIVER    DON'T WRITE IF IS CHANNEL 0 AND IS NOT CONSOLE!
        BEQ      WRITEA0  B/ IS CONSOLE, IS ALWAYS OK TO WRITE
        ;LDX    CODE+SDOS:IOBLOCKPTR       NOT CONSOLE, IS THIS CHANNEL 0 ?
        LDX     CODE+SDOS:IOBLOCKPTR
        ;LDA     WRITEA:CHANNEL,X   ...?
        LDAA      WRITEA:CHANNEL,X
        BEQ      WRITEA1  B/ YES, DON'T DO WRITE, WOULD DAMAGE "DO" FILE!
        ;LDX    DRIVERVPOINTER  MUST DO WRITE, GET POINTER TO DRIVER VECTOR
        LDX     DRIVERVPOINTER
WRITEA0
        ;JSR    [DRIVER:WRITEA,X]        GO DO THE WRITE
        LDX     DRIVER:WRITEA,X
        JSR     0,X
        BCS       READARTS  B/ ERROR, GIVE UP NOW!
WRITEA1  ;LDX    CODE+SDOS:IOBLOCKPTR       SET UP TO HANDLE LOGGING
        LDX     CODE+SDOS:IOBLOCKPTR
        ;LDD    WRITEA:COUNT,X    GET NUMBER OF BYTES TO WRITE
        LDAB      (WRITEA:COUNT)+1,X
        LDAA      WRITEA:COUNT,X
        ;LDX    WRITEA:BUFFERP,X  AND WHERE TO WRITE THEM FROM
        LDX     WRITEA:BUFFERP,X
        BRA       WRITEALOG        GO SEE IF WE SHOULD LOG THIS DATA
        PAGE     MISCELLANEOUS SYSCALLS
*
*       CONTROL -- PERFORM "SYSCALL:CONTROL"
*
CONTROL  EQU     *
        BSR      STATUSCONTROL     DO ALL THE COMMON WORK
        ;JMP    [DRIVER:CONTROL,X]       CALL THE DRIVER
        LDX     DRIVER:CONTROL,X
        JMP     0,X
*
*       STATUSCONTROL -- COMMON SUBROUTINE FOR "CONTROL", "STATUS" SYSCALLS
*       IF OPERATION IS ON CHANNEL 0, IT IS AIMED AT LOG CHANNEL IF LOG IS OPEN
*       SETS UP (A) TO CONTAIN THE ACTUAL STATUS (CONTROL) REQUEST CODE
*       RETURNS (X) = DRIVERVPOINTER
*
STATUSCONTROL     EQU     *
        ;JSR    CHECKCHANNELOPEN    OR WE CAN'T DO ANYTHING AT ALL!
        JSR     CHECKCHANNELOPEN
        BSR      DOWELOG LOGGING ?
        BCC        STATUSCONTROL1    B/ NOT LOGGING
        STX     DRIVERVPOINTER  LOGGING, USE LOGIOCB'S DRIVER...
        ;LDX    #LOGIOCB  SET EVERYTHING ELSE UP...
        LDX     #LOGIOCB
        STX     IOCBPOINTER
        ;LDX    IOCB:DCB,X  AS THOUGH "OPEN" ON THE LOG CHANNEL...
        LDX     IOCB:DCB,X
        STX     DCBPOINTER        HAD BEEN PERFORMED
STATUSCONTROL1    EQU     *
        ;LDX    CODE+SDOS:IOBLOCKPTR       GET STATUS REQUEST CODE TO (A)
        LDX     CODE+SDOS:IOBLOCKPTR
        LDAA      STATUS:CODE,X
        ;LDX    DRIVERVPOINTER  GET DRIVER ADDRESS TO (X), AS PROMISED
        LDX     DRIVERVPOINTER
        OKRTS
*
*       STATUS -- PERFORM "SYSCALL:STATUS"
*
STATUS   EQU     *
        BSR      STATUSCONTROL     DO COMMON WORK
        ;JMP    [DRIVER:STATUS,X]        CALL THE DEVICE DRIVER
        LDX     DRIVER:STATUS,X
        JMP     0,X
        PAGE
*       DEBUG -- PERFORM "SYSCALL:DEBUG"
*       ASSERT: SDOSRECURSIVECALL=1 (I.E., SDOS ITSELF DOES NOT INVOKE THIS!)
*
DEBUG    ;LDX    CODE+SDOS:CONFIGURATION
        LDX     CODE+SDOS:CONFIGURATION
        ;LDX    CNFG:DEBUGGER,X   IS THERE A DEBUGGER?
        LDX     CNFG:DEBUGGER,X
        BEQ      DEBUG1   B/ NOPE
        ;LEAS    2,S     POP RETURN ADDRESS PUSHED BY "SYSCALL2"
        IF      2<0
        RPT     -2
        DES
        ELSE
        RPT     2
        INS
        FIN
        ;DEC     SDOSRECURSIVECALL  FLAG "NOT IN SDOS"
        DEC      SDOSRECURSIVECALL
        ;JMP    ,X      NOW ENTER THE DEBUGGER (RETURN VIA RTS)
        JMP     0,X

DEBUG1   EQU     *
        ;LDX    #ERR:NODEBUGGER  YOU GUESSED IT!
        LDX     #ERR:NODEBUGGER
        ;JMP    EXIT1   GO STICK USER WITH THIS ERROR
        JMP     EXIT1
*
*       ATTNCHECK -- PERFORM "SYSCALL:ATTNCHECK"
*
ATTNCHECK  ;LDX    CODE+SDOS:CONFIGURATION    DOES OKRTS IF OPERATOR INTERVENTION NO REQUIRED
        LDX     CODE+SDOS:CONFIGURATION
        ;JMP    [CNFG:ATTNCHECK,X]
        LDX     CNFG:ATTNCHECK,X
        JMP     0,X
*
*       SETERROR -- PERFORM "SYSCALL:SETERROR"
*
SETERROR        ;LDX    CODE+SDOS:IOBLOCKPTR
        LDX     CODE+SDOS:IOBLOCKPTR
        ;LDX    SETERROR:CODE,X
        LDX     SETERROR:CODE,X
        STX     USERSLASTERROR
WAITDONE ; FOR NOW, SINCE IT'S NOT REALLY IMPLEMENTED
        OKRTS
*
*       GETERROR -- PERFORM "SYSCALL:GETERROR"
*
GETERROR        EQU     *
        ;JSR    CHECKRDLEN        MAKE SURE READ BUFFER IS LARGE ENOUGH
        JSR     CHECKRDLEN
        FDB      2       2 BYTES OF ERROR CODE TO READ BACK
        ;LDD    USERSLASTERROR   COPY ERROR CODE TO READ BUFFER
        LDAB      USERSLASTERROR+1
        LDAA      USERSLASTERROR
        ;STD    [SCBLK:RDBUF,X]
        LDX     SCBLK:RDBUF,X
        STAB      1,X
        STAA      0,X
        OKRTS
        PAGE     ERROR DISPLAY
*       DISPLAYERROR -- DISPLAY "USERSLASTERROR" ON THE CONSOLE...
*       AS EITHER AN ERROR STRING FROM THE $ERRORMESSAGES FILE
*       OR AS "ERROR ddddd" IF WE CAN'T GET TO $ERRORMESSAGES SOMEHOW
*       IF WE CANNOT PRINT THE ERROR MESSAGE, CROAK AND DIE!
*       (EXAMINE "LASTERROR" IN SDOS:XXXX TO FIND OUT WHY)
*
DISPLAYERROR     ;LDX    USERSLASTERROR   DO IT NOW, IN CASE OF ERROR WHILE
        LDX     USERSLASTERROR
        STX     ERRORNUMBER      PROCESSING THIS ERROR
DISPLAYERRORRETRY ; TRY TO DISPLAY ERROR AGAIN
        ;JSR    OPENCONSOLE      MAKE SURE WE CAN OUTPUT THE ERROR MESSAGE
        JSR     OPENCONSOLE
        BCC        DISPLAYERRORA     B/ NO ERROR
        CPX      #ERR:CHBUSY       IS CHANNEL ALREADY OPEN ?
        BNE      *       LOOP IF NOT, CAN'T RECOVER!
DISPLAYERRORA     EQU     *
        ;JSR    DSKFOPENERRORFILE       TRY TO OPEN THE "ERRORMSGS.SYS" FILE
        JSR     DSKFOPENERRORFILE
        BCS       DISPLAYERROR4A    B/ CAN'T OPEN, GO DISPLAY ERROR IN NUMERIC FORMAT
*       NOW THE ERRORMSGS.SYS FILE IS OPEN!
*
*       POSITION TO THE ERROR MESSAGE POINTER
*       = 3 * ERROR NUMBER
*
        ;LDX    #DISPPOS1
        LDX     #DISPPOS1
        ;CLR     1,X     (0,X IS ASSEMBLED AS A ZERO!)
        CLR      1,X
        ;LDD    ERRORNUMBER
        LDAB      ERRORNUMBER+1
        LDAA      ERRORNUMBER
        ;ASLD            *2
        ASLB
        ROLA
        ROL     1,X
        ;ADDD    ERRORNUMBER      *3
        ADDB      ERRORNUMBER+1
        ADCA       ERRORNUMBER
        BCC        DISPLAYERROR0
        ;INC     1,X
        INC      1,X
DISPLAYERROR0    ;STD    2,X
        STAB      (2)+1,X
        STAA      2,X
        ;LDX    #DISPPOS        NOW POSITION ERRORMSGS.SYS FILE...
        LDX     #DISPPOS
        ;JSR    SYSCALLENTRY      TO THE ERROR MESSAGE STRING POINTER
        JSR     SYSCALLENTRY
        BCS       DISPLAYERROR4    B/ OOPS, SOME PROBLEM OCCURRED
        ;LDX    #DISPREADB3       READ IN THE STRING ADDRESS
        LDX     #DISPREADB3
        ;JSR    SYSCALLENTRY
        JSR     SYSCALLENTRY
        BCS       DISPLAYERROR4
        ;LDX    DISPPOS1+2      IS THE ERROR MSG IN THE FILE?
        LDX     DISPPOS1+2
        BNE      DISPLAYERROR1A    B/ YUP
        LDAA      DISPPOS1+1      ...?
        BEQ      DISPLAYERROR4    B/ NO, PRINT THE ERROR CODE THE HARD WAY
DISPLAYERROR1A    EQU     *
        ;LDX    #DISPPOS        POSITION TO THE STRING
        LDX     #DISPPOS
        ;JSR    SYSCALLENTRY
        JSR     SYSCALLENTRY
        BCS       DISPLAYERROR4    B/ ERROR
*
*       COPY THE STRING TO CHANNEL 0
*
DISPLAYERROR1    ;LDX    #DISPGETCHAR
        LDX     #DISPGETCHAR
        ;JSR    SYSCALLENTRY
        JSR     SYSCALLENTRY
        BCS       DISPLAYERROR4
        LDAA      BUFFER
        ;CMPA     #ASCII:CR
        CMPA      #ASCII:CR
        BEQ      DISPLAYERRORDONE B/ I'M DONE!
        ;LDX    #DISPPUTCHAR      NOT DONE, OUTPUT THIS CHARACTER TO CONSOLE
        LDX     #DISPPUTCHAR
        ;JSR    SYSCALLENTRY
        JSR     SYSCALLENTRY
        BCC        DISPLAYERROR1    B/ NO ERROR, GO OUTPUT NEXT CHARACTER
DISPERRKILLLOG  ; PERHAPS ERROR IS CAUSED BY LOG DEVICE
        BSR      DISPLAYERRORDONE CLOSE ERRORMSGS.SYS FILE TO KEEP THINGS NEAT
        ;JSR    CLOSELOG GET RID OF POTENTIAL SOURCE OF PROBLEM
        JSR     CLOSELOG
        BCC        DISPERRKILLLOG1 B/ MANAGED TO CLOSE LOG FILE!
        CPX      #ERR:CLOSED      FAIL BECAUSE ALREADY CLOSED ?
        BEQ      *       B/ YES, SITUATION IS HOPELESS...
DISPERRKILLLOG1 ; MANAGED TO CLOSE THE LOG FILE (PERHAPS WITH ERROR)
        ;LDX    #CLOSECHANNEL0     TURN OFF THE "DO" FILE
        LDX     #CLOSECHANNEL0
        ;JSR    SYSCALLENTRY
        JSR     SYSCALLENTRY
        BCS       *       B/ BUT IT WAS OPEN A MINUTE AGO!!!???
        BRA       DISPLAYERRORRETRY
*
*       CLOSE THE ERROR FILE (I'M DONE & ALL IS WELL)
*
DISPLAYERRORDONE ;LDX    #DISPCLOSE
        LDX     #DISPCLOSE
        ;JSR    SYSCALLENTRY
        JSR     SYSCALLENTRY
        BCS       *       IF ITS NOT PERFECT, I WON'T LET YOU PLAY WITH MY BALL!
        RTS
        PAGE
*       AN ERROR WAS DETECTED WHILE TRYING TO PRINT AN ERROR STRING
*       IGNORE THE ERROR, AND ATTEMPT TO PRINT "ERROR <ERRORNUMBER>" INSTEAD
*       (IN DECIMAL FORMAT)
*
DISPLAYERROR4    BSR      DISPLAYERRORDONE CLOSE THE ERROR FILE
DISPLAYERROR4A    EQU     *
        ;LDX    #DISPERROR
        LDX     #DISPERROR
        ;JSR    SYSCALLENTRY
        JSR     SYSCALLENTRY
        BCS       DISPERRKILLLOG  IF I CAN'T PRINT THE ERROR, WE DON'T GO NOWHERE!
        LDAB      #16     (16 BITS TO CONVERT)
        ;LDX    #DECBUF   CONVERT 16 BITS BINARY TO 3 DIGITS BCD
        LDX     #DECBUF
        ;CLR     0,X
        CLR      0,X
        ;CLR     1,X
        CLR      1,X
        ;CLR     2,X
        CLR      2,X
DISPLAYERROR5    EQU     *
        ASL      ERRORNUMBER-DECBUF+1,X
        ROL     ERRORNUMBER-DECBUF,X
        LDAA      2,X
        ADCA       2,X
        DAA
        STAA      2,X
        LDAA      1,X
        ADCA       1,X
        DAA
        STAA      1,X
        LDAA      0,X
        ADCA       0,X
        DAA
        STAA      0,X
        DECB
        BNE      DISPLAYERROR5
        LDAB      #3      (3 BYTES OF BCD)
DISPLAYERROR6    LDAA      2,X
        ANDA      #$F
        PSHA
        LDAA      2,X
        LSRA
        LSRA
        LSRA
        LSRA
        ANDA      #$F
        PSHA
        DEX
        DECB
        BNE      DISPLAYERROR6
        ;LDX    #STRINGBUFFER
        LDX     #STRINGBUFFER
        LDAA      #'0
        STAA      0,X
        LDAB      #6      (6 BYTES ON THE STACK)
DISPLAYERROR7
        PULA
        DECB
        BEQ      DISPLAYERROR9    B/ NO MORE (THEY WERE ALL ZERO)
        TSTA
        BEQ      DISPLAYERROR7    B/ ZERO SUPPRESS
DISPLAYERROR9    INCB
        BRA       DISPLAYERROR8A

DISPLAYERROR8
        PULA
DISPLAYERROR8A
        ADDA      #'0
        ;STA     ,X+
        STAA      0,X
        INX
        STAA      0,X
        DECB
        BNE      DISPLAYERROR8
        DEX
        STX     TEMPX   COMPUTE LENGTH OF THE STRING (ALWAYS < 256)
        LDAB      TEMPX+1
        SUBB      #(STRINGBUFFER&$FF)-1
        ;LDX    #DISPOUT
        LDX     #DISPOUT
        STAB      WRITEA:COUNT+1,X
        ;JSR    SYSCALLENTRY
        JSR     SYSCALLENTRY
        ;LBCS     DISPERRKILLLOG  ITS GOTTA BE PERFECT, OR I QUIT!
        BCC        MACRO:000C
        JMP     DISPERRKILLLOG
MACRO:000C
        RTS
*
DISPERRORMSG    FCC       'Error '
DISPERRORMSGL   EQU     *-DISPERRORMSG
*
DISPCLOSE        FCB       SYSCALL:CLOSE      FUNCTION
        FCB       CLOSE:SCLEN
        FCB       SYSCHANNEL        OPEN
*
DISPPOS ; USED TO POSITION $ERRORMESSAGES FILE
        FCB       SYSCALL:CONTROL
        FCB       CONTROL:SCLEN+4   ROOM FOR POINTER TO WRBUF
        FCB       SYSCHANNEL        CHANNEL
        FCB       CC:POSITION       CONTROL SUB-CODE
        FDB      DISPPOS1        POINTER TO 4 BYTE FILE POSITION DESIRED
        FDB      4       SIZE OF FILE POSITION DATA
*
DISPPUTCHAR       ; USED TO WRITE ERROR MESSAGE BYTES TO CONSOLE
        FCB       SYSCALL:WRITEA
        FCB       WRITEA:SCLEN
        FCB       0       CHANNEL
        FCB       IGNORED
        FDB      BUFFER   THIS IS WHERE CHARACTER IS
        FDB      1       ALL OF 1 BYTE!
*
DISPERROR       ; USED TO DISPLAY "Error " ON CONSOLE
        FCB       SYSCALL:WRITEA
        FCB       WRITEA:SCLEN
        FCB       0       CHANNEL
        FCB       IGNORED
        FDB      DISPERRORMSG    BUFFER ADDRESS
        FDB      DISPERRORMSGL   # BYTES TO PRINT
        PAGE     USER PROGRAM EXIT LOGIC
*       KILLUSERPROGRAM -- ENTERED TO ABORT THE CURRENT USER PROGRAM
*       CAN BE CALLED FROM WITHIN SDOS
*       OR FROM WITHIN AN I/O PACKAGE SUBROUTINE OF SDOS
*       OR FROM AN INTERRUPT ROUTINE
*       RETURNS CARRY SET IF CAN'T KILL USER INSTANTLY, SO INPUT ROUTINES DON'T ABORT!
*
KILLUSERPROGRAM  EQU     *
        LDAA      CODE+SDOS:KILLPROOF      IS USER PROGRAM KILL PROOF ?
        BNE      KILLUSERRTS     B/ YES, DON'T KILL IT!
        ;CLR     KILLEDF REMEMBER THAT WE KILLED HIM (USED BY "CHAIN")
        CLR      KILLEDF
        ;JSR    KILLPROOF       ONCE KILLED, DON'T LET IT BE KILLED AGAIN!
        JSR     KILLPROOF
        ;LDD    #KILLPROGRAM     (A,B):= DESIRED PC OF USER TASK
        LDAB      #(KILLPROGRAM)&$FF
        LDAA      #(KILLPROGRAM)/256
        TST     SDOSRECURSIVECALL  USER TASK EXECUTING INSIDE SDOS SOMEWHERE ?
        BNE      KILLUSER2       B/ YES, FIX UP HIS RETURN ADDRESS AND WE'RE DONE!
        ;LDX    USERTASKTCB+TCB:STACK  GET STACK POINTER FOR USER TASK
        LDX     USERTASKTCB+TCB:STACK
        ;STD    REG:PC,X MODIFY CONTEXT BLOCK'S PC...
        STAB      (REG:PC)+1,X
        STAA      REG:PC,X
*       SO THAT THE "RTI" WILL TAKE USER TASK TO "KILLPROGRAM"
        OKRTS

KILLUSER2       ; MODIFY USER'S RETURN ADDRESS SO HE GOES TO "KILLPROGRAM"
        IF      M6800!M6801
        ;LDX    USERRETAPTR      GET USER'S (S) ON ENTRY TO SDOS
        LDX     USERRETAPTR
        ;STD    1,X     THIS IS WHERE PC IS IN STACK
        STAB      (1)+1,X
        STAA      1,X
        ELSE    (M6809)
        ;STD    [USERRETAPTR]
        LDX     USERRETAPTR
        STAB      1,X
        STAA      0,X
        FIN
        OKRTS
*
KILLUSERRTS     ; USER IS KILL PROOF
        ;CLR     KILLREQUESTEDF  CAN'T KILL HIM NOW, SET TIME BOMB
        CLR      KILLREQUESTEDF
        ERRORRTS
        PAGE
*       KILLPROOF -- PERFORM "SYSCALL:KILLPROOF"
*       KILLENABLE -- PERFORM "SYSCALL:KILLENABLE"
*
KILLPROOF       EQU     *
        LDAA      #1      MAKE USER PROGRAM UNKILLABLE (FOR THE NONCE)
        BRA       KILLPROOF1

KILLENABLE        ; MAKE USER PROGRAM KILLABLE
        CLRA              0 --> KILLABLE
KILLPROOF1      STAA      CODE+SDOS:KILLPROOF
        ORAA      KILLREQUESTEDF  DID SOMEBODY ASK FOR THIS GUY TO BE KILLED ?
KILLEDTEST      ; CHECK TO SEE IF USER HAS BEEN KILLED
        BEQ      KILLPROGRAM      B/ NOT KILLPROOF, AND KILL REQUESTED IN PAST
        OKRTS           ALL IS DANDY, GET OUT!
*
*       KILLPROGRAM -- THIS IS WHERE USER TASK IS FORCED TO GO
*       HERE WE MAKE USER TASK DO A FORCED EXIT
*
KILLPROGRAM      EQU     *
        BCS       *+2     EAT USER ERROR IF KILLED ****IS THIS WHAT WE WANT???***
        ;INC     SDOSRECURSIVECALL  SO SYSCALLS WITH FUNNY CHANNEL NUMBERS ARE LEGAL
        INC      SDOSRECURSIVECALL
        ;LDX    #CLOSECHANNEL0     KILL ANY "DO" FILE THAT MIGHT BE OPEN
        LDX     #CLOSECHANNEL0
        ;JSR    SYSCALLENTRY
        JSR     SYSCALLENTRY
        BCS       EXIT1   B/ MORE IMPORTANT ERROR OCCURRED
        ;JSR    CLOSELOG IF ITS OPEN
        JSR     CLOSELOG
        BCC        KILLPROGRAM1     B/ IT WAS OPEN, AND WE CLOSED IT SUCCESSFULLY
        CPX      #ERR:CLOSED      THIS IS OK, TOO!
        BNE      EXIT1   B/ WRONG REASON, GO SHOW TO USER
KILLPROGRAM1     EQU     *
        ;JSR    OPENCONSOLE      RE-OPEN THE CONSOLE ON CHANNEL 0
        JSR     OPENCONSOLE
        BCS       EXIT1   B/ MORE IMPORTANT ERROR OCCURRED
        ;LDX    #ACKCONTROLC        ACKNOWLEDGE RECEIPT OF ^C^C
        LDX     #ACKCONTROLC
        ;JSR    SYSCALLENTRY
        JSR     SYSCALLENTRY
        BCS       EXIT1   B/ RECEIPT ACKNOWLEDGED WITH ERROR 1041
        ;LDX    #ERR:PROGRAMKILLED       NOW CAUSE APPROPRIATE ERROR TO OCCUR
        LDX     #ERR:PROGRAMKILLED
        BRA       EXIT1
        PAGE
*       EXIT -- EXIT FROM USER PROGRAM BACK TO COMMAND INTERPRETER
*       CLOSES ALL OPEN CHANNELS EXCEPT 0 & FLUSHES THE BUFFERS
*       THEN EXITS TO OPERATING SYSTEM
*
ERROREXIT       ;LDX    CODE+SDOS:IOBLOCKPTR
        LDX     CODE+SDOS:IOBLOCKPTR
        ;LDX    ERROREXIT:CODE,X
        LDX     ERROREXIT:CODE,X
        BRA       EXIT1
*
EXITERRED       ; EXIT GOT AN ERROR, DISPLAY IT!
        ;PSHX           SAVE THIS ERROR CODE
        STX     TEMPX
        LDAB      TEMPB
        PSHB
        LDAB      TEMPA
        PSHB
        ;JSR    DISPLAYERRORCR    DISPLAY THE PREVIOUS ERROR
        JSR     DISPLAYERRORCR
        ;PULD           GET EXIT'S ERROR CODE BACK
        PULA
        PULB
        ;STD    USERSLASTERROR   SAVE THE ERROR CODE
        STAB      USERSLASTERROR+1
        STAA      USERSLASTERROR
        ;JSR    DISPLAYERRORCR    SHOW EXIT'S ERROR
        JSR     DISPLAYERRORCR
        PAGE
EXITCHKSUMBASE     ; CODE FROM HERE TO EXITCHKSUMEND IS CHECKSUMMED
EXIT    ;LDX    #0      PICK UP ERROR CODE FOR "NORMAL EXIT"
        LDX     #0
EXIT1   ;JSR    KILLPROOF       SO WE DON'T GET KILLED BY SOME ZEALOT
        JSR     KILLPROOF
        LDAA      #1      GET RID OF ANY OLD KILL REQUESTS
        STAA      KILLREQUESTEDF
        STAA      KILLEDF FORGET THAT USER MIGHT HAVE BEEN KILLED
        LDS     SDOSSTACK PICK UP A REASONABLE STACK POINTER
        STX     USERSLASTERROR   SAVE LAST ERROR CODE
        ;JSR    INTENABLE IN CASE SOMEBODY MANAGED TO TURN THEM OFF
        JSR     INTENABLE
        ;JSR    EXITS   GO CLOSE UP THE FILES
        JSR     EXITS
        BCS       EXITERRED       B/ ERROR, GO TRY TO DEAL WITH IT
        BSR      DISPLAYERRORCR
        ;LDX    #SDOSCHKSUMBASE
        LDX     #SDOSCHKSUMBASE
EXITCODECHKSUM    EQU     *+1     CONTAINS VALUE THAT MAKES CHECKSUM OVER EXIT ALL ZERO
        LDAB      #CHANGED  CHANGED BYTE IS CHECKSUM BYTE
        CLRA              COMPUTE CHECKSUM ON SDOS CODE
EXITCKSUML       ; DO CHECKSUM THAT IS HARD TO BEAT BY TRANSPOSITION OF BYTES
        ASLA
        IF      M6800!M6801
        ADCA       0,X
        INX
        ELSE    (M6809)
        ADCA       ,X+
        FIN
        CPX      #SDOS:END
        BNE      EXITCKSUML
        CLRA	;ZZZ	TSTA             IS CHECKSUM OK (=0?)
        BEQ      EXIT2   B/ YES, GO CHAIN TO DEFAULTPROGRAM
        ;LDX    #ERR:SDOSCKSUM   DISPLAY THE ERROR!
        LDX     #ERR:SDOSCKSUM
        STX     USERSLASTERROR
        BSR      DISPLAYERRORCR
        BRA       *       WE'RE DEAD...
        page
;       SerialNumberLocation is included in the critically secure "EXIT" region...
;       because of the importance of knowing that its contents are not forged.

SerialNumberLocation    ;ZZZ fdb     0       Points to SerialNumber if Mass-produced ROM
	fdb  $FFF0
                ; Points to different place for each Mass-Produced computer type
                ; Contains Zero if Standard SDOS boot ROM structure.

EXITCHKSUMEND    ; ALL CODE BETWEEN EXITCHKSUMBASE AND HERE IS CHECKSUMMED
*
*       SDOSCODECHKSUM contains a value that makes the checksum over SDOS give 0
*
SDOSCODECHKSUM    FCB       CHANGED
        PAGE
EXIT2   ;CLR     SDOSRECURSIVECALL  SWITCH TO USER MODE ("NOT IN SDOS")
        CLR      SDOSRECURSIVECALL
        ;JSR    KILLENABLE        ALLOW USER PROGRAM TO GET KILLED
        JSR     KILLENABLE
        ;LDX    #EXITCHAIN        ALL IS OK, GO GET THE DEFAULT PROGRAM
        LDX     #EXITCHAIN
        ;JSR    SYSCALLENTRY
        JSR     SYSCALLENTRY
        BCC        *       WE GOT HERE WITHOUT AN ERROR???
        ;INC     SDOSRECURSIVECALL  SWITCH BACK TO "IN SDOS" MODE
        INC      SDOSRECURSIVECALL
        CPX      #ERR:NOSUCHPROGRAM        THIS KIND OF ERROR ?
        BNE      EXIT3   B/ NO, TELL THE USER
        ;LDX    #ERR:NODEFAULTPROGRAM     SCREAM "NO DEFAULTPROGRAM"!
        LDX     #ERR:NODEFAULTPROGRAM
EXIT3   STX     USERSLASTERROR
        BSR      DISPLAYERRORCR
*
*       Since there is no DEFAULTPROGRAM on this disk, dismount the disk.
*
        ;LDX    DEFAULTDISKDCB     THIS IS THE DISK TO DISMOUNT.
        LDX     DEFAULTDISKDCB
        STX     DCBPOINTER
        ;JSR    DSKDDISMOUNT
        JSR     DSKDDISMOUNT
        BRA       EXIT    AND START OVER AGAIN

DEFAULTPROG      FCC       'DEFAULTPROGRAM'
DEFAULTPROGL     EQU     *-DEFAULTPROG
*
EXITCR   ;LDX    #EXITCR1
        LDX     #EXITCR1
        ;JMP    SYSCALLENTRY
        JMP     SYSCALLENTRY
*
EXITCR1  ; SYSCALL USED TO PRINT A <CR> ON CHANNEL 0
        FCB       SYSCALL:WRITEA
        FCB       WRITEA:SCLEN
        FCB       0,IGNORED       CHANNEL
        FDB      COPYRIGHTEND-1   YOU'LL SEE A :0D THERE...
        FDB      1       THIS IS ALL WE WANT TO WRITE!
        PAGE
*
*       DISPLAYERRORCR -- DISPLAY USER'S LAST ERROR, FOLLOWED BY <CRLF>
*
DISPLAYERRORCR    EQU     *
        ;LDX    USERSLASTERROR   GET ERROR NUMBER
        LDX     USERSLASTERROR
        BEQ      DISPLAYERRORCR1   B/ NO ERROR!
        ;JSR    DISPLAYERROR     GO PRINT THE ERROR STRING OR NUMBER
        JSR     DISPLAYERROR
        BSR      EXITCR   GO DISPLAY <CRLF>
        BCS       *       LOOP HERE IF WE CAN'T GET IT OUT!
DISPLAYERRORCR1   EQU     *
        OKRTS
*
*       OPEN UP CHANNEL 0 TO THE FIRST DEVICE IN THE
*       DEVICE NAME LIST
*       ***** RULE *****
*       THE FIRST DEVICE IN THE DEVICE LIST IS THE CONSOLE
*
OPENCONSOLE      ;LDX    #CONSOLEOPEN
        LDX     #CONSOLEOPEN
        ;JMP    SYSCALLENTRY
        JMP     SYSCALLENTRY
        PAGE
        IF      0       this code is cute, but is wrong evolutionary path...
*
*       SCANDCBSFORLUN -- SCAN DOWN DCB CHAIN, DECREMENT LOGICAL UNIT # IN D...
*       UNTIL ZERO OR DCB CHAIN IS EXHAUSTED
*       RETURNS (X)=0 --> NOT FOUND; <>0 --> FOUND
*
SCANDCBSFORLUN1     ; CHECK: IS LUN ZERO?
        ;TSTD
        TSTA
        ;BEQD    SCANDCBSFORLUNF     B/ YES, WE FOUND DEVICE NAME!
        BNE      MACRO:000D
        TSTB
        BEQ      SCANDCBSFORLUNF
MACRO:000D
        ;SUBD    #1      DECREMENT LUN
        SUBB      #(1)&$FF
        SBCA       #(1)/256
        ;LDX    DCB:NEXTDCB,X       FIND NEXT DCB
        LDX     DCB:NEXTDCB,X
SCANDCBSFORLUN      ; SCAN DCB CHAIN FOR LUN (D)
        BNE      SCANDCBSFORLUN1     B/ MORE DCB CHAIN TO SEARCH
        RTS             WITH "Z" SET --> NOT FOUND!

SCANDCBSFORLUNF     ; FOUND DCB THAT MATCHES LOGICAL UNIT NUMBER!
        ;LDX    DCB:NAME,X GET POINTER TO NAME
        LDX     DCB:NAME,X
        RTS             WITH "Z" BIT RESET

ERRNOSUCHLUN
        ;JSR    ERRET
        JSR     ERRET
        FDB      ERR:NOSUCHLUN
*
*       READLUNNAME -- PERFORM "SYSCALL:READLUNNAME"
*       CONVERTS LOGICAL UNIT NUMBER TO DEVICE NAME STRING
*
READLUNNAME
        ;LDX    CODE+SDOS:IOBLOCKPTR       GET LOGICAL UNIT NUMBER
        LDX     CODE+SDOS:IOBLOCKPTR
        ;LDD    READLUNNAME:LUN,X
        LDAB      (READLUNNAME:LUN)+1,X
        LDAA      READLUNNAME:LUN,X
        ;LDX    CODE+SDOS:CONFIGURATION    SEE IF LUN IS IN DISK DCBS
        LDX     CODE+SDOS:CONFIGURATION
        ;LDX    CNFG:DISKDCBS,X
        LDX     CNFG:DISKDCBS,X
        BSR      SCANDCBSFORLUN
        BNE      READLUNNAME1      B/ YES!
        ;LDX    CODE+SDOS:CONFIGURATION    SEE IF LUN IS IN DEVICE DCBS
        LDX     CODE+SDOS:CONFIGURATION
        ;LDX    CNFG:DEVICEDCBS,X
        LDX     CNFG:DEVICEDCBS,X
        BSR      SCANDCBSFORLUN
        BEQ      ERRNOSUCHLUN     B/ LUN IS NOT LEGAL IN THIS CONFIGURATION
READLUNNAME1      ; (X) = ADDRESS OF DEVICE NAME FOR SPECIFIED LUN
        STX     FROMPOINTER     SAVE DEVICE NAME ADDRESS
        LDAB      #-1     GET LENGTH OF DEVICE NAME
READLUNNAME2      ; SCAN DEVICE NAME TO GET LENGTH
        INCB              BUMP LENGTH
        IF      M6800!M6801
        LDAA      ,X      GET BYTE OF DEVICE NAME
        BEQ      READLUNNAME3      B/ END OF NAME
        INX
        BRA       READLUNNAME2
READLUNNAME3
        ELSE    (M6809)
        ;LDA     ,X+
        LDAA      0,X
        INX
        BNE      READLUNNAME2
        FIN
        CLRA
        ;STD    TEMPX   = LENGTH OF DEVICE NAME
        STAB      TEMPX+1
        STAA      TEMPX
        ;LDX    CODE+SDOS:IOBLOCKPTR       GET USER BUFFER ADDRESS
        LDX     CODE+SDOS:IOBLOCKPTR
        ;LDD    READLUNNAME:MAXCOUNT,X      = MAX # BYTES TO TRANSFER
        LDAB      (READLUNNAME:MAXCOUNT)+1,X
        LDAA      READLUNNAME:MAXCOUNT,X
        ;SUBD    TEMPX   ROOM FOR REPLY?
        SUBB      TEMPX+1
        SBCA       TEMPX
        BCS       ERRSYSTOOSHORTJ
        ;LDD    TEMPX   SET REPLY LENGTH
        LDAB      TEMPX+1
        LDAA      TEMPX
        ;STD    READLUNNAME:ACTUALCOUNT,X
        STAB      (READLUNNAME:ACTUALCOUNT)+1,X
        STAA      READLUNNAME:ACTUALCOUNT,X
        IF      M6800!M6801
        ;LDX    READLUNNAME:BUFFERP,X      = WHERE TO PUT NAME
        LDX     READLUNNAME:BUFFERP,X
        STX     TOPOINTER
        ELSE    (M6809)
        LDY     READLUNNAME:BUFFERP,X      = WHERE TO PUT NAME
        FIN
        ;LDX    FROMPOINTER
        LDX     FROMPOINTER
        ;JSR    BLOCKMOVE
        JSR     BLOCKMOVE
        OKRTS
        ELSE
READLUNNAME       EQU     ERRILLSYSCALL     to cauterize the wound...
        FIN
        PAGE
*       CHECKRDLEN -- CHECK SCBLK:RDLEN...
*       TO MAKE SURE ITS VALUE >= 2 BYTES AT RETURN ADDRESS
*       ALSO CHECKS THAT SYSCALL BLOCK IS LONG ENOUGH TO INCLUDE SCBLK:RDLEN
*       SETS SCBLK:RPLEN TO 2 BYTE INLINE VALUE IF RDLEN IS OK
*       (X) = CODE+SDOS:IOBLOCKPTR ON EXIT
*       SKIPS AROUND 2 BYTE INLINE VALUE IF OK
*       ERROR EXIT IF NOT OK
*       **** CHECKWRLEN, CHECKRDLEN SHOULD BE RECODED SO THAT THE FOLLOWING WORKS:
*       JSR     CHECKRDLEN
*       FDB      XXXX
*       BCS       error...
*
CHECKRDLEN        EQU     *
        ;LDX    CODE+SDOS:IOBLOCKPTR       CHECK THAT READ DATA BUFFER IS INCLUDED...
        LDX     CODE+SDOS:IOBLOCKPTR
        LDAA      SCBLK:WLEN,X      IN THE SYSCALL BLOCK
        ANDA      #$7F    BYEBYE WAIT BIT
        ;CMPA     #SCBLK:RDLEN+2    IS SYSCALL BLOCK LONG ENOUGH ?
        CMPA      #SCBLK:RDLEN+2
        BCS       ERRSYSTOOSHORTJ B/ NOPE, STICK THE USER WITH AN ERROR
        ;LDD    [0,S]   IS 0 > MINLENGTH-RDLEN-1 ?
        TSX
        LDX     0,X
        LDAB      1,X
        LDAA      0,X
        SEC              (-1 PART)
        ;LDX    CODE+SDOS:IOBLOCKPTR       SUBTRACT RDLEN
        LDX     CODE+SDOS:IOBLOCKPTR
        SBCB       SCBLK:RDLEN+1,X
        SBCA       SCBLK:RDLEN,X
        BCC        ERRRDBUFTOOSMALL  B/ NO, NOT ENOUGH READ BUFFER
        ADCB       SCBLK:RDLEN+1,X   SET REPLY LENGTH = DESIRED # BYTES
        ADCA       SCBLK:RDLEN,X     (A,B):=DESIRED # BYTES
        ;STD    SCBLK:RPLEN,X     RPLEN:=(A,B)
        STAB      (SCBLK:RPLEN)+1,X
        STAA      SCBLK:RPLEN,X
CHECKRDLEN1       EQU     *
        ;LDA     1,S     ALL IS OK, TAKE SKIP EXIT
        TSX
        LDAA      1,X
        ADDA      #2      BUMP RETURN PAST INLINE ARGUMENT
        IF      M6800!M6801
        STAA      1,X
        BCC        CHECKRDLEN2
        ;INC     0,X
        INC      0,X
        ELSE    (M6809)
        STAA      1,S
        BCC        CHECKRDLEN2
        ;INC     0,S
        TSX
        INC      0,X
        FIN
CHECKRDLEN2       EQU     *
        ;LDX    CODE+SDOS:IOBLOCKPTR
        LDX     CODE+SDOS:IOBLOCKPTR
        OKRTS
        PAGE
ERRSYSTOOSHORTJ EQU     *
        ;JMP    ERRSYSCALLTOOSHORT
        JMP     ERRSYSCALLTOOSHORT

ERRRDBUFTOOSMALL  EQU     *
        ;JSR    ERRET
        JSR     ERRET
        FDB      ERR:RDBUFTOOSMALL
*
*       CHECKWRLEN -- CHECK SCBLK:WRLEN...
*       TO MAKE SURE ITS VALUE >= 2 BYTES AT RETURN ADDRESS
*       ERROR EXIT IF NOT
*       RETURNS WITH (X) CONTAINING CODE+SDOS:IOBLOCKPTR OTHERWISE
*       SKIPS AROUND 2 BYTE INLINE VALUE
*
CHECKWRLEN        EQU     *
        ;LDX    CODE+SDOS:IOBLOCKPTR       CHECK THAT WRBUF INFO IS INCLUDED...
        LDX     CODE+SDOS:IOBLOCKPTR
        LDAA      SCBLK:WLEN,X      IN THE SYSCALL
        ANDA      #$7F    BYEBYE WAIT BIT
        ;CMPA     #SCBLK:WRLEN+2    SYSCALL BLOCK LONG ENOUGH ?
        CMPA      #SCBLK:WRLEN+2
        BCS       ERRSYSTOOSHORTJ B/ NO, GO STICK IT TO THE USER
        ;LDD    [0,S]   IS 0 > MINLENGTH - WRLEN -1 ?
        TSX
        LDX     0,X
        LDAB      1,X
        LDAA      0,X
        SEC              (-1 PART)
        ;LDX    CODE+SDOS:IOBLOCKPTR       NOW SUBTRACT WRLEN
        LDX     CODE+SDOS:IOBLOCKPTR
        SBCB       SCBLK:WRLEN+1,X
        SBCA       SCBLK:WRLEN,X
        BCS       CHECKRDLEN1       B/ ITS OK
ERRWRBUFTOOSMALL  EQU     *
        ;JSR    ERRET
        JSR     ERRET
        FDB      ERR:WRBUFTOOSMALL
*
*       CHECKSCLEN -- CHECK SCBLK:WLEN...
*       TO MAKE SURE IT IS LARGER THAN (B), ERROR EXIT IF NOT
*
CHECKSCLEN
        ;LDX    CODE+SDOS:IOBLOCKPTR       GET WLEN OF SYSCALL BLOCK
        LDX     CODE+SDOS:IOBLOCKPTR
        ;LDA     SCBLK:WLEN,X
        LDAA      SCBLK:WLEN,X
        ANDA      #$7F    AND MASK OFF THE NO WAIT BIT
        CBA                IS SYSCALL BLOCK LONG ENOUGH?
        BCS       ERRSYSTOOSHORTJ B/ NOPE, STAB USER IN BACK TO GET EVEN!
        RTS             ALL IS WONDERFUL...
        PAGE
*       EXITS -- DO CLEAN UP APPROPRIATE FOR PROGRAM COMPLETION
*       CLOSES ALL I/O CHANNELS EXCEPT 0
*       DUMPS ALL DISK BUFFERS TO DISK
*
EXITS   ;LDX    CODE+SDOS:CONFIGURATION
        LDX     CODE+SDOS:CONFIGURATION
        LDAA      CNFG:NIOCHANNELS,X
        STAA      EXITSCLOSE+CLOSE:CHANNEL    SET UP CHANNEL-CLOSING SYSCALL
EXITS2  ;LDX    #EXITSCLOSE      CLOSE A CHANNEL
        LDX     #EXITSCLOSE
        ;DEC     CLOSE:CHANNEL,X
        DEC      CLOSE:CHANNEL,X
        BEQ      EXITS3  B/ ALL USER I/O CHANNELS EXCEPT ZERO CLOSED
        ;JSR    SYSCALLENTRY      GO CLOSE THIS CHANNEL
        JSR     SYSCALLENTRY
        BCC        EXITS2
        CPX      #ERR:CLOSED      WAS THE CHANNEL CLOSED?
        BEQ      EXITS2  B/ YEP, GO ON
EXITSERRED      ; NOPE, HE'S DEAD (CARRY IS STILL SET)
        ;JMP    ERRORED
        JMP     ERRORED
*
*       NOW GO THROUGH AND DUMP THE DISK BUFFERS ON ALL THE DRIVES
*
EXITS3  ;LDX    CODE+SDOS:CONFIGURATION
        LDX     CODE+SDOS:CONFIGURATION
        ;LDX    CNFG:DISKDCBS,X
        LDX     CNFG:DISKDCBS,X
EXITS4  STX     DCBPOINTER
        ;JSR    DSKDUMPBUFFERS
        JSR     DSKDUMPBUFFERS
        BCC        EXITS6  B/ NO PROBLEMS
        CPX      #ERR:FILEISOPEN WAS IT THE FILE OPEN PROBLEM?
        BNE      EXITSERRED      B/ NOPE, YOU'RE DEAD
EXITS6  ;LDX    DCBPOINTER
        LDX     DCBPOINTER
        ;LDX    DCB:NEXTDCB,X
        LDX     DCB:NEXTDCB,X
        BNE      EXITS4
        IF      *&1     FORCE EXITDAMAGE TO BE EVEN ADDRESS
        NOP
        FIN
EXITDAMAGE        ; THIS PLACE IS MASHED BY COPYRIGHT CHECK FAILURE
        OKRTS
        PAGE     CHAIN/LOAD SYSCALLS
*       CHAIN -- PERFORM "SYSCALL:CHAIN"
*       ALWAYS RETURNS CONTROL TO CALLER AFTER ERROR UNTIL TYPE 1 RECORD VALIDATED
*       ONCE TYPE 1 RECORD SEEN, ERROREXIT IS FORCED ON AN ERROR.
*       CHAIN SWITCHES STACK TO TOP OF USER SPACE ONCE TYPE 1 RECORD SEEN.
*
*       CHAIN Transition/action table:
*       Unencrypted --> Unencrypted:    Do nothing
*       Unencrypted --> Encrypted:      Zero the user space, save key, mark 'running encrypted'
*       Encrypted --> Encrypted:        Do nothing
*       Encrypted --> Encrypted':       Zero the user space, save decryption key
*       Encrypted --> Unencrypted:      Zero the user space, save key, mark 'runencrypted'

*       LOAD Transition/action table:
*       Unencrypted --> Unencrypted:    Do nothing
*       Unencrypted --> Encrypted:      Signal error
*       Encrypted --> Encrypted:        Do nothing
*       Encrypted --> Encrypted':       Signal error
*       Encrypted --> Unencrypted:      Signal error
*
*       These routines use OldKeyEncrypted and NewKeyEncrypted to decide transitions
*       Definition: If OldKeyEncrypted=0, then we were running Unencrypted
*               If NewKeyEncrypted=0, then we are transiting to Unencrypted
*
CHAIN     EQU     *
        ;LDX    CODE+SDOS:IOBLOCKPTR       REMEMBER WHERE THE CHAIN SYSCALL IS
        LDX     CODE+SDOS:IOBLOCKPTR
        STX     USERSYSCALLPTR    (THIS IS NEEDED BECAUSE EXIT DOES A CHAIN)
        BSR      EXITS   GO CLOSE ALL THE CHANNELS
        ;LDX    USERSYSCALLPTR    GRAB ADDRESS OF CHAIN SYSCALL AGAIN
        LDX     USERSYSCALLPTR
        STX     CODE+SDOS:IOBLOCKPTR       MAKE IT THE OFFICIAL "BEING PROCESSED" SYSCALL AGAIN
        ;LDX    SCBLK:PARAMS,X      GET LONG-TERM OPERATION ENABLING KEY
        LDX     SCBLK:PARAMS,X
        ;JSR    SAFEGAURD SET UP A DISASTER IF WRONG KEY IS PASSED
        JSR     SAFEGAURD
FIRSTCHAIN        ; ENTRY POINT USED TO CHAIN TO "SERIALNUMBER.SYS"
        BSR      LOADINIT OPEN THE FILE AND VERIFY IT IS AN OBJECT FILE
        ;LDX    STARTADDRESS      CHECK THE START ADDRESS FOR ILLEGAL VALUE
        LDX     STARTADDRESS
        BEQ      ERRZEROSTARTADDRESS       B/ NO START ADDRESS!
        LDS     SDOSSTACK FILE IS OK, SWITCH TO STANDARD STACK FOR CHAINING
*** ^C^C IS PERFECTLY SAFE HERE, BECAUSE SDOSRECURSIVE CALL IS SET!
        BSR      COMPAREDECRYPTIONKEYS      ARE OLD AND NEW ENCRYPTION KEYS IDENTICAL ?
        BCC        CHAINOK   B/ DECRYPTION KEYS MATCH, DO NOTHING
        ;JSR    ZAPUSERSPACE       MAKE TRASH OUT OF INFORMATION IN USER SPACE
        JSR     ZAPUSERSPACE
        if      m6800!m6801
        ;ldx    #OldKeyEncrypted        save this "key" as last "key" used
        LDX     #OldKeyEncrypted
        stx     topointer
        else    (m6809)
        ldy     #OldKeyEncrypted
        fin
        ;LDX    #NEWKEYENCRYPTED = FROM ADDRESS
        LDX     #NEWKEYENCRYPTED
        ;ldd    #8      = # bytes to save
        LDAB      #(8)&$FF
        LDAA      #(8)/256
        ;jsr    blockmove       Note: it is NOT secure to call code+sdos:blockmove here!
        JSR     blockmove
CHAINOK   ; ITS OK TO DO THE CHAIN, HOP TO IT!
        ;JSR    LOADREST GO LOAD THE REST OF THE FILE
        JSR     LOADREST
        BCC        CHAIN1    B/ NO LOADER ERROR
        ;JMP    EXIT1   I GIVE UP
        JMP     EXIT1

CHAIN1    ;CLR     SDOSRECURSIVECALL  FLAG "NOT IN SDOS"
        CLR      SDOSRECURSIVECALL
        LDAA      KILLEDF SEE IF USER GOT KILLED WHILE LOADING!
        ;JSR    KILLEDTEST      ...?
        JSR     KILLEDTEST
        ;LDX    STARTADDRESS      ALL IS DONE...
        LDX     STARTADDRESS
        ;JMP    ,X      PASS CONTROL TO USER PROGRAM!
        JMP     0,X

ERRZEROSTARTADDRESS       ; START ADDRESS IS ZERO ON A CHAIN
        ;LDX    #ERR:ZEROSTARTADDRESS     GET ERROR CODE
        LDX     #ERR:ZEROSTARTADDRESS
        ;JMP    LOADER2  GO CLOSE THE FILE, TRASH THE KEY, AND EXIT!
        JMP     LOADER2
        PAGE
*       COMPAREDECRYPTIONKEYS -- COMPARE OLD AND NEW DECRYPTION KEYS
*       SIGNAL ERROR IF NO MATCH
*       (DO SO IN A SUBTLE WAY, SO IT IS NOT EASY TO FIND WHO GENERATES THE ERROR CODE)
*
COMPAREDECRYPTIONKEYS
        IF      M6800!M6801
        ;LDX    #OLDKEYENCRYPTED = COMPARE "TO" ADDRESS
        LDX     #OLDKEYENCRYPTED
        STX     TOPOINTER
        ELSE    (M6809)
        LDY     #OLDKEYENCRYPTED
        FIN
        ;LDX    #NEWKEYENCRYPTED = COMPARE "FROM" ADDRESS
        LDX     #NEWKEYENCRYPTED
        ;LDB     #8      = # BYTES TO COMPARE (KEY SIZE)
        LDAB      #8
        ;JSR    BLOCKCOMPARE
        JSR     BLOCKCOMPARE
        BEQ      COMPAREDECRYPTIONMATCH       B/ ALL IS OK
        ;LDD    #ERR:DECRYPTIONKEYSDONTMATCH-1234  GENERATE ERROR CODE...
        LDAB      #(ERR:DECRYPTIONKEYSDONTMATCH-1234)&$FF
        LDAA      #(ERR:DECRYPTIONKEYSDONTMATCH-1234)/256
        ;ADDD    #1234   IN SUBTLE WAY
        ADDB      #(1234)&$FF
        ADCA       #(1234)/256
        ;TDX
        STAA      TEMPA
        STAB      TEMPB
        LDX     TEMPX
        ERRORRTS                AND TAKE ERROR EXIT

COMPAREDECRYPTIONMATCH       ; OLD AND NEW KEYS MATCH!
        OKRTS
        PAGE
*
*       LOADINIT -- OPEN LOAD FILE, COMPUTE DECRYPTION KEY,
*       AND VERIFY OBJECT FORMAT CONTENT
*       IF AN ERROR OCCURS, CLOSE THE LOAD FILE
*
LOADINIT
        ;LDX    CODE+SDOS:IOBLOCKPTR       REMEMBER ADDRESS OF SYSTEM CALL
        LDX     CODE+SDOS:IOBLOCKPTR
        STX     LOADSYSCALLPTR     SO WE CAN SAVE START ADDRESS IN REPLY BUFFER, LATER
        LDAA      #$7E    SET UP SYSCALL JUMP IN PAGE ZERO...
        STAA      SYSCALL$  TO JUMP TO I/O PACKAGE BASE
        ;LDX    CODE+SDOS:CONFIGURATION    (SO USER KNOWS WHERE BASE OF I/O PACK IS!)
        LDX     CODE+SDOS:CONFIGURATION
        ;LDX    CNFG:DRIVERBASE,X
        LDX     CNFG:DRIVERBASE,X
        STX     SYSCALL$+1
        ;JSR    CHECKRDLEN        NEED 4 BYTE READ-BACK AREA
        JSR     CHECKRDLEN
        FDB      2+2     2 FOR FILENAME LENGTH, 2 FOR START ADDRESS
        ;LDX    #SYSIOCB  FAKE A CHECKCHANNEL CALL ON SYS CHANNEL
        LDX     #SYSIOCB
        STX     IOCBPOINTER
        ;JSR    FNAMEPROCESS1     GO FIGGER OUT DA DRIVER ADDRESS
        JSR     FNAMEPROCESS1
        ;JSR    [DRIVER:OPEN,X] AND OPEN IT!
        LDX     DRIVER:OPEN,X
        JSR     0,X
        BCS       LOADINITCANTOPEN   B/ HAD A PROBLEM!
        ;JSR    OPEN2   GO ADJUST FILE NAME, AND MARK SYSIOCB AS "OPEN"
        JSR     OPEN2
        ;CLR     OKTODECRYPTFLAG   FLAG "DON'T DECRYPT!"
        CLR      OKTODECRYPTFLAG
        ;LDX    #DECRYPTBUFFER    SET UP SO GET BYTE GETS 1ST BYTE OF FILE
        LDX     #DECRYPTBUFFER
        STX     DECRYPTBUFPTR
        ;LDX    #FILLDECRYPTBUFFER        READ 1ST 8 BYTES OF FILE
        LDX     #FILLDECRYPTBUFFER
        ;JSR    SYSCALLENTRY
        JSR     SYSCALLENTRY
        BCS       LOADER2  B/ PROBABLY EOF, TOO BAD!
        ;JSR    GETBYTE  GET ME A BYTE
        JSR     GETBYTE
        ;CMPA     #LOAD:ENCRYPTED   IS THIS AN ENCRYPTED FILE?
        CMPA      #LOAD:ENCRYPTED
        ;LBEQ    LOADENCRYPTED     B/ YES, GO COMPUTE DECRYPTION KEY AND PROCESS 1ST LOAD RECORD
        BNE      MACRO:000E
        JMP     LOADENCRYPTED
MACRO:000E
        ;LDX    #NEWKEYENCRYPTED SET NEWKEYENCRYPTED = 0 --> UNENCRYPTED FILE
        LDX     #NEWKEYENCRYPTED
        ;LDB     #8      = # BYTES TO ZERO
        LDAB      #8
ZERONEWKEYLOOP
        ;CLR     ,X+
        CLR      0,X
        INX
        DECB
        BNE      ZERONEWKEYLOOP
LOADSTART ; VERIFY THAT THIS IS A PROPERLY CONSTRUCTED START RECORD
        ;CMPA     #LOAD:TYPE1      DOES IT APPEAR TO BE SDOS BINARY FORMAT ?
        CMPA      #LOAD:TYPE1
        BEQ      LOADTYPE1        B/ YES
CANTLOAD   ; THIS IS NOT AN OBJECT FILE
        BSR      LOADCLOSE CLOSE THE FILE
        ;JSR    ERRET
        JSR     ERRET
        FDB      ERR:NOTALOADFILE
*
LOADTYPE1        ; FETCH START ADDRESS AND VERIFY COMPLEMENT IN TYPE1 RECORD
        ;JSR    GETWORD GET THE EXECUTION ADDRESS
        JSR     GETWORD
        ;STD    STARTADDRESS
        STAB      STARTADDRESS+1
        STAA      STARTADDRESS
        ;LDX    LOADSYSCALLPTR     COPY START ADDRESS TO SYSCALL REPLY BUFFER
        LDX     LOADSYSCALLPTR
        ;LDX    SCBLK:RDBUF,X
        LDX     SCBLK:RDBUF,X
        ;STD    2,X
        STAB      (2)+1,X
        STAA      2,X
        ;JSR    GETWORD
        JSR     GETWORD
        ;ADDD    STARTADDRESS
        ADDB      STARTADDRESS+1
        ADCA       STARTADDRESS
        ;CMPD    #-1
        CMPA      #(-1)/256
        BNE      MACRO:000F
        CMPB      #(-1)&$FF
MACRO:000F
        BNE      CANTLOAD   B/ NOT TYPE 1 RECORD!
LOADINITOKRTS
        OKRTS

ERRSERIALNOWRONG
        ;LDX    #ERR:SERIALNOWRONG
        LDX     #ERR:SERIALNOWRONG
LOADER2  ; ERRORED WHILE TRYING TO LOAD
        STX     STARTADDRESS      SAVE THE ERROR CODE
        BSR      LOADCLOSE CLOSE UP THE LOAD FILE
        ;LDX    STARTADDRESS      GET ERROR CODE BACK
        LDX     STARTADDRESS
        BRA       LOADINITCANT1      GO STICK USER WITH ERROR

LOADINITCANTOPEN   ; ERROR WHEN OPENING LOAD FILE
        CPX      #ERR:FILENOTFOUND       IS THIS THE CAUSE?
        BNE      LOADINITCANT1      B/ NO
        ;LDX    #ERR:NOSUCHPROGRAM        YES, CHANGE ERROR CODES
        LDX     #ERR:NOSUCHPROGRAM
LOADINITCANT1
        ;JMP    ERRORINX        TRIGGER THE ERROR AGAIN
        JMP     ERRORINX
        PAGE
*       LOAD -- PERFORM "SYSCALL:LOAD"
*
LOAD     EQU     *
        ;JSR    LOADINIT LOAD THE FILE INTO MEMORY
        JSR     LOADINIT
        ;JSR    COMPAREDECRYPTIONKEYS      ARE OLD AND NEW DECRYPTION KEYS IDENTICAL ?
        JSR     COMPAREDECRYPTIONKEYS
        BCS       LOADER2  B/ KEYS DON'T MATCH, CLOSE FILES AND SIGNAL ERROR!
*
LOADREST ; LOAD OBJECT RECORDS FROM FILE
        ;JSR    LOADCONTENTS      LOAD THE CONTENTS OF THIS FILE
        JSR     LOADCONTENTS
        BCS       LOADER2  B/ ERRORED IN LOADING FILE CONTENTS
LOADCLOSE ; CLOSE THE LOAD FILE AND QUIT
        ;LDX    #OLDKEYENCRYPTED DECIDE IF WE SHOULD RUN ENCRYPTED OR NOT
        LDX     #OLDKEYENCRYPTED
        ;JSR    SETKEY  (TRASH THE DECRYPTION KEY, THIS PATH ALWAYS TAKEN!)
        JSR     SETKEY
        LDAA      ,X      IF OLDKEYENCRYPTED<>0, THEN RUN ENCRYPTED!
        ORAA      1,X
        ORAA      2,X
        ORAA      3,X
        ORAA      4,X
        ORAA      5,X
        ORAA      6,X
        ORAA      7,X
        ;JSR    GETRUNNINGENCRYPTED      SET RUNNINGENCRYPTED FLAG
        JSR     GETRUNNINGENCRYPTED
        ;STA     ,X      SET RUNNINGENCRYPTED TO PROPER STATE
        STAA      0,X
        ;LDX    #LOADCLOSE1       NOW CLOSE THE LOAD FILE
        LDX     #LOADCLOSE1
        ;JMP    SYSCALLENTRY
        JMP     SYSCALLENTRY

LOADCLOSE1        EQU     *
        FCB       SYSCALL:CLOSE
        FCB       CLOSE:SCLEN
        FCB       SYSCHANNEL
        PAGE
*
*       SYSCALL:GETSERIALNUMBER
*       RETURNS SERIALNUMBER OF PROCESSOR IN REPLY BUFFER
*
GETSERIALNUMBER
        ;JSR    CHECKRDLEN        MAKE SURE REPLY BUFFER IS LARGE ENOUGH
        JSR     CHECKRDLEN
        FDB      SERIALNUMBER:SIZE
        IF      M6800!M6801
        ;LDX    SCBLK:RDBUF,X      WHERE TO PUT SERIAL NUMBER
        LDX     SCBLK:RDBUF,X
        STX     TEMPX   = COPY-TO ADDRESS
        ELSE    (M6809)
        LDY     SCBLK:RDBUF,X      WHERE TO PUT SERIAL NUMBER
        FIN
        BSR      GETSERIALNUMBERADDRESS     GET ADDRESS AND SIZE OF SERIAL NUMBER
        ;JSR    BLOCKMOVE *** NOT SAFE TO USE SDOS:BLOCKMOVE ENTRY POINT ***
        JSR     BLOCKMOVE
        OKRTS
*
*       GETSERIALNUMBERADDRESS -- RETURNS LOCATION AND SIZE OF SERIALNUMBER
*
GETSERIALNUMBERADDRESS
        ;LDD    #SERIALNUMBER:SIZE        GET SIZE OF SERIAL NUMBER TO (D)
        LDAB      #(SERIALNUMBER:SIZE)&$FF
        LDAA      #(SERIALNUMBER:SIZE)/256
        ;LDX    SERIALNUMBERLOCATION        GET LOCATION OF S/N FOR MASK ROM
        LDX     SERIALNUMBERLOCATION
        BNE      GETSERIALNUMBERADDRESSRTS  B/ MASK ROM
        ;LDX    $FFFE   STANDARD SDOS BOOT ROM, FIND JMP PRECEDING S/N
        LDX     $FFFE
        ;LEAX    3,X     ADVANCE POINTER SO IT POINTS AT S/N IN ROM
        IF      3<0
        RPT     -3
        DEX
        ELSE
        RPT     3
        INX
        FIN
GETSERIALNUMBERADDRESSRTS
        RTS
        PAGE     SDOS BINARY FORMAT LOADER
GETRUNNINGENCRYPTED ; GET ADDRESS OF RUNNING ENCRYPTED FLAG TO (X)
        ;LDX    SERIALNUMBERLOCATION        MASK ROM ?
        LDX     SERIALNUMBERLOCATION
        BEQ      GETRUNNINGENCRYPTED1     B/ NO, GO LOCATE VIA RESTART VECTOR
        ;LDX    #RUNNINGENCRYPTEDFLAG     YES, USE DEFAULT RUNNING ENCRYPTED FLAG
        LDX     #RUNNINGENCRYPTEDFLAG
        RTS

GETRUNNINGENCRYPTED1 ; STANDARD SDOS ROM STRUCTURE
        ;LDX    $FFFE   GET ADDRESS OF JMP PRECEDING SERIAL NUMBER
        LDX     $FFFE
        ;LDX    1,X     GET POINTER TO RESTART CODE
        LDX     1,X
        ;LDX    LDAENCRYPTED-RESTART+1,X   = ADDRESS OF RUNNINGENCRYPTED FLAG
        LDX     LDAENCRYPTED-RESTART+1,X
        RTS

LOADENCRYPTED ; LOAD AN ENCRYPTED FILE, PROCESS TYPE 5 RECORD
        BSR      GETRUNNINGENCRYPTED      GET ADDRESS OF RUNNING ENCRYPTED
        ;INC     ,X      BUMP RUNNINGENCRYPTED; = 2 --> WAS ALREADY RUNNING ENCRYPTED
        INC      0,X
        ;LDX    SERIALNUMBERLOCATION        SHOULD WE CHECK SELECT BANK ROUTINE ?
        LDX     SERIALNUMBERLOCATION
        BNE      LOADENCRYPTED1    B/ NO, THIS MACHINE HAS MASK-ROM --> NO SELECT BANK!
        ;LDX    $FFFE   LOCATE SELECT BANK VIA RESTART VECTOR
        LDX     $FFFE
        ;LDX    1,X     CALL SELECTBANK TO VERIFY THAT IT REALLY WORKS!
        LDX     1,X
        CLRA              SELECT BANK 0
        ;JSR    [ERASEBANK-RESTART+1,X]
        LDX     ERASEBANK-RESTART+1,X
        JSR     0,X
LOADENCRYPTED1
        ;LDB     DECRYPTBUFFER+1   GET KEY COUNT FROM TYPE 5 RECORD
        LDAB      DECRYPTBUFFER+1
        ;STB     NKEYS   = # OF KEYS ENCODED
        STAB      NKEYS
        ;LDX    #SDOSSECRETKEY
        LDX     #SDOSSECRETKEY
        ;JSR    SETKEY  TO START DECRYPT CASCADE THAT GENERATES KEY
        JSR     SETKEY
        ;LDX    #DECRYPTBUFFER    START CASCADE OF DECRYPTING 05 RECORD
        LDX     #DECRYPTBUFFER
        ;JSR    DECRYPT  THIS RANDOMIZES AS MUCH AS ENCRYPT
        JSR     DECRYPT
        ;JSR    SETKEY  SET KEY TO CONTENTS OF BUFFER
        JSR     SETKEY
        ;CLR     OKTODECRYPTFLAG   FLAG 'NO SERIAL NUMBER MATCHES'
        CLR      OKTODECRYPTFLAG
LOADCASCADELOOP ; PROCESS SERIAL NUMBERS BY CASCADING THEM
        ;LDX    #FILLDECRYPTBUFFER READ IN THE NEXT SERIAL NUMBER
        LDX     #FILLDECRYPTBUFFER
        ;JSR    SYSCALLENTRY
        JSR     SYSCALLENTRY
        IF      M6800!M6801
        ;LDX    #DECRYPTBUFFER    = COMPARE "TO" ADDRESS
        LDX     #DECRYPTBUFFER
        STX     TOPOINTER
        ELSE    (M6809)
        LDY     #DECRYPTBUFFER
        FIN
        BSR      GETSERIALNUMBERADDRESS     GET POINTER TO SERIAL NUMBER IN ROM
        ; ASSERT: GETSERIALNUMBERADDRESS SETS (D) TO 8
        ;JSR    BLOCKCOMPARE        COMPARE DECRYPTBUFFER AGAINST ROM SERIAL NUMBER
        JSR     BLOCKCOMPARE
        TPA              HAS 4'S BIT SET IF MATCHED
        ANDA      #4      = 0 IF NO MATCH, <>0 IF MATCH
*       SET OKTODECRYPTFLAG IF THERE IS A MATCH
*       DON'T USE CONDITIONAL BRANCH AS THEY ARE EASY TO FIND
*
        ;EORA    OKTODECRYPTFLAG   NOW SET FLAG IF OK TO DECRYPT
        EORA     OKTODECRYPTFLAG
        ;STA     OKTODECRYPTFLAG
        STAA      OKTODECRYPTFLAG
*** IF DECRYPT KEY WERE FUNCTION OF ROM, THEN WE WOULD NOT HAVE TO CHECK SERIAL
*** NUMBER IN ROM AT ALL; SIMPLY TRY TO LOAD IT. ILLEGAL LOAD RECORD REPORTS AS
*** WRONG SERIAL NUMBER!
        ;LDX    #DECRYPTBUFFER    START CASCADE OF DECRYPTING 05 RECORD
        LDX     #DECRYPTBUFFER
        ;JSR    DECRYPT  THIS RANDOMIZES AS MUCH AS ENCRYPT
        JSR     DECRYPT
        ;JSR    SETKEY  SET KEY TO CONTENTS OF BUFFER
        JSR     SETKEY
        ;DEC     NKEYS   PROCESSED A KEY...
        DEC      NKEYS
        BNE      LOADCASCADELOOP      B/ MORE KEYS TO PROCESS
        TST     OKTODECRYPTFLAG   DID WE FIND A MATCHING SERIAL NUMBER?
        ;LBEQ    ERRSERIALNOWRONG
        BNE      MACRO:0010
        JMP     ERRSERIALNOWRONG
MACRO:0010
*
*       AT THIS POINT, THE DECRYPTION KEY FOR THE OBJECT RECORDS IS COMPLETE
*       NOW WE START THE ACTUAL LOADING PROCESS
*       WE STILL CHECK FOR OBJECT FILE FORMAT IN CASE THE DECRYPTION KEY IS BAD
        PAGE
*       NOW GENERATE AN ENCRYPTED VERSION OF THE DECRYPTION KEY...
*       SO THAT CHAIN/LOAD CAN COMPARE TO OLD VERSION OF "DECRYPTION" KEY
*
        ;jsr    decrypt "Encrypt" the key using itself
        JSR     decrypt
        IF      M6800!M6801
        ;LDX    #NEWKEYENCRYPTED = "TO" ADDRESS
        LDX     #NEWKEYENCRYPTED
        STX     TOPOINTER
        ELSE    (M6809)
        LDY     #NEWKEYENCRYPTED
        FIN
        ;LDX    #DECRYPTBUFFER    = FROM ADDRESS
        LDX     #DECRYPTBUFFER
        ;LDD    #8      = SIZE OF KEY
        LDAB      #(8)&$FF
        LDAA      #(8)/256
        ;JSR    BLOCKMOVE SAVE NEWKEY, ENCRYPTED FOR LATER COMPARISION
        JSR     BLOCKMOVE
*       LDX     #DECRYPTBUFFEREND SET UP TO GET PRESUMED TYPE1 RECORD CODE
        STX     DECRYPTBUFPTR
        ;JSR    GETBYTE GET ME A BYTE
        JSR     GETBYTE
        ;jmp    loadstart       go process type1 load record
        JMP     loadstart

        FCB       $CE      TO THROW OFF WOULD-BE DISASSEMBLERS
SDOSSECRETKEY FCB $4C,$B0,$B7,$4E,$9B,$65,$72,$C9
        PAGE
LOADSETPOS       ; SYSCALL TO POSITION LOAD FILE PAST SKIP RECORD
        FCB       SYSCALL:CONTROL    USED BY LOADER TO EXECUTE "SKIP N BYTES"
        FCB       CONTROL:SCLEN+4
        FCB       SYSCHANNEL
        FCB       CC:POSITION
        FDB      LOADFILEPOS      POINTER TO POSITION SELECT BUFFER
        FDB      4       SIZE OF POSITION SELECT BUFFER

LOADTYPE0        ; IGNORE "LOADCOUNT" BYTES (ASSERT: CANNOT OCCUR IN ENCRYPTED FILES!!!)
        ;JSR    GETWORD
        JSR     GETWORD
LOADTYPE0L       ; USE UP BYTES IN DECRYPT BUFFER
        ;STD    LOADCOUNT SAVE # BYTES TO SKIP
        STAB      LOADCOUNT+1
        STAA      LOADCOUNT
        ;LDX    DECRYPTBUFFER     USE UP BYTES IN DECRYPTBUFFER, FIRST
        LDX     DECRYPTBUFFER
        CPX      #DECRYPTBUFFEREND DECRYPT BUFFER EXHAUSTED?
        BEQ      LOADTYPE0.2      B/ YES
        ;JSR    GETBYTE  NO, USE UP A BYTE
        JSR     GETBYTE
        ;LDD    LOADCOUNT DECREMENT SKIP LOADCOUNT
        LDAB      LOADCOUNT+1
        LDAA      LOADCOUNT
        ;SUBD    #1
        SUBB      #(1)&$FF
        SBCA       #(1)/256
        ;BNED    LOADTYPE0L       B/ MORE BYTES TO SKIP
        BNE      LOADTYPE0L
        TSTB
        BNE      LOADTYPE0L
        BRA       LOADNEXT EXHAUSTED SKIP LOADCOUNT!

LOADTYPE0.2 ; SKIP OVER BIG CHUNK OF BYTES IN FILE
        ;LDX    #LOADGETPOS      GET FILE POSITION
        LDX     #LOADGETPOS
        ;JSR    SYSCALLENTRY
        JSR     SYSCALLENTRY
        ;LDD    BUFFER   ADD LOADCOUNT BYTES TO CURRENT POSITION
        LDAB      BUFFER+1
        LDAA      BUFFER
        ;ADDD    LOADFILEPOS+2
        ADDB      LOADFILEPOS+2+1
        ADCA       LOADFILEPOS+2
        ;STD    LOADFILEPOS+2
        STAB      LOADFILEPOS+2+1
        STAA      LOADFILEPOS+2
        BCC        LOADTYPE0.1
        ;LDX    LOADFILEPOS      PROPOGATE CARRY TO UPPER 16 BITS
        LDX     LOADFILEPOS
        INX
        STX     LOADFILEPOS
LOADTYPE0.1      EQU     *
        ;LDX    #LOADSETPOS      AND POSITION THERE
        LDX     #LOADSETPOS
        ;JSR    SYSCALLENTRY
        JSR     SYSCALLENTRY
        BRA       LOADNEXT
        page
*       LOAD BYTES AND THEN LOOK FOR NEXT RECORD
*
LOADTYPE2
        BSR      LOAD2AND3
*
*       GET NEXT RECORD, TYPE 0, 2, & 3 ALLOWED HERE
*
LOADCONTENTS      ; LOAD CONTENTS OF OBJECT FILE
LOADNEXT ;JSR    GETBYTE
        JSR     GETBYTE
        ;CMPA     #LOAD:TYPE2      DATA RECORD ?
        CMPA      #LOAD:TYPE2
        BEQ      LOADTYPE2        B/ YES
        ;CMPA     #LOAD:TYPE3      LAST DATA RECORD ?
        CMPA      #LOAD:TYPE3
        BEQ      LOADTYPE3        B/ YES
        ;CMPA     #LOAD:TYPE0      SKIP RECORD ?
        CMPA      #LOAD:TYPE0
        BEQ      LOADTYPE0        B/ YES
ERRBADLOADRECORD    EQU     *
        ;JSR    ERRET
        JSR     ERRET
        FDB      ERR:BADLOADRECORD

ERRNOTENOUGHROOM        EQU     *
        ;JSR    ERRET
        JSR     ERRET
        FDB      ERR:NOTENOUGHROOM
        PAGE
*       LOAD BYTES AND THEN QUIT
*
LOADTYPE3 ; LAST LOAD RECORD, LOAD THE BYTES AND QUIT
*
*
*       LOAD BYTES FROM DISK FILE INTO USER SPACE
*
LOAD2AND3 ; LOAD CONTENTS OF TYPE 2 OR TYPE 3 RECORD
        ;JSR    GETWORD GO GET THE LOAD ADDRESS
        JSR     GETWORD
        ;STD    LOADADDRESS
        STAB      LOADADDRESS+1
        STAA      LOADADDRESS
        ;JSR    GETWORD
        JSR     GETWORD
        ;STD    LOADCOUNT
        STAB      LOADCOUNT+1
        STAA      LOADCOUNT
        ;ADDD    LOADADDRESS       = ADDRESS OF LAST BYTE LOADED, +1
        ADDB      LOADADDRESS+1
        ADCA       LOADADDRESS
*
*       LOADBOUNDSCHECK -- MAKE SURE (A,B) <= DRIVER BASE
*       WE SHOULD ALSO CHECK TO MAKE SURE WE ARE LOADING ON TOP OF THE STACK, TOO!
*
        ;LDX    CODE+SDOS:CONFIGURATION
        LDX     CODE+SDOS:CONFIGURATION
        SEC              ACTUALLY TEST FOR (A,B)-1 < DRIVERBASE
        SBCB       CNFG:DRIVERBASE+1,X        ...?
        SBCA       CNFG:DRIVERBASE,X  ...?
        BCC        ERRNOTENOUGHROOM        B/ HE'S DEAD!
LOAD2AND3.1 ; CHECK FOR DONE LOADING BYTES FROM THIS RECORD
        ;LDX    LOADCOUNT ARE WE DONE?
        LDX     LOADCOUNT
        BEQ      LOAD2AND3RTS      B/ YES
LOAD2AND3LOOP ; LOAD SOME BYTES FROM THIS RECORD
        ;LDX    DECRYPTBUFPTR     TRY TO OPTIMIZE THE LOAD PROCESS
        LDX     DECRYPTBUFPTR
        CPX      #DECRYPTBUFFEREND IS THERE STILL STUFF IN THE DECRYPT BUFFER?
        BNE      LOAD2AND3BYTE      B/ STUFF STILL IN THE BUFFER
        ;LDD    LOADCOUNT AT LEAST 8 BYTES TO LOAD?
        LDAB      LOADCOUNT+1
        LDAA      LOADCOUNT
        ANDB      #(\7)&$FF       (D) = MULTIPLE OF 8 BYTES TO LOAD
        ;STD    OPTIMIZEDLOADCOUNT
        STAB      OPTIMIZEDLOADCOUNT+1
        STAA      OPTIMIZEDLOADCOUNT
        ;BEQD    LOAD2AND3BYTE      B/ NOT ENOUGH BYTES TO LOAD
        BNE      MACRO:0011
        TSTB
        BEQ      LOAD2AND3BYTE
MACRO:0011
*
*       LOAD A MULTIPLE OF 8 BYTES INTO MEMORY QUICKLY
*
        ;LDD    LOADCOUNT COMPUTE REMAINING LOADCOUNT AFTER OPTIMIZED LOAD
        LDAB      LOADCOUNT+1
        LDAA      LOADCOUNT
        CLRA
        ANDB      #7      = REMAINING LOADCOUNT AFTER MULTIPLE OF 8 LOADED
        ;STD    LOADCOUNT
        STAB      LOADCOUNT+1
        STAA      LOADCOUNT
        ;LDX    #LOADMULTIPLEOF8
        LDX     #LOADMULTIPLEOF8
        ;JSR    SYSCALLENTRY      EOF WILL OCCUR IF LOAD FILE IS NOT MULTIPLE OF 8 BYTES IN SIZE
        JSR     SYSCALLENTRY
        ;LDX    LOADADDRESS       WHERE TO START DECRYPTING
        LDX     LOADADDRESS
        ;LDD    LOADADDRESS       COMPUTE WHERE TO END DECRYPTING
        LDAB      LOADADDRESS+1
        LDAA      LOADADDRESS
        ;ADDD    OPTIMIZEDLOADCOUNT
        ADDB      OPTIMIZEDLOADCOUNT+1
        ADCA       OPTIMIZEDLOADCOUNT
        ;STD    LOADADDRESS       = 1ST PLACE NOT YET LOADED
        STAB      LOADADDRESS+1
        STAA      LOADADDRESS
        TST     OKTODECRYPTFLAG   ARE WE DECRYPTING?
        BEQ      LOAD2AND3.1       B/ NO, GO LOAD MORE BYTES
LOAD2AND3MASSDECRYPT ; DECRYPT JUST LOADED BLOCK OF BYTES
        ;JSR    DECRYPT  GO DECRYPT A BLOCK OF 8 BYTES
        JSR     DECRYPT
        ;LEAX    8,X     FIND NEXT BLOCK OF 8 BYTES
        IF      8<0
        RPT     -8
        DEX
        ELSE
        RPT     8
        INX
        FIN
        CPX      LOADADDRESS       ALL LOADED BYTES DECRYPTED YET?
        BNE      LOAD2AND3MASSDECRYPT B/ NO, GO DECRYPT SOME MORE
        BRA       LOAD2AND3.1       YES, GO SEE IF MORE BYTES TO LOAD
*
*       LOAD A BYTE THE HARD WAY
*
LOAD2AND3BYTE ; LOAD ONE BYTE THE UNOPTIMIZED WAY
        BSR      GETBYTE
        ;LDX    LOADADDRESS
        LDX     LOADADDRESS
        ;STA     ,X+
        STAA      0,X
        INX
        STX     LOADADDRESS
        ;LDX    LOADCOUNT
        LDX     LOADCOUNT
        DEX
        STX     LOADCOUNT
        BNE      LOAD2AND3LOOP
LOAD2AND3RTS      OKRTS   YOU GUESS...
        PAGE
*
*
GETBYTE ; GET NEXT DECRYPTED BYTE FROM THE FILE INTO (A)
        ;LDX    DECRYPTBUFPTR     IS THE BUFFER EMPTY?
        LDX     DECRYPTBUFPTR
        CPX      #DECRYPTBUFFEREND
        BNE      GETBYTE1 B/ NOPE
        TST     OKTODECRYPTFLAG   BUFFER IS EMPTY, ARE WE DECRYPTING?
        BNE      GETBYTED B/ YES, GO FETCH ANOTHER BUFFERFUL TO DECRYPT
        ;LDX    #GET1BYTE        NO, FETCH NEXT LOAD RECORD HEADER BYTE
        LDX     #GET1BYTE
        ;JSR    SYSCALLENTRY
        JSR     SYSCALLENTRY
        ;LDA     BUFFER   GET THE BYTE
        LDAA      BUFFER
        OKRTS

GETBYTED ; GET NEXT 8 BYTES FROM FILE AND DECRYPT
        ;LDX    #FILLDECRYPTBUFFER
        LDX     #FILLDECRYPTBUFFER
        ;JSR    SYSCALLENTRY
        JSR     SYSCALLENTRY
        ;LDX    #DECRYPTBUFFER    START BUFFER POINTER AT BEGIN BUFFER
        LDX     #DECRYPTBUFFER
        ;JSR    DECRYPT  DECRYPT THE 8 BYTES JUST READ
        JSR     DECRYPT
GETBYTE1 ; FETCH DECRYPTED BYTE FROM BUFFER
        ;LDA     ,X+     GET THE CHAR
        LDAA      0,X
        INX
        STX     DECRYPTBUFPTR
        OKRTS           I'M DONE
*
GETWORD ; GET 2 BYTES FROM THE DISK BUFFER INTO (D)
        BSR      GETBYTE
        PSHA
        BSR      GETBYTE
        TAB
        PULA
        RTS
        page
SETKEY ; SET "KEY" TO 8 BYTES POINTED TO BY (X)
        ;LDD    4,X     COPY KEY BYTES TO INLINE CODE
        LDAB      (4)+1,X
        LDAA      4,X
        ;STB     KEY5    DO SO IN AS APPARENTLY DISORGANIZED WAY AS POSSIBLE
        STAB      KEY5
        ;STA     KEY4
        STAA      KEY4
        ;LDD    0,X
        LDAB      (0)+1,X
        LDAA      0,X
        ;STA     KEY0
        STAA      KEY0
        ;STB     KEY1
        STAB      KEY1
        ;LDD    6,X
        LDAB      (6)+1,X
        LDAA      6,X
        ;STB     KEY7
        STAB      KEY7
        ;STA     KEY6
        STAA      KEY6
        ;LDD    2,X
        LDAB      (2)+1,X
        LDAA      2,X
        ;STA     KEY2
        STAA      KEY2
        ;STB     KEY3
        STAB      KEY3
        RTS

ZAPUSERSPACE       ; OLD DECRYPTION KEY <> NEW, ERASE USER SPACE!
;       Note: If this Trashed the user space, it would be much harder to
;       determine program bounds of decrypted program
        IF      M6800!M6801
        TSX
ZAPUSERSPACEL ; ZAP ANOTHER USER SPACE BYTE
        ;CLR     ,-X
        DEX
        CLR      0,X
        CPX      #$100   STOP ZEROING AT $100
        BNE      ZAPUSERSPACEL
        RTS
        ELSE    (M6809)
        ;LDX    #$100   USE BLOCKMOVE LIKE 360 MVC INSTRUCTION TO ZERO MEMORY
        LDX     #$100
        STX     ,X      ZERO $100 THRU 101, FIRST
        ;DEC     ,X      DON'T YOU LOVE OBSCURE CODE?
        DEC      0,X
        ;LDD    SDOSSTACK = TOP OF SPACE TO ZERO
        LDAB      SDOSSTACK+1
        LDAA      SDOSSTACK
        SUBA      #2      (D) = # BYTES TO CLEAR, NOT COUNT PZ AND 256 BYTES OF STACK
        LEAY     2,X     WHERE TO MOVE STUFF TO...
        ;JMP    BLOCKMOVE NOT SECURE TO CALL CODE+SDOS:BLOCKMOVE
        JMP     BLOCKMOVE
        FIN
        PAGE     DISK FILE/DEVICE DRIVER
*       DISK DEVICE DRIVER ENTRY VECTOR
*
DISKDEVICEDRIVER EQU     *
        FDB      DSKDOPEN        OPEN
        FDB      DSKDCLOSE        CLOSE
        FDB      DSKDREADA READA
        FDB      DSKDWRITEA       WRITEA
        FDB      DSKDREADB READB
        FDB      DSKDWRITEB       WRITEB
        FDB      DSKDOPEN        CREATE
        FDB      ILLDEVICEOP      RENAME
        FDB      ILLDEVICEOP      DELETE
        FDB      DSKDCONTROL      CONTROL
        FDB      DSKDSTATUS       STATUS
        FDB      DISKRTS RESET
        FDB      ILLDEVICEOP      PFRESTART

ILLDEVICEOP      ; ILLEGAL DEVICE OPERATION ATTEMPTED
        ;JSR    ERRET
        JSR     ERRET
        FDB      ERR:ILLDEVICEOP
*
DISKRTS OKRTS
        PAGE
*
*       DISK FILE DRIVER ENTRY VECTOR
*
DISKFILEDRIVER  EQU     *
        FDB      DSKFOPEN
        FDB      DSKFCLOSE
        FDB      DSKFREADA
        FDB      DSKFWRITEA
        FDB      DSKFREADB
        FDB      DSKFWRITEB
        FDB      DSKFCREATE
        FDB      DSKFRENAME
        FDB      DSKFDELETE
        FDB      DSKFCONTROL
        FDB      DSKFSTATUS
        FDB      DSKFRESET
        FDB      DSKFPFRESTART
*
*       DSKFPFRESTART -- DISK FILE DRIVER POWER FAIL RESET
*
DSKFPFRESTART    EQU     *
        ;JSR    ERRET
        JSR     ERRET
        FDB      ERR:PWRFAILDISKF
        PAGE
*
*       DSKFCREATE -- CREATE A NEW DISK FILE
*
DSKFCREATE        EQU     *
        ;JSR    PLANTDCBINIOCB       SO DISK I/O ROUTINES CAN FIND DRIVERS
        JSR     PLANTDCBINIOCB
        ;JSR    PARSEFILENAME     GO PROCESS THE DISK FILE NAME
        JSR     PARSEFILENAME
        ;JSR    SEARCHDIRCREATE     GO FIND OUT IF FILE ALREADY EXISTS
        JSR     SEARCHDIRCREATE
        ;JSR    SEARCHFCBINIT       SET UP TO SEARCH FCBS
        JSR     SEARCHFCBINIT
        ;JSR    SEARCHFCBS  IS FILE OPEN ALREADY?
        JSR     SEARCHFCBS
        BCS       DSKFCREATE1       B/ FILE IS NOT OPEN ANYWHERE
        LDAA      FCB:FLAGS,X        FILE BY THAT NAME IS ALREADY OPEN
        BITA      #FCBFLG::NEWFILE  A NEW FILE ?
        BNE      ERRFILEINCREATE   B/ FILE ALREADY BEING CREATED
*       LDAA      FILEREPLACEMENTFLAG        IS "!" PRESENT TO ALLOW FILE OVERWRITE?
*       BNE      ERROLDFILEEXISTS        B/ NO, CAN'T OVERWRITE OLD FILE!
        LDAA      FCB:PROT,X        IS OLD FILE WRITE PROTECTED ?
        BITA      #PROT::WRITE    IS FILE WRITE PROTECTED ?
        BNE      ERRFILEWRTPROT  B/ YES, CAN'T CREATE A NEW ONE
        ;JSR    SEARCHFCBS  OLD FILE IS OPEN ALREADY
        JSR     SEARCHFCBS
        BCS       DSKFCREATEF       B/ NO REPLACEMENT EXISTS FOR OLD FILE
ERRFILEINCREATE   ; FILE BY THAT NAME IS BEING CREATED
        ;JSR    ERRET
        JSR     ERRET
        FDB      ERR:FILEINCREATE
        PAGE
DSKFCREATE1       ; OLD VERSION OF FILE IS NOT OPEN
        ;LDX    DIRENTRY        IS DIRECTORY ENTRY A FREE ENTRY?
        LDX     DIRENTRY
        LDAA      DIR:HCSIC,X
        BEQ      DSKFCREATEC        B/ YES, GO COPY NAME TO DIRECTORY
*       LDAA      FILEREPLACEMENTFLAG        IS "!" PRESENT TO ALLOW FILE OVERWRITE?
*       BNE      ERROLDFILEEXISTS        B/ NO, CAN'T OVERWRITE OLD FILE!
        LDAA      DIR:PROTECTION,X NO, IS OLD FILE DELETE PROTECTED ?
        BITA      #PROT::WRITE    IS FILE WRITE PROTECTED ?
        BEQ      DSKFCREATEF       B/ NO, WE CAN DO THE CREATE
ERRFILEWRTPROT  EQU     *
        ;JSR    ERRET
        JSR     ERRET
        FDB      ERR:FILEWRTPROT

*       UPDATEFILEDATE -- SET CREATION DATE OF FILE TO CURRENT DATE
*       THIS ROUTINE IS CALLED WHENEVER A FILE IS MODIFIED
*       FCBPOINTER SPECIFIES WHICH FILE
*
UPDATEFILEDATE
        ;LDX    FCBPOINTER        GET POINTER TO DESIRED FILE
        LDX     FCBPOINTER
        ;LDA     FCB:PROT,X        IS FILE WRITE PROTECTED?
        LDAA      FCB:PROT,X
        BITA      #PROT::WRITE    ...?
        BNE      ERRFILEWRTPROT  B/ YES, DON'T ALLOW UPDATE!
        ;LDB     CODE+SDOS:DAY     STAMP THE FCB WITH THE CREATION DATE
        LDAB      CODE+SDOS:DAY
        BEQ      ERRTIMENOTSET   B/ TIME NOT SET, CANNOT MODIFY FILE!
        ANDA      #(\PROT::BACKUP)&$FF       TURN OFF "FILE IS BACKED UP" FLAG
        ;STA     FCB:PROT,X
        STAA      FCB:PROT,X
        ;STB     FCB:DAY,X  TIME STAMP FILE WITH DATE OF CHANGE
        STAB      FCB:DAY,X
        ;LDD    CODE+SDOS:MONTH
        LDAB      CODE+SDOS:MONTH+1
        LDAA      CODE+SDOS:MONTH
        ;STD    FCB:MONTH,X
        STAB      (FCB:MONTH)+1,X
        STAA      FCB:MONTH,X
        ;LDA     FCB:FLAGS,X        UPDATE FILE FLAGS...
        LDAA      FCB:FLAGS,X
        ORAA      #FCBFLG::UPDATEDIR!FCBFLG::MODIFIED  REMEMBER THAT THIS DATA MUST GO TO DISK
        STAA      FCB:FLAGS,X
        OKRTS

ERRTIMENOTSET ; CLOCK DATE IS ZEROED, CAN'T CREATE A FILE!
        ;JSR    ERRET
        JSR     ERRET
        FDB      ERR:TIMENOTSET
        PAGE
DSKFCREATEC        EQU     *
        ;JSR    COPYNAMETODIR     COPY FILE NAME TO DIRENTRY
        JSR     COPYNAMETODIR
DSKFCREATEF       ; NOW CREATE A NEW FILE IN AN FCB
***     JSR     DRIVER:WRTPROTCHECK       VERIFY THAT DISK DRIVE IS NOT WRITE PROTECTED
        ;JSR    FINDFREEFCB       GO FIND AN FCB TO USE
        JSR     FINDFREEFCB
        ;CLR     FCB:HCSIC,X INITIALIZE FCB FOR NEW FILE
        CLR      FCB:HCSIC,X
        ;CLR     FCB:FILESIZE,X    RESET FILE SIZE TO ZIP
        CLR      FCB:FILESIZE,X
        ;CLR     FCB:FILESIZE+1,X
        CLR      FCB:FILESIZE+1,X
        ;CLR     FCB:FILESIZE+2,X
        CLR      FCB:FILESIZE+2,X
        ;CLR     FCB:FILESIZE+3,X
        CLR      FCB:FILESIZE+3,X
        LDAA      #FCBFLG::NEWFILE  MARK FCB AS "NEW FILE"
        STAA      FCB:FLAGS,X
        ;CLR     FCB:PROT,X        RESET THE PROTECTION BITS
        CLR      FCB:PROT,X
        BSR      UPDATEFILEDATE    UPDATE FILE DATE
        BCS       DSKFCREATEOOPS    B/ TIME NOT SET, CAN'T CREATE FILE!
        ;JSR    DSKFOPEN1       GO SET UP IOCB TO REMEMBER FCB
        JSR     DSKFOPEN1
        ;CLR     IOCB:RDCN,X        TELL ALLOCATOR TO START ...
        CLR      IOCB:RDCN,X
        LDAA      #1      WITH RDCN 1 (= 1ST DATA CLUSTER)
        STAA      IOCB:RDCN+1,X
        ;LDX    FILESIZERQSTD   DID USER SPECIFY INITIAL FILESIZE ?
        LDX     FILESIZERQSTD
        BNE      DSKFCREATE3       B/ YES, USE SPECIFIED FILE SIZE
        ;LDX    FILESIZERQSTD+2
        LDX     FILESIZERQSTD+2
        BEQ      DSKFCREATEMIN     B/ NO, USE MINIMUM ALLOCATION
DSKFCREATE3       EQU     *
        ;LDX    IOCBPOINTER       COPY FILESIZE DESIRED...
        LDX     IOCBPOINTER
        ;LDD    FILESIZERQSTD   TO IOCB:CURBYTE SO WE CAN USE COMPUTERDCN...
        LDAB      FILESIZERQSTD+1
        LDAA      FILESIZERQSTD
        ;STD    IOCB:CURBYTE,X      TO DETERMINE HOW MANY CLUSTERS TO ALLOCATE
        STAB      (IOCB:CURBYTE)+1,X
        STAA      IOCB:CURBYTE,X
*** NOTE: THIS CAN ACTUALLY ALLOCATE 1 CLUSTER TOO MANY, SINCE...
*       COMPUTERDCN COMPUTES CLUSTER # THAT CONTAINS THE SPECIFIED BYTE!
*       TO BE EXACT, NEED TO SUBTRACT 1 FROM "CURBYTE"
*       BUT THATS OK, SINCE CLOSE WILL FREE THE EXTRA CLUSTER
        ;LDD    FILESIZERQSTD+2
        LDAB      FILESIZERQSTD+2+1
        LDAA      FILESIZERQSTD+2
        ;STD    IOCB:CURBYTE+2,X
        STAB      (IOCB:CURBYTE+2)+1,X
        STAA      IOCB:CURBYTE+2,X
        ;JSR    COMPUTERDCN       COMPUTE # DATA CLUSTERS NEEDED
        JSR     COMPUTERDCN
        BCS       DSKFCREATEOOPS    B/ SOME ERROR OCCURRED!
        BRA       DSKFCREATEALLOC     GO ALLOCATE THE DISK SPACE
        PAGE
DSKFCREATEMIN     ; USE MINIMUM ALLOCATION
        ;LDX    DCBPOINTER        WE NEED THIS, SO WE CAN...
        LDX     DCBPOINTER
        ;LDD    DSKINFO:MINALLOC,X        USE MIN ALLOCATION FOR FILE CREATES
        LDAB      (DSKINFO:MINALLOC)+1,X
        LDAA      DSKINFO:MINALLOC,X
DSKFCREATEALLOC     ; ALLOCATE SPACE TO A NEW FILE
        ;JSR    ALLOCATECLUSTERS    GO INVENT NEW FILE HEADER CLUSTER
        JSR     ALLOCATECLUSTERS
        BCS       DSKFCREATEE       B/ RAN OUT OF DISK SPACE
DSKFCREATE2       EQU     *
        BRA       DSKFOPEN1       RESET THE IOCB TO MAKE SURE RDCN=DUMMY

DSKFCREATEE       ; RAN OUT OF DISK SPACE WHILE ALLOCATING FILE
        CPX      #ERR:NODISKSPACE  DOUBLE-CHECK, MIGHT BE SOMETHING ELSE
        BNE      DSKFCREATEOOPS    IT WAS SOMETHING ELSE, CLOSE UP SHOP!
        ;LDX    FCBPOINTER        RAN OUT OF SPACE ALRIGHT!
        LDX     FCBPOINTER
        ;LDX    FCB:NCLUSTERS,X    WAS HEADER CLUSTER ALLOCATED?
        LDX     FCB:NCLUSTERS,X
        BNE      DSKFCREATE2       B/ YES, TREAT LIKE NORMAL FILE CREATE
DSKFCREATEOOPS    ; DIDN'T CREATE FILE, OR SOME OTHER PROBLEM
        ;LDX    FCBPOINTER        FREE THE FCB, ITS NOT VALID ANYWAY
        LDX     FCBPOINTER
        ;CLR     FCB:REFCOUNT,X
        CLR      FCB:REFCOUNT,X
        ;JMP    ERRORED AND TRAP UPWARDS
        JMP     ERRORED
        PAGE
*
*       DSKFOPEN -- OPEN A DISK FILE
*       ON ENTRY DCBPOINTER HAS BEEN SET UP
*
DSKFOPEN        EQU     *
        ;JSR    PLANTDCBINIOCB       SO DISK I/O ROUTINES CAN FIND DRIVERS
        JSR     PLANTDCBINIOCB
        ;JSR    PARSEFILENAME     GO PROCESS THE DISK FILE NAME
        JSR     PARSEFILENAME
        ;JSR    SEARCHDIR GO LOOK IT UP IN DIRECTORY
        JSR     SEARCHDIR
        LDAA      DIR:HCSIC,X       DOES FILE EXIST ?
        BEQ      ERRFILENOTFNDJ  B/ NOPE
        ;JSR    SEARCHFCBINIT       SET UP TO SEARCH FCBS
        JSR     SEARCHFCBINIT
DSKFOPENL       EQU     *
        ;JSR    SEARCHFCBS  SEE IF FILE ALREADY OPENED
        JSR     SEARCHFCBS
        BCS       DSKFOPEN0       NO FCB SET UP FOR FILE
        LDAA      FCB:FLAGS,X        IS THE FCB FOR A NEW FILE ?
        BITA      #FCBFLG::NEWFILE  ...?
        BNE      DSKFOPENL       B/ YES, TREAT AS IF FCB DIDN'T EXIST
        ;INC     FCB:REFCOUNT,X     NO, FCB IS ALREADY SET UP FOR FILE
        INC      FCB:REFCOUNT,X
        BRA       DSKFOPEN1       PLACE HOLD ON FCB AND GO OPEN
        PAGE
DSKFOPEN0       ; NO FCB EXISTS FOR FILE YET
        ;JSR    FINDFREEFCB       OOPS, NO FCB FOR THIS FILE YET
        JSR     FINDFREEFCB
DSKFOPEN1       ; ENTRY POINT FOR DSKFOPENERRORFILE
        ;LDX    IOCBPOINTER       NOW FILL IN THE IOCB
        LDX     IOCBPOINTER
        ;LDD    FCBPOINTER        REMEMBER THE FCB ADDRESS
        LDAB      FCBPOINTER+1
        LDAA      FCBPOINTER
        ;STD    IOCB:FCB,X
        STAB      (IOCB:FCB)+1,X
        STAA      IOCB:FCB,X
        ;CLR     IOCB:CURBYTE,X      ASSUME WE WILL START ...
        CLR      IOCB:CURBYTE,X
        ;CLR     IOCB:CURBYTE+1,X    AT BYTE ZERO OF THE FILE
        CLR      IOCB:CURBYTE+1,X
        ;CLR     IOCB:CURBYTE+2,X
        CLR      IOCB:CURBYTE+2,X
        ;CLR     IOCB:CURBYTE+3,X
        CLR      IOCB:CURBYTE+3,X
        ;CLR     IOCB:LOCATEDF,X     MARK "LOCATE OPERATION NEEDED"
        CLR      IOCB:LOCATEDF,X
        ;LDD    #DUMMYLCN        SET "LAST EXAMINED DATA CLUSTER"...
        LDAB      #(DUMMYLCN)&$FF
        LDAA      #(DUMMYLCN)/256
        ;STD    IOCB:RDCN,X
        STAB      (IOCB:RDCN)+1,X
        STAA      IOCB:RDCN,X
        ;CLR     IOCB:DRDSI,X      MARK RDSI POINTERS AS "MUST BE READ"
        CLR      IOCB:DRDSI,X
        ;CLR     IOCB:DRDSI+1,X
        CLR      IOCB:DRDSI+1,X
        ;CLR     IOCB:HRDSI,X
        CLR      IOCB:HRDSI,X
        ;CLR     IOCB:HRDSI+1,X
        CLR      IOCB:HRDSI+1,X
        LDAA      #-1     SET HRSN = "NONE"
        STAA      IOCB:HRSN,X
        ;CLR     IOCB:COLCNT,X       START OUT ON COLUMN 0
        CLR      IOCB:COLCNT,X
        ;JSR    DSKFEOFTEST     AFTER ALL, THE FILE MIGHT BE (SIGH!) EMPTY!
        JSR     DSKFEOFTEST
        BCS       *+2     IGNORE EOF HIT ERROR
        ;LDX    IOCBPOINTER       BECUZ EOF TEST BOMBS (X)!
        LDX     IOCBPOINTER
        OKRTS
*
*       DSKFOPENSYSIOCB -- SET UP SYSIOCB AS THOUGH "OPEN" WAS CALLED
*
DSKFOPENSYSIOCB   EQU     *
        ;LDX    #SYSIOCB  SET UP IOCBPOINTER
        LDX     #SYSIOCB
        STX     IOCBPOINTER
        ;LDX    DCBPOINTER        POKE DCB ADDRESS INTO IOCB
        LDX     DCBPOINTER
        STX     SYSIOCB+IOCB:DCB
        ;LDX    #DISKFILEDRIVER SET UP FILE DRIVER
        LDX     #DISKFILEDRIVER
        STX     SYSIOCB+IOCB:DRIVER
        BRA       DSKFOPEN1       GO SET UP REST OF IOCB FOR FILE I/O
        PAGE
*
*       DSKFDELETE -- DELETE A DISK FILE
*
DSKFDELETE      EQU     *
        ;JSR    PARSEFILENAME     GO PROCESS THE DISK FILE NAME
        JSR     PARSEFILENAME
        ;JSR    SEARCHDIR GO LOOK IT UP IN DIRECTORY
        JSR     SEARCHDIR
        LDAA      DIR:HCSIC,X       IS THIS DIRECTORY SLOT BUSY ?
ERRFILENOTFNDJ  EQU     *
        BEQ      ERRFILENOTFOUND B/ NO, NO FILE TO DELETE !
        ;JSR    SEARCHFCBINIT       SET UP TO SEARCH FCBS
        JSR     SEARCHFCBINIT
DSKFDELETEL     EQU     *
        ;JSR    SEARCHFCBS  IS THE FILE ALREADY OPENED?
        JSR     SEARCHFCBS
        BCS       DSKFDELETE1     B/ NO, MUST SET UP FCB TO DELETE
        LDAA      FCB:FLAGS,X        A NEWLY CREATED FILE?
        BITA      #FCBFLG::NEWFILE  ...?
        BNE      DSKFDELETEL     B/ YES, IGNORE THIS FCB
        LDAB      FCB:PROT,X        SINCE FILE IS OPEN...
        BITB      #PROT::WRITE    FCB IS MORE UP-TO-DATE THAN DIRECTORY
        BNE      ERRFILEWRTPROTJ B/ FILE HAS BEEN WRITE PROTECTED
        ORAA      #FCBFLG::DELETED  NEITHER ONE, FORCE DELETION OF FILE ...
        STAA      FCB:FLAGS,X        WHEN IT IS CLOSED
DSKFDELETEDE    ; DELETE DIRECTORY ENTRY
        ;JSR    LOCATEDIRENTRY    ZAP THE DIRECTORY ENTRY NOW!
        JSR     LOCATEDIRENTRY
        ;CLR     DIR:HCSIC,X       SO FILE NO LONGER APPEARS TO EXIST
        CLR      DIR:HCSIC,X
        ;JSR    MARKMODIFIED     MARK DIRECTORY SECTOR AS MODIFIED
        JSR     MARKMODIFIED
        OKRTS
        PAGE
DSKFDELETE1     ; MUST SET UP FCB TO DELETE FILE
        ;LDX    DIRENTRY
        LDX     DIRENTRY
        LDAA      DIR:PROTECTION,X IS FILE WRITE PROTECTED?
        BITA      #PROT::WRITE
        BNE      ERRFILEWRTPROTJ B/ YES, CAN'T DELETE
        ;JSR    FINDFREEFCB       INVENT AN FCB FOR THIS STUNT
        JSR     FINDFREEFCB
DSKFDELETEFCB     ; DELETE FILE REPRESENTED BY FCB POINTER
        BSR      DSKFDELETEDE    DELETE THE DIRECTORY ENTRY
DSKFDELETESYSIOCB ; DELETE FILE USING SYSTEM IOCB
        BSR      DSKFOPENSYSIOCB   SET UP USING SYSIOCB
DSKFDELETEIOCBFCB ; DELETE FILE REPRESENTED BY IOCBPOINTER AND FCBPOINTER
        ;LDX    IOCBPOINTER       (DIRENTRY ALREADY DELETED)
        LDX     IOCBPOINTER
        ;CLR     IOCB:RDCN,X        MARK ZEROTH CLUSTER AS START POINT OF DELETE
        CLR      IOCB:RDCN,X
        ;CLR     IOCB:RDCN+1,X
        CLR      IOCB:RDCN+1,X
        ;LDX    FCBPOINTER        DELETE ALL THE CLUSTERS ...
        LDX     FCBPOINTER
        ;CLR     FCB:REFCOUNT,X     LET GO OF THIS FCB
        CLR      FCB:REFCOUNT,X
        ;LDD    FCB:NCLUSTERS,X
        LDAB      (FCB:NCLUSTERS)+1,X
        LDAA      FCB:NCLUSTERS,X
        ;JSR    FREECLUSTERS
        JSR     FREECLUSTERS
        ;LDX    #0      MARK SYSIOCB...
        LDX     #0
        STX     SYSIOCB+IOCB:DRIVER AS CLOSED
        OKRTS

ERRFILEWRTPROTJ
        ;JMP    ERRFILEWRTPROT
        JMP     ERRFILEWRTPROT

ERRFILENOTFOUND EQU     *
        ;JSR    ERRET
        JSR     ERRET
        FDB      ERR:FILENOTFOUND
        PAGE
*
*       DSKFCLOSE -- CLOSE A DISK FILE
*
DSKFCLOSE        EQU     *
        ;JSR    GETFCBFROMIOCB      SET UP FCBPOINTER
        JSR     GETFCBFROMIOCB
        ;LDX    FCBPOINTER        IS FILE OPEN ON MORE THAN ONE CHANNEL ?
        LDX     FCBPOINTER
        ;DEC     FCB:REFCOUNT,X     IF SOME OTHER CHANNEL HAS THIS FILE OPEN ...
        DEC      FCB:REFCOUNT,X
        BNE      DSKFCLOSEOKRTS   WE'LL LET HIM DO THE CLEANUP WHEN HE CLOSES
        LDAA      FCB:FLAGS,X        HAS THIS FILE BEEN DELETED FROM DIRECTORY?
        BITA      #FCBFLG::DELETED
        BNE      DSKFDELETEIOCBFCB   B/ YES, LET'S DELETE IT!
        BITA      #FCBFLG::MODIFIED HAS FILE BEEN MODIFIED ?
        BEQ      DSKFCLOSE1       B/ NO, DON'T TRUNCATE!
*
*       NOW SHORTEN UP THE FILE (CHOP OFF ALL DATA CLUSTERS PAST EOF)
*
        ;JSR    DSKFPOSITIONTOEND       POSITION TO END OF FILE
        JSR     DSKFPOSITIONTOEND
        ;JSR    COMPUTERDCN       FIND RELATIVE DATA CLUSTER OF EOF
        JSR     COMPUTERDCN
        BCS       DSKFCLOSE1       B/ OFF END OF HEADER CLUSTER, NOTHING TO DEALLOCATE
        ;ADDD    #1      ROUND UP TO NEXT DATA CLUSTER
        ADDB      #(1)&$FF
        ADCA       #(1)/256
        ;STD    IOCB:RDCN,X        AND START DELETING THERE
        STAB      (IOCB:RDCN)+1,X
        STAA      IOCB:RDCN,X
        CLRA              (D):=0 --> DELETE TILL END OF HEADER CLUSTER
        CLRB
        ;JSR    FREECLUSTERS     GO CHOP OFF THE FILE
        JSR     FREECLUSTERS
DSKFCLOSE1
        ;LDX    FCBPOINTER        FILE HAS BEEN SHORTENED TO MATCH FILESIZE
        LDX     FCBPOINTER
        ;LDA     FCB:FLAGS,X        LOOK AT THE FLAGS AGAIN
        LDAA      FCB:FLAGS,X
        BITA      #FCBFLG::NEWFILE  A NEW FILE?
        BEQ      DSKFCLOSEOLD     B/ NO
        ORAA      #FCBFLG::UPDATEDIR CHANGE FILE STATUS
        STAA      FCB:FLAGS,X        SO DIRECTORY WILL GET UPDATED
        ;JSR    LOCATEDIRENTRY    GO GET THE DIRECTORY ENTRY
        JSR     LOCATEDIRENTRY
        LDAA      DIR:HCSIC,X       IS THERE AN OLD FILE HERE?
        BEQ      DSKFCLOSEOLD     B/ NO, TREAT LIKE UPDATE DIRECTORY
*
*       MUST DELETE OLD VERSION OF FILE
*
        ;JSR    SEARCHFCBINIT       IS OLD FILE OPEN ON SOME CHANNEL?
        JSR     SEARCHFCBINIT
        ;JSR    SEARCHFCBS  SEE IF ANOTHER FCB MATCHES
        JSR     SEARCHFCBS
        BCS       DSKFCLOSEDOLD1   B/ NO, JUST DELETE IT
        LDAA      FCB:FLAGS,X        MARK FCB OF OLD FILE...
        ORAA      #FCBFLG::DELETED  AS 'DELETED'
        STAA      FCB:FLAGS,X        SO OLD FILE WILL GO AWAY ...
        ;LDX    IOCBPOINTER       WHEN IT IS CLOSED
        LDX     IOCBPOINTER
        ;LDX    IOCB:FCB,X  GET THE FCB OF THE NEW FILE BACK
        LDX     IOCB:FCB,X
        STX     FCBPOINTER
DSKFCLOSEOLD     ; OLD FILE TO BE CLOSED
        ;JSR    UPDATEDIRFROMFCB   GO UPDATE THE DIRECTORY IF NEEDED
        JSR     UPDATEDIRFROMFCB
DSKFCLOSEOKRTS   EQU     *
        OKRTS
        PAGE
DSKFCLOSEDOLD1   ; OLD VERSION OF FILE IS NOT OPEN
        ;LDX    IOCBPOINTER       DAMN! MARK THIS FCB AS BUSY AGAIN
        LDX     IOCBPOINTER
        ;LDX    IOCB:FCB,X
        LDX     IOCB:FCB,X
        ;INC     FCB:REFCOUNT,X     (SET REFCOUNT TO 1)
        INC      FCB:REFCOUNT,X
        ;JSR    FINDFREEFCB       COPY OLD FILE INFORMATION
        JSR     FINDFREEFCB
        STX     SYSFCBPOINTER     AND REMEMBER WHERE WE PUT IT
        ;LDX    IOCBPOINTER       RESTORE FCBPOINTER TO NEW FILE
        LDX     IOCBPOINTER
        ;LDX    IOCB:FCB,X
        LDX     IOCB:FCB,X
        ;CLR     FCB:REFCOUNT,X     NOW LET GO OF NEW FCB AGAIN
        CLR      FCB:REFCOUNT,X
        STX     FCBPOINTER        SINCE SETUPFCB STOMPED ON FCBPOINTER
        ;JSR    UPDATEDIRFROMFCB   TO RECORD NEW FILE
        JSR     UPDATEDIRFROMFCB
        ;LDX    SYSFCBPOINTER     SET UP FCBPOINTER...
        LDX     SYSFCBPOINTER
        STX     FCBPOINTER        TO SELECT OLD FILE TO BE DELETED
        ;JMP    DSKFDELETEIOCBFCB   NOW GO DELETE FILE REPRESENTED BY FCBPOINTER
        JMP     DSKFDELETEIOCBFCB
        PAGE
*
*       DSKFRENAME -- RENAME A DISK FILE
*
DSKFRENAME       EQU     *
        ;JSR    GETFCBFROMIOCB      GET FCB ADDRESS
        JSR     GETFCBFROMIOCB
        ;JSR    PARSEFILENAME     GO PROCESS THE DISK FILE NAME
        JSR     PARSEFILENAME
        ;LDA     CODE+SDOS:DAY     IS TIME SET ?
        LDAA      CODE+SDOS:DAY
        ;LBEQ    ERRTIMENOTSET   B/ NO, CAN'T RENAME THE FILE!
        BNE      MACRO:0012
        JMP     ERRTIMENOTSET
MACRO:0012
        ;LDX    FCBPOINTER        MAKE SURE WE CAN RENAME THE FILE
        LDX     FCBPOINTER
        LDAA      FCB:PROT,X        GET PROTECTION BITS
        BITA      #PROT::WRITE    WRITE PROTECTED ?
        ;LBNE    ERRFILEWRTPROT  B/ YES, CAN'T RENAME!
        BEQ      MACRO:0013
        JMP     ERRFILEWRTPROT
MACRO:0013
        LDAA      FCB:FLAGS,X        IS THE FILE ALREADY DELETED ?
        BITA      #FCBFLG::DELETED  ...?
        BNE      ERRFILEALREADYDELETED     B/ YES, CAN'T RENAME IT!
        ;JSR    LOCATEDIRENTRY    PULL IN THE DIRECTORY ENTRY FROM THE DISK
        JSR     LOCATEDIRENTRY
        ;JSR    SEARCHFCBINIT       YES, GO SEE IF ITS BEING CREATED
        JSR     SEARCHFCBINIT
DSKFRENAMEL      EQU     *
        ;JSR    SEARCHFCBS  LOOK FOR AN FCB USING THIS DIRECTORY SLOT
        JSR     SEARCHFCBS
        BCS       DSKFRENAME1      B/ NO, LOOKS GOOD SO FAR
        LDAA      FCB:FLAGS,X        RATS, MUST BE AT LEAST ONE: LOOK AT OPEN FILE
        BITA      #FCBFLG::NEWFILE  IS IT A NEW FILE?
        BEQ      DSKFRENAMEL      B/ NO, IGNORE THIS FCB
        ;JMP    ERRFILEINCREATE
        JMP     ERRFILEINCREATE

DSKFRENAMEERR1   ; DESIRED NAME IS IN USE
        ;JSR    GETFCBFROMIOCB      PUT OLD DIRECTORY ENTRY BACK LIKE IT WAS
        JSR     GETFCBFROMIOCB
        ;LDX    FCBPOINTER        AND THEN GO COMPLAIN!
        LDX     FCBPOINTER
        ;DEC     FCB:DIRDISP+1,X   MAKE DIRENTRY DISPLACEMENT VALID ONCE AGAIN
        DEC      FCB:DIRDISP+1,X
        ;JSR    LOCUPDATEDIRENTRY GO LOCATE DIR ENTRY AND UPDATE IT
        JSR     LOCUPDATEDIRENTRY
ERRNEWFILEEXISTS        EQU     *
        ;JSR    ERRET
        JSR     ERRET
        FDB      ERR:NEWFILEEXISTS

ERRFILEALREADYDELETED     EQU     *
        ;JSR    ERRET
        JSR     ERRET
        FDB      ERR:FILEALREADYDELETED
        PAGE
DSKFRENAME1      ; NO PROBLEM WITH FILE TO BE RENAMED
        ;JSR    GETFCBFROMIOCB      SET FCBPOINTER BACK TO FCB BEING RENAMED
        JSR     GETFCBFROMIOCB
        ;LDX    FCBPOINTER        MAKE SURE THIS FCB DOESN'T MATCH ANY DIRECTORY SLOT
        LDX     FCBPOINTER
        ;INC     FCB:DIRDISP+1,X   BY MAKING DIRENTRY DISPLACEMENT INVALID
        INC      FCB:DIRDISP+1,X
        ;LDX    DIRENTRY        LET GO OF THIS DIRECTORY ENTRY
        LDX     DIRENTRY
        ;CLR     DIR:HCSIC,X       (IN CASE DIRECTORY IS FULL)
        CLR      DIR:HCSIC,X
        ;JSR    MARKMODIFIED     (ALSO PREVENTS SEARCHDIRCREATE FROM GIVING...)
        JSR     MARKMODIFIED
        ;LDX    #FILENAMEBUF      (US THE SAME SLOT BACK, THEREBY REHASHING)
        LDX     #FILENAMEBUF
        ;JSR    SEARCHDIRCREATE     GO LOOK FOR FREE DIRECTORY SLOT
        JSR     SEARCHDIRCREATE
*       NO ERROR CHECK NEEDED, BECAUSE FREE DIRECTORY SLOT IS KNOWN TO BE AVAILABLE
        LDAA      DIR:HCSIC,X       IS DIRECTORY ENTRY BUSY?
        BNE      DSKFRENAMEERR1   B/ YES, CAN'T RENAME TO THIS FILE
        ;JSR    SEARCHFCBINIT       SET UP TO SEARCH FCBS
        JSR     SEARCHFCBINIT
        ;JSR    SEARCHFCBS  DOES MATCHING FCB EXIST?
        JSR     SEARCHFCBS
        BCS       DSKFRENAME2      B/ NOBODY USING THIS SLOT
        ;LDX    IOCBPOINTER       IS THIS SLOT IN USE...
        LDX     IOCBPOINTER
        ;LDX    IOCB:FCB,X  BY FILE BEING RENAMED ?
        LDX     IOCB:FCB,X
        CPX      FCBPOINTER        ...?
        BNE      DSKFRENAMEERR1   B/ NO, NEW NAME IS OCCUPIED!
DSKFRENAME2      EQU     *
        ;JSR    GETFCBFROMIOCB      RESET FCB POINTER SINCE SEARCHFCBS BOMBED IT!
        JSR     GETFCBFROMIOCB
        ;JSR    UPDATEFILEDATE    MAKE SURE DATE IS MODIFIED (ASSERT: NO ERROR POSSIBLE!)
        JSR     UPDATEFILEDATE
        ;JSR    SETUPFCBDIRPOS    GO COPY DIRECTORY ENTRY DATA INTO FCB
        JSR     SETUPFCBDIRPOS
        ;LDX    DIRENTRY        SET UP (X) PROPERLY...
        LDX     DIRENTRY
        ;JSR    UPDATEDIRENTRY   TO SAVE CRITICAL FILE DATA
        JSR     UPDATEDIRENTRY
*       JSR     COPYNAMETODIR     SET UP NEW NAME IN DIRENTRY
*       OKRTS
        PAGE
*
*       COPYNAMETODIR -- COPY "FILENAME" TO DIRENTRY
*               MARKS RDSI AS MODIFIED
*
COPYNAMETODIR     EQU     *
        IF      M6800!M6801
        ;LDX    DIRENTRY        SET UP TARGET POINTER
        LDX     DIRENTRY
        STX     TOPOINTER
        ELSE    (M6809)
        LDY     DIRENTRY
        FIN
        ;LDX    #FILENAMEBUF      GET SOURCE POINTER
        LDX     #FILENAMEBUF
        ;LDD    #DIR:NAMESIZE    AND # BYTES TO COPY
        LDAB      #(DIR:NAMESIZE)&$FF
        LDAA      #(DIR:NAMESIZE)/256
        ;JSR    BLOCKMOVE
        JSR     BLOCKMOVE
*       JSR     MARKMODIFIED     SO DIRECTORY ENTRY WILL GO BACK TO DISK
*       RTS
*
*       MARKMODIFIED -- MARKS RDSI(RDSIPOINTER) AS MODIFIED
*
MARKMODIFIED     EQU     *
        ;LDX    RDSIPOINTER     WHAT CAN I SAY?
        LDX     RDSIPOINTER
        ;CLR     RDSI:MODIFIED,X (RESETS CARRY TO MAKE "OKRTS")
        CLR      RDSI:MODIFIED,X
        ;INC     RDSI:MODIFIED,X
        INC      RDSI:MODIFIED,X
        RTS
        PAGE
SWAPPING EQU     0       ******** TAKE NOTE!
        IF      SWAPPING
DSKFREADBOPT      ; TRY TO OPTIMIZE NEXT SECTOR READ
        ;JSR    CHECKTRANSFERDONE  COMPUTE REMAINING # BYTES TO MOVE
        JSR     CHECKTRANSFERDONE
        ;LDX    DCBPOINTER
        LDX     DCBPOINTER
        ;SUBD    DSKINFO:NBPS,X
        SUBB      (DSKINFO:NBPS)+1,X
        SBCA       DSKINFO:NBPS,X
        BCS       DSKFREADBL1       B/ NO, CAN'T TRANSFER A SECTOR'S WORTH
        ;LDX    FCBPOINTER        ARE THERE ENOUGH BYTES LEFT IN THE FILE ?
        LDX     FCBPOINTER
        ;LDD    FCB:FILESIZE,X    (I.E., IS FCB:FILESIZE - IOCB:CURBYTE >=NBPS ?)
        LDAB      (FCB:FILESIZE)+1,X
        LDAA      FCB:FILESIZE,X
        ;PSHD                   (GET FCB:FILESIZE TO (TOS-1,TOS),(A,B))
        PSHB
        PSHA
        ;LDD    FCB:FILESIZE+2,X
        LDAB      (FCB:FILESIZE+2)+1,X
        LDAA      FCB:FILESIZE+2,X
        ;LDX    FCB:DISKINFO,X    (NOW SUBTRACT DSKINFO:NBPS)
        LDX     FCB:DISKINFO,X
        ;SUBD    DSKINFO:NBPS,X
        SUBB      (DSKINFO:NBPS)+1,X
        SBCA       DSKINFO:NBPS,X
        BCC        DSKFREADBO1       B/ NO BORROW BIT TO PROPOGATE
        TST     1,S     DO DOUBLE PRECISION DECREMENT
        BNE      DSKFREADBO2       B/ DON'T HAVE TO DECREMENT UPPER HALF
        IF      M6800!M6801
        ;DEC     ,X      NOTE: THIS MIGHT GO NEGATIVE!
        DEC      0,X
DSKFREADBO2       EQU     *
        ;DEC     1,X     PROPOGATE THE BORROW
        DEC      1,X
        ELSE    (M6809)
        ;DEC     0,S
        TSX
        DEC      0,X
DSKFREADBO2
        ;DEC     1,S
        TSX
        DEC      1,X
        FIN
DSKFREADBO1       EQU     *
        ;LDX    IOCBPOINTER       NOW SUBTRACT IOCB:CURBYTE...
        LDX     IOCBPOINTER
        ;SUBD    IOCB:CURBYTE+2,X    SO WE CAN FIND OUT IF FCB:FILESIZE-IOCB:CURBYTE...
        SUBB      (IOCB:CURBYTE+2)+1,X
        SBCA       IOCB:CURBYTE+2,X
        ;PULD           -DSKINFO:NBPS>=0
        PULA
        PULB
        SBCB       IOCB:CURBYTE+1,X
        SBCA       IOCB:CURBYTE,X
        BMI      DSKFREADBL1       B/ NOPE, NOT ENOUGH BYTES LEFT IN FILE
        BVS      DSKFREADBL1       THOROUGH BASTARD, AREN'T I ?
****NEEDS WORK!!!*****
        ;JSR    LOCATESECTOR       SEEMS WE CAN DO OPTIMIZED READ
        JSR     LOCATESECTOR
        ;JSR    READDIRECT        DO DIRECT READ
        JSR     READDIRECT
DSKFREADBO3       ; UPDATE IOBLOCK
        ;LDX    DCBPOINTER        NOW ADJUST EVERYTHING
        LDX     DCBPOINTER
        ;LDD    DSKINFO:NBPS,X   ADD NBPS TO ACTUAL COUNT READ
        LDAB      (DSKINFO:NBPS)+1,X
        LDAA      DSKINFO:NBPS,X
        ;LDX    CODE+SDOS:IOBLOCKPTR
        LDX     CODE+SDOS:IOBLOCKPTR
        ;ADDD    READB:ACTUALCOUNT,X
        ADDB      (READB:ACTUALCOUNT)+1,X
        ADCA       READB:ACTUALCOUNT,X
        ;STD    READB:ACTUALCOUNT,X
        STAB      (READB:ACTUALCOUNT)+1,X
        STAA      READB:ACTUALCOUNT,X
        BRA       DSKFREADBOPT      GO SEE IF WE CAN TRANSFER ANOTHER BLOCK
        FIN
        PAGE
*
*       DSKFREADB -- DISK FILE READ BINARY
*
DSKFREADB EQU     *
        ;JSR    DSKFIMPLIEDPOSITION     HANDLE IMPLIED POSITIONING IF GIVEN
        JSR     DSKFIMPLIEDPOSITION
        ;JSR    SETUPFORREAD     COPY BUFFER ADDRESS TO BUFFERPOINTER
        JSR     SETUPFORREAD
*                       AND SET UP FCB AND DISKINFO POINTERS
        ;CLR     IOCB:COLCNT,X       (YOU DID A READ BINARY, YOUR COL COUNT GETS ZAPPED)
        CLR      IOCB:COLCNT,X
DSKFREADBL        ; READ BINARY BYTE LOOP
        IF      SWAPPING
        ;LDX    IOCBPOINTER       BECAUSE AN (EOF) ERROR BOMBS (X)
        LDX     IOCBPOINTER
        ;LDD    IOCB:CURBYTE+2,X    AT A SECTOR BOUNDARY (I.E., IS CURBYTE MOD NBPS = 0 )?
        LDAB      (IOCB:CURBYTE+2)+1,X
        LDAA      IOCB:CURBYTE+2,X
        ;LDX    IOCB:DCB,X  AT SECTOR BOUNDARY ?
        LDX     IOCB:DCB,X
        BITB      DSKINFO:NBPSM1+1,X       (AND WITH NBPS - 1 FOR QUICK CHECK)
        BNE      DSKFREADBL1       B/ NO, READ A BYTE AT A TIME
        BITA      DSKINFO:NBPSM1,X ... ?
        BEQ      DSKFREADBOPT      B/ YES, MAYBE WE CAN DO A DIRECT READ!
DSKFREADBL1       ; MUST READ INTO RDSI BUFFER AND COPY
        FIN
        ;JSR    CHECKREADDONE      ALL BYTES REQUESTED COPIED ?
        JSR     CHECKREADDONE
        BEQ      DSKFREADBOKRTS    B/ YES, ALL DONE
        ;JSR    LOCATECURBYTE       LOCATE THE BYTE WE WANT
        JSR     LOCATECURBYTE
        BSR      DSKREADBCHUNK      GO COPY SOME BYTES TO THE DISK
        ;JSR    UPDATECURBYTEF     ADJUST CURBYTE
        JSR     UPDATECURBYTEF
        BCC        DSKFREADBL        GO SEE IF MORE BYTES TO COPY
        BRA       DSKFREADBL        IGNORE EOF ERROR

DSKFREADBOKRTS    ; READ BINARY COMPLETED SUCCESSFULLY
        OKRTS
        PAGE
*       DSKDREADB -- DISK DEVICE READ BINARY
*
DSKDREADB EQU     *
        ;JSR    DSKDIMPLIEDPOSITION     HANDLE IMPLIED POSITIONING IF GIVEN
        JSR     DSKDIMPLIEDPOSITION
        ;JSR    SETUPFORREAD     AND SET UP DCBPOINTER
        JSR     SETUPFORREAD
DSKDREADBL        EQU     *
        ;JSR    CHECKREADDONE      SEE IF ANY MORE BYTES TO MOVE TO BUFFER
        JSR     CHECKREADDONE
        BEQ      DSKFREADBOKRTS    B/ ALL BYTES COPIED
        ;JSR    LOCDSKD  NO, SET UP PARAMETERS FOR THE COPY
        JSR     LOCDSKD
        BSR      DSKREADBCHUNK      GO COPY THE CHUNK OF BYTES SET UP BY LOCDSKD
        ;JSR    UPDATECURBYTED     UPDATE POINTERS AND STUFF FOR DISK DEVICE
        JSR     UPDATECURBYTED
        BCC        DSKDREADBL        AND LOOP UNTIL USER'S BUFFER IS FILLED
        BRA       DSKDREADBL        IGNORE EOF ERROR
*
*       DSKREADBCHUNK -- READ A CHUNK OF BYTES FROM FILE TO BUFFER
*               CHUNK PARAMETERS ARE ALL SET UP BY LOCATECURBYTE
*
DSKREADBCHUNK      EQU     *
        ;LDX    CODE+SDOS:IOBLOCKPTR       GET THE # BYTES MOVED SO FAR
        LDX     CODE+SDOS:IOBLOCKPTR
        ;LDD    READB:ACTUALCOUNT,X
        LDAB      (READB:ACTUALCOUNT)+1,X
        LDAA      READB:ACTUALCOUNT,X
        ;ADDD    USEDCOUNT        ADD # BYTES WE'LL MOVE THIS TIME
        ADDB      USEDCOUNT+1
        ADCA       USEDCOUNT
        ;STD    READB:ACTUALCOUNT,X
        STAB      (READB:ACTUALCOUNT)+1,X
        STAA      READB:ACTUALCOUNT,X
        IF      M6800!M6801
        ;LDX    BUFFERPOINTER    SET "TO" POINTER
        LDX     BUFFERPOINTER
        STX     TOPOINTER
        ELSE    (M6809)
        LDY     BUFFERPOINTER
        FIN
        ;LDX    IOCBPOINTER       GET THE SOURCE POINTER
        LDX     IOCBPOINTER
        ;LDX    IOCB:NEXTBYTE,X
        LDX     IOCB:NEXTBYTE,X
        ;LDD    USEDCOUNT        FETCH TRANSFER COUNT
        LDAB      USEDCOUNT+1
        LDAA      USEDCOUNT
        ;JSR    CODE+SDOS:BLOCKMOVE        GO MOVE THE BYTES
        JSR     CODE+SDOS:BLOCKMOVE
*       NOTE: THIS USES SDOS ENTRY POINT VECTOR...
*       SO THAT A PATCH TO ENTRY POINT VECTOR CAN SUPPLY A DIFFERENT...
*       (PRESUMABLY MUCH FASTER) BLOCK MOVE ROUTINE OF ITS OWN!
        IF      M6800!M6801
        ;LDX    TOPOINTER       UPDATE BUFFER POINTER PAST COPIED BYTES
        LDX     TOPOINTER
        STX     BUFFERPOINTER
        ELSE    (M6809)
        STY     BUFFERPOINTER
        FIN
        RTS
        PAGE
*
*       DSKFREADA -- DISK FILE READ ASCII
*
DSKFREADA EQU     *
        ;JSR    DSKFIMPLIEDPOSITION     HANDLE IMPLIED POSITIONING IF REQUESTED
        JSR     DSKFIMPLIEDPOSITION
        ;JSR    SETUPFORREAD     COPY BUFFER ADDRESS TO BUFFERPOINTER
        JSR     SETUPFORREAD
*                       AND SET UP FCB AND DISKINFO POINTERS
DSKFREADAL        EQU     *
        ;JSR    CHECKREADDONE      ALL BYTES READ THAT WERE REQUESTED ?
        JSR     CHECKREADDONE
        BEQ      DSKFREADADONE     B/ YES, DON'T READ ANY MORE BYTES
        ;JSR    LOCATECURBYTE       LOCATE THE BYTE WE WANT
        JSR     LOCATECURBYTE
        BSR      DSKREADACHUNK      READ A CHUNK OF BYTES SELECTED BY LOCATECURBYTE
        BNE      DSKFREADALINE     B/ LINE MODE INPUT COMPLETED
        ;JSR    UPDATECURBYTEF     ADJUST CURBYTE
        JSR     UPDATECURBYTEF
        BCC        DSKFREADAL        GO CHECK FOR MORE BYTES TO MOVE
        BRA       DSKFREADAL        IGNORE EOF ERROR

DSKFREADALINE     EQU     *
        ;JSR    UPDATECURBYTEF     UPDATE CURBYTE FOR THE FILE
        JSR     UPDATECURBYTEF
        BCS       DSKFREADADONE     IGNORE EOF ERROR
DSKFREADADONE     ; DONE FILLING SYSCALL REQUEST
        LDAA      COLUMNCOUNT       COPY COLUMN COUNT BACK TO IOCB
        ;LDX    IOCBPOINTER
        LDX     IOCBPOINTER
        STAA      IOCB:COLCNT,X
        OKRTS
        PAGE
*
*       DSKDREADA -- DISK DEVICE READ ASCII
*
DSKDREADA EQU     *
        ;JSR    DSKDIMPLIEDPOSITION     HANDLE IMPLIED POSITIONING IF REQUESTED
        JSR     DSKDIMPLIEDPOSITION
        ;JSR    SETUPFORREAD     AND SET UP DISKINFO AND COLUMNCOUNT
        JSR     SETUPFORREAD
DSKDREADAL        EQU     *
        ;JSR    CHECKREADDONE      TO SEE IF ALL DESIRED BYTES WERE COPIED
        JSR     CHECKREADDONE
        BEQ      DSKFREADADONE     B/ ALL DONE, GO CLEAN UP
        ;JSR    LOCDSKD  GO LOCATE THE CHUNK OF BYTES TO COPY
        JSR     LOCDSKD
        BSR      DSKREADACHUNK      READ THEM INTO THE USER'S BUFFER
        BNE      DSKDREADALINE     B/ LINE MODE REQUEST SATISFIED
        ;JSR    UPDATECURBYTED     UPDATE THE POINTERS FOR THE DISK DEVICE
        JSR     UPDATECURBYTED
        BCC        DSKDREADAL        AND GO SEE IF THERE ARE MORE BYTES TO COPY
        BRA       DSKDREADAL        IGNORE EOF ERROR

DSKDREADALINE     EQU     *
        ;JSR    UPDATECURBYTED     UPDATE POINTERS FOR THE DISK DEVICE
        JSR     UPDATECURBYTED
        BCC        DSKFREADADONE     B/ NO ERROR, GET OUT QUICK!
        BRA       DSKFREADADONE     AND GO CLEAN UP
        PAGE
*
*       DSKREADACHUNK -- READ AN ASCII CHUNK OF BYTES SELECTED BY LOCATECURBYTE
*       RETURNS CC=0 IF EXHAUSTED CHUNK, NEED TO READ MORE
*               <>0 IF LINE MODE REQUEST WAS SATISFIED
*       THIS ROUTINE SHOULD TEST ACTIVATION CHARACTER SET LIKE VT DRIVER!
*
DSKREADACHUNK      EQU     *
        ;LDD    USEDCOUNT        MAKE EASY-TO-INCREMENT 16 BIT COUNT
        LDAB      USEDCOUNT+1
        LDAA      USEDCOUNT
        ;NEGD
        NEGA
        NEGB
        SBCA       #0
        ;STD    TRANSFERCOUNT
        STAB      TRANSFERCOUNT+1
        STAA      TRANSFERCOUNT
        ;LDX    CODE+SDOS:IOBLOCKPTR       GET THE # BYTES MOVED SO FAR
        LDX     CODE+SDOS:IOBLOCKPTR
        ;LDD    READA:ACTUALCOUNT,X
        LDAB      (READA:ACTUALCOUNT)+1,X
        LDAA      READA:ACTUALCOUNT,X
        ;ADDD    USEDCOUNT        ADD # BYTES WE'LL MOVE THIS TIME
        ADDB      USEDCOUNT+1
        ADCA       USEDCOUNT
        ;STD    READA:ACTUALCOUNT,X
        STAB      (READA:ACTUALCOUNT)+1,X
        STAA      READA:ACTUALCOUNT,X
        ;LDX    IOCBPOINTER       GET THE SOURCE POINTER
        LDX     IOCBPOINTER
        IF      M6800!M6801
        ;LDX    IOCB:NEXTBYTE,X
        LDX     IOCB:NEXTBYTE,X
        STX     FROMPOINTER
DSKREADACHUNKL     ; COPY BYTES FROM SECTOR TO BUFFER
        ;LDX    FROMPOINTER
        LDX     FROMPOINTER
        ;LDA     ,X+     COPY A BYTE...
        LDAA      0,X
        INX
        STX     FROMPOINTER
        ANDA      #ASCII:MASK        A NULL ?
        BEQ      DSKREADANULL      B/ YES, ADJUST ACTUAL COUNT READ
        ;CMPA     #ASCII:LF A LINE FEED ?
        CMPA      #ASCII:LF
        BEQ      DSKREADANULL      B/ YES, IGNORE IT
        ;CMPA     #ASCII:RUBOUT      ?
        CMPA      #ASCII:RUBOUT
        BEQ      DSKREADANULL      B/ YES, IGNORE IT
        ;JSR    ADJUSTCOLUMNCOUNT  NO, GO UPDATE THE COLUMN COUNTER
        JSR     ADJUSTCOLUMNCOUNT
        ;LDX    BUFFERPOINTER    TO THE USER'S BUFFER
        LDX     BUFFERPOINTER
        ;STA     ,X+
        STAA      0,X
        INX
        STX     BUFFERPOINTER
        ;CMPA     #ASCII:CR  END OF LINE CODE ?
        CMPA      #ASCII:CR
        BNE      DSKREADACHUNKL1    B/ NO
        ;LDX    CODE+SDOS:IOBLOCKPTR       YES, LINE MODE ?
        LDX     CODE+SDOS:IOBLOCKPTR
        LDAA      READA:LMFLAG,X     ...?
        BNE      DSKREADACR B/ YES, CR IS IMPORTANT
DSKREADACHUNKL1 ; ADJUST NUMBER OF BYTES TRANSFERRED
        ELSE    (M6809)
        PAGE
        LDY     IOCB:NEXTBYTE,X    GET SOURCE POINTER
        LDU     BUFFERPOINTER    GET TARGET BUFFER ADDRESS
DSKREADACHUNKL     ; COPY BYTES FROM SECTOR TO BUFFER
        ;LDA     ,Y+     COPY A BYTE...
        LDAA      
        ANDA      #ASCII:MASK        A NULL?
        BEQ      DSKREADANULL      B/ YES
        ;CMPA     #ASCII:LF LINE FEED?
        CMPA      #ASCII:LF
        BEQ      DSKREADANULL      B/ YES, IGNORE IT
        ;CMPA     #ASCII:RUBOUT      RUBOUT?
        CMPA      #ASCII:RUBOUT
        BEQ      DSKREADANULL      B/ YES, IGNORE IT
        ;JSR    ADJUSTCOLUMNCOUNT  NO, GO UPDATE THE COLUMN COUNT
        JSR     ADJUSTCOLUMNCOUNT
        ;STA     ,U+     STORE THE BYTE INTO THE USER'S BUFFER
        STAA      
        ;CMPA     #ASCII:CR  END OF LINE MARK?
        CMPA      #ASCII:CR
        BNE      DSKREADACHUNKL1    B/ NO, KEEP COPYING
        ;LDX    CODE+SDOS:IOBLOCKPTR       YES, LINE MODE?
        LDX     CODE+SDOS:IOBLOCKPTR
        ;LDA     READA:LMFLAG,X     ...?
        LDAA      READA:LMFLAG,X
        BNE      DSKREADACR B/ YES, CR MARKS END OF TRANSFER
DSKREADACHUNKL1    EQU     *
        FIN
        ;INC     TRANSFERCOUNT+1   DOWN COUNT # BYTES TO MOVE
        INC      TRANSFERCOUNT+1
        BNE      DSKREADACHUNKL     B/ MORE TO MOVE
        IF      M6809
        STU     BUFFERPOINTER    ENSURE BUFFER POINTER IS UP TO DATE IN CASE WE EXIT
        FIN
        ;INC     TRANSFERCOUNT
        INC      TRANSFERCOUNT
        BNE      DSKREADACHUNKL     B/ MORE
        RTS             WITH CC=0 IF ALL BYTES SPECIFIED WERE COPIED
        PAGE
DSKREADANULL      ; RATS, ENCOUNTERED A NULL!
        ;LDX    USERRETAPTR      HAS THIS USER BEEN KILLED ?
        LDX     USERRETAPTR
        ;LDD    M6800!M6801,X   (FETCH HIS RETURN ADDRESS)
        LDAB      (M6800!M6801)+1,X
        LDAA      M6800!M6801,X
        ;CMPD    #KILLPROGRAM     (DOES PC POINT TO KILL PROGRAM?)
        CMPA      #(KILLPROGRAM)/256
        BNE      MACRO:0014
        CMPB      #(KILLPROGRAM)&$FF
MACRO:0014
        BEQ      DSKREADANULL2     B/ YES, STOP IGNORING NULLS --> RELATIVELY QUICK EXIT!
        ;LDX    CODE+SDOS:IOBLOCKPTR       ACTUALCOUNT:=ACTUALCOUNT-1
        LDX     CODE+SDOS:IOBLOCKPTR
        LDAA      READA:ACTUALCOUNT+1,X (WE CAN'T COPY THE NULL...
        BNE      DSKREADANULL1     TO THE USER'S BUFFER!)
        ;DEC     READA:ACTUALCOUNT,X
        DEC      READA:ACTUALCOUNT,X
DSKREADANULL1     EQU     *
        ;DEC     READA:ACTUALCOUNT+1,X
        DEC      READA:ACTUALCOUNT+1,X
DSKREADANULL2
        ;JMP    DSKREADACHUNKL1    GO GRAB THE NEXT BYTE (JMP FOR SPEED)
        JMP     DSKREADACHUNKL1

DSKREADACR ; WE JUST SAW A CR IN LINE MODE
        ;LDD    READA:ACTUALCOUNT,X   ADJUST THE ACTUAL # BYTES XFERRED
        LDAB      (READA:ACTUALCOUNT)+1,X
        LDAA      READA:ACTUALCOUNT,X
        SEC              (COUNT THE CR BYTE)
        ADCB       TRANSFERCOUNT+1   THESE GUYS...
        ADCA       TRANSFERCOUNT     WE DIDN'T ACTUALLY TRANSFER
        ;STD    READA:ACTUALCOUNT,X   UPDATE THE ACTUAL # OF BYTES XFERRED
        STAB      (READA:ACTUALCOUNT)+1,X
        STAA      READA:ACTUALCOUNT,X
        ;LDD    USEDCOUNT        ADJUST THE ACTUAL # OF BYTES USED THIS TIME
        LDAB      USEDCOUNT+1
        LDAA      USEDCOUNT
        SEC              (AGAIN, COUNT THE CR)
        ADCB       TRANSFERCOUNT+1   THESE GUYS WE DIDN'T TRANSFER
        ADCA       TRANSFERCOUNT
        ;STD    USEDCOUNT
        STAB      USEDCOUNT+1
        STAA      USEDCOUNT
        IF      M6809
        STU     BUFFERPOINTER    ENSURE THAT BUFFER POINTER IS UP TO DATE
        FIN
        LDAA      #1      RETURN WITH CC<>0...
        RTS             SINCE LINEMODE REQUEST WAS SATISFIED
        PAGE
*
*       ADJUSTCOLUMNCOUNT -- ADJUST COLUMNCOUNT ACCORDING TO (A)
*               MASKS PARITY ON (A)
*
ADJUSTCOLUMNCOUNT  EQU     *
        ANDA      #ASCII:MASK        DITCH THE PARITY BIT
        ;CMPA     #ASCII:SPACE-1      A PRINTING CHARACTER ?
        CMPA      #ASCII:SPACE-1
        BHI      ADJUSTCOLBUMP      B/ YEP, GO PROCESS
        ;CMPA     #ASCII:CR  MUST BE A CONTROL CHARACTER
        CMPA      #ASCII:CR
        BEQ      ADJUSTCOLZERO     B/ NEW LINE MARK, ZERO THE COLUMN COUNT
        ;CMPA     #ASCII:BS  BACKSPACE ?
        CMPA      #ASCII:BS
        BEQ      ADJUSTCOLBS        B/ YES, GO HANDLE
        ;CMPA     #ASCII:HT A TAB CHARACTER ?
        CMPA      #ASCII:HT
        BEQ      ADJUSTCOLTAB        B/ YES, GO PROCESS
        ;CMPA     #ASCII:FF FORM FEED ?
        CMPA      #ASCII:FF
        BNE      ADJUSTCOLRTS      B/ NO, LEAVE COLUMN COUNT ALONE
ADJUSTCOLZERO ; MUST ZERO THE COLUMN COUNT
        ;CLR     COLUMNCOUNT       CR --> ZERO THE COLUMN COUNTER
        CLR      COLUMNCOUNT
ADJUSTCOLRTS      EQU     *
        RTS

ADJUSTCOLBUMP      ; LOOKS LIKE WE SHOULD BUMP COLUMN COUNT
        ;CMPA     #ASCII:RUBOUT      ALL CODES > $20 ARE PRINTING CHARACTERS...
        CMPA      #ASCII:RUBOUT
        BEQ      ADJUSTCOLRTS      WITH THE EXCEPTION OF RUBOUT
        ;INC     COLUMNCOUNT       BUMP THE COLUMN COUNT (TOO BAD IF IT OVERFLOWS!)
        INC      COLUMNCOUNT
        RTS

ADJUSTCOLBS        TST     COLUMNCOUNT       HANDLE BACKSPACE
        BEQ      ADJUSTCOLRTS      B/ AT COL 0, CANNOT BACKSPACE
        ;DEC     COLUMNCOUNT       ELSE BACK UP THE COLUMN COUNT
        DEC      COLUMNCOUNT
        RTS

ADJUSTCOLTAB        ;LDB     COLUMNCOUNT       TAB SEEN
        LDAB      COLUMNCOUNT
        ;ORB     #7      BUMP COLUMN COUNT TO NEXT MULTIPLE OF 8
        ORAB      #7
        INCB
        ;STB     COLUMNCOUNT
        STAB      COLUMNCOUNT
        RTS
        PAGE
*       SETUPFORWRITE -- SET UP FOR "WRITEA" OR "WRITEB"
*       WORKS JUST LIKE SETUPFORREAD, EXCEPT THAT WRITEFLAG IS SET
*
SETUPFORWRITE   EQU     *
        LDAA      #1      REMEMBER, THIS IS A WRITE!
        STAA      WRITEFLAG
        ;LDX    CODE+SDOS:IOBLOCKPTR       GET SCBLK:WRBUF...
        LDX     CODE+SDOS:IOBLOCKPTR
        ;LDX    SCBLK:WRBUF,X      AND COPY INTO BUFFERPOINTER
        LDX     SCBLK:WRBUF,X
        BRA       SETUPFORREAD1
*
*       SETUPFORREAD -- COPY BUFFERADDRESS FROM IOBLOCK TO BUFFERPOINTER
*               ALSO GETS FCB AND DISKINFO POINTERS FROM IOCB
*               FINALLY, RESETS THE WRITEFLAG AND COPIES IOCB:COLCNT INTO COLUMNCOUNT
*
SETUPFORREAD     EQU     *
        ;CLR     WRITEFLAG        THIS IS A READ, REMEMBER?
        CLR      WRITEFLAG
        IF      READA:BUFFERP#READB:BUFFERP
        ?SETUPFORREAD WON'T WORK?
        FIN
        ;LDX    CODE+SDOS:IOBLOCKPTR       GET BUFFER POINTER FROM I/O BLOCK
        LDX     CODE+SDOS:IOBLOCKPTR
        ;LDX    READA:BUFFERP,X
        LDX     READA:BUFFERP,X
SETUPFORREAD1    EQU     *
        STX     BUFFERPOINTER
        ;LDX    IOCBPOINTER       AND SET UP THE COLUMNCOUNT
        LDX     IOCBPOINTER
        LDAA      IOCB:COLCNT,X       IN CASE THIS IS AN ASCII READ OR WRITE
        STAA      COLUMNCOUNT
        RTS
*
*       GETFCBFROMIOCB -- SETS UP FCBPOINTER FROM IOCB
*       PRESERVES (A) FOR DISK DRIVER CONTROL, STATUS CALLS
*
GETFCBFROMIOCB      EQU     *
        ;LDX    IOCBPOINTER       GRAB IOCB ADDRESS
        LDX     IOCBPOINTER
        ;LDX    IOCB:FCB,X  COPY FCB ADDRESS OUT OF IOCB...
        LDX     IOCB:FCB,X
        STX     FCBPOINTER        INTO A CONVENIENT PLACE
        ;LDX    IOCBPOINTER       JUST TO BE NICE
        LDX     IOCBPOINTER
        RTS
        PAGE
*       CHECKREADDONE -- CHECKS TO SEE IF READB:MAXCOUNT = READB:ACTUALCOUNT
*               RETURNS Z BIT SET IF EQUAL
*               ...RESET IF NOT EQUAL
*               RETURNS (A,B):=READB:MAXCOUNT-READB:ACTUALCOUNT
*
CHECKREADDONE      EQU     *
        IF      READA:BUFFERP#READB:BUFFERP
        ?CHECKREADDONE WON'T WORK?
        FIN
        ;LDX    CODE+SDOS:IOBLOCKPTR       IS ACTUALCOUNT TRANSFERRED...
        LDX     CODE+SDOS:IOBLOCKPTR
        ;LDD    READB:MAXCOUNT,X    = MAXCOUNT ?
        LDAB      (READB:MAXCOUNT)+1,X
        LDAA      READB:MAXCOUNT,X
        ;SUBD    READB:ACTUALCOUNT,X   (COMPUTE NUMBER OF BYTES LEFT TO TRANSFER)
        SUBB      (READB:ACTUALCOUNT)+1,X
        SBCA       READB:ACTUALCOUNT,X
        IF      M6800!M6801
        BNE      CHECKREADDONE1     B/ WE STILL NEED TO MOVE LOTSA BYTES
        TSTB             ... ?
CHECKREADDONE1     EQU     *
        FIN
        RTS
*
*       CHECKWRITEDONE -- CHECKS TO SEE IF WRBUF+WRLEN = BUFFERPOINTER
*               RETURNS Z BIT SET IF EQUAL, RESET IF NOT EQUAL
*               RETURNS (A,B):=WRBUF+WRLEN-BUFFERPOINTER (# BYTES LEFT TO WRITE)
*
CHECKWRITEDONE    EQU     *
        IF      WRITEA:BUFFERP#WRITEB:BUFFERP
        ?CHECKWRITEDONE WON'T WORK?
        FIN
        ;LDX    CODE+SDOS:IOBLOCKPTR       FIND END OF WRBUF
        LDX     CODE+SDOS:IOBLOCKPTR
        ;LDD    SCBLK:WRBUF,X
        LDAB      (SCBLK:WRBUF)+1,X
        LDAA      SCBLK:WRBUF,X
        ;ADDD    SCBLK:WRLEN,X
        ADDB      (SCBLK:WRLEN)+1,X
        ADCA       SCBLK:WRLEN,X
        ;SUBD    BUFFERPOINTER    HAS BUFFERPOINTER ARRIVED THERE ?
        SUBB      BUFFERPOINTER+1
        SBCA       BUFFERPOINTER
        IF      M6800!M6801
        BNE      CHECKWRITEDONE1   B/ GO FIND OUT.
        TSTB
CHECKWRITEDONE1
        FIN
        RTS
        PAGE
*
*       DSKFWRITEB -- WRITE BINARY TO DISK FILE
*
DSKFWRITEB       EQU     *
        ;JSR    DSKFIMPLIEDPOSITION     HANDLE IMPLIED POSITIONING IF REQUESTED
        JSR     DSKFIMPLIEDPOSITION
        BCS       *+2     IGNORE EOF ERROR IF GIVEN
        BSR      SETUPFORWRITE   SO WE CAN MODIFY IT AS WE PLEASE
*               AND GET FCB AND DISKINFO POINTERS
        ;CLR     IOCB:COLCNT,X       YOU SAY, "WRITE BINARY", I SAY "ZAP THE COLUMN COUNT"
        CLR      IOCB:COLCNT,X
        ;JSR    UPDATEFILEDATE    SET DATE OF FILE TO TODAY
        JSR     UPDATEFILEDATE
DSKFWRITEBL      ; WRITE BINARY BYTES TO DISK FILE
        BSR      CHECKWRITEDONE    ARE ALL BYTES FROM BUFFER WRITTTEN ?
        BEQ      DSKFWRITEBDONE   B/ YES, ALL DONE WRITING BYTES
        ;JSR    LOCATECURBYTE       LOCATE THE BYTE WE WANT
        JSR     LOCATECURBYTE
        BSR      DSKWRITEBCHUNK    COPY A CHUNK OF BYTES FROM THE BUFFER TO THE DISK
        ;JSR    UPDATECURBYTEF     ADJUST CURBYTE
        JSR     UPDATECURBYTEF
        BCC        DSKFWRITEBL      GO LOOK FOR MORE BYTES TO MOVE
        BRA       DSKFWRITEBL      IGNORE EOF ERROR

DSKFWRITEBDONE   EQU     *
        OKRTS           AND EXIT
*
*       DSKDWRITEB -- WRITE BINARY TO DISK FILE
*
DSKDWRITEB       EQU     *
        ;JSR    DSKDIMPLIEDPOSITION     HANDLE IMPLIED POSITIONING IF REQUESTED
        JSR     DSKDIMPLIEDPOSITION
        ;JSR    SETUPFORWRITE   AND SET UP DISKINFO POINTER
        JSR     SETUPFORWRITE
        ;CLR     IOCB:COLCNT,X       SINCE YOU ASKED FOR A WRITE BINARY
        CLR      IOCB:COLCNT,X
DSKDWRITEBL      EQU     *
        BSR      CHECKWRITEDONE    ALL BYTES MOVED FROM BUFFER TO DISK ?
        BEQ      DSKFWRITEBDONE   B/ YES, QUIT NOW
        ;JSR    LOCDSKD  LOCATE THE CHUNK OF BYTES TO WRITE INTO
        JSR     LOCDSKD
        BSR      DSKWRITEBCHUNK    GO COPY A CHUNK OF BYTES TO THE DISK
        ;JSR    UPDATECURBYTED     AND UPDATE THE POINTERS TELLING US WHERE WE ARE
        JSR     UPDATECURBYTED
        BCC        DSKDWRITEBL      GO SEE IF SOME MORE WORK TO DO
        BRA       DSKDWRITEBL      IGNORE EOF ERROR
        PAGE
*
*       DSKWRITEBCHUNK -- WRITE A CHUNK OF BYTES FROM BUFFER TO DISK FILE
*               PARAMETERS SPECIFYING THE CHUNK ARE SET UP BY LOCATECURBYTE
*
DSKWRITEBCHUNK    EQU     *
        ;LDX    IOCBPOINTER       GET THE TARGET POINTER
        LDX     IOCBPOINTER
        IF      M6800!M6801
        ;LDX    IOCB:NEXTBYTE,X
        LDX     IOCB:NEXTBYTE,X
        STX     TOPOINTER
        ELSE    (M6809)
        LDY     IOCB:NEXTBYTE,X
        FIN
        ;LDX    BUFFERPOINTER    GET FROM POINTER TO (A,B)
        LDX     BUFFERPOINTER
        ;LDD    USEDCOUNT        # BYTES TO MOVE
        LDAB      USEDCOUNT+1
        LDAA      USEDCOUNT
        ;JSR    CODE+SDOS:BLOCKMOVE        GO MOVE THE BYTES
        JSR     CODE+SDOS:BLOCKMOVE
*       NOTE: THIS USES SDOS ENTRY POINT VECTOR...
*       SO THAT A PATCH TO ENTRY POINT VECTOR CAN SUPPLY A DIFFERENT...
*       (PRESUMABLY MUCH FASTER) BLOCK MOVE ROUTINE OF ITS OWN!
        STX     BUFFERPOINTER    UPDATE POINTER PAST COPIED BYTES
        RTS
        PAGE
*
*       DSKFWRITEA -- WRITE ASCII TO DISK FILE
*
DSKFWRITEA       EQU     *
        ;JSR    DSKFIMPLIEDPOSITION     HANDLE IMPLIED POSITIONING IF REQUESTED
        JSR     DSKFIMPLIEDPOSITION
        BCS       *+2     IGNORE EOF ERROR IF GIVEN
        ;JSR    SETUPFORWRITE   SO WE CAN MODIFY IT AS WE PLEASE
        JSR     SETUPFORWRITE
*                       AND SET UP FCB AND DISKINFO TABLE POINTERS
        ;JSR    UPDATEFILEDATE    TO MATCH TODAY'S DATE!
        JSR     UPDATEFILEDATE
DSKFWRITEAL      ; WRITE A BYTE TO DISK FILE
        ;JSR    CHECKWRITEDONE    ALL BYTES COPIED FROM BUFFER TO DISK FILE ?
        JSR     CHECKWRITEDONE
        BEQ      DSKFWRITEADONE   B/ YES, ALL DONE WRITING BYTES
        ;JSR    LOCATECURBYTE       LOCATE THE BYTE WE WANT
        JSR     LOCATECURBYTE
        BSR      DSKWRITEACHUNK    WRITE A CHUNK OF BYTES FROM BUFFER TO DISK FILE
        ;JSR    UPDATECURBYTEF     ADJUST CURBYTE
        JSR     UPDATECURBYTEF
        BCC        DSKFWRITEAL      GO SEE IF WE MUST STILL MOVE MORE BYTES
        BRA       DSKFWRITEAL      IGNORE EOF ERROR

DSKFWRITEADONE   EQU     *
        ;LDX    IOCBPOINTER       RESET THE WRITE MODE FLAG
        LDX     IOCBPOINTER
        LDAA      COLUMNCOUNT       AND UPDATE THE COLUMN COUNTER
        STAA      IOCB:COLCNT,X
        OKRTS           AND EXIT
        PAGE
*
*       DSKWRITEACHUNK -- WRITE A CHUNK OF ASCII BYTES TO A DISK SECTOR
*               CHUNK PARAMETERS SET UP BY LOCATECURBYTE
*
DSKWRITEACHUNK    EQU     *
        IF      M6800!M6801
        ;LDD    USEDCOUNT        = # BYTES TO TRANSFER
        LDAB      USEDCOUNT+1
        LDAA      USEDCOUNT
        ;NEGD           MAKE EASY-TO-INCREMENT COUNTER
        NEGA
        NEGB
        SBCA       #0
        ;STD    TRANSFERCOUNT
        STAB      TRANSFERCOUNT+1
        STAA      TRANSFERCOUNT
        ;LDX    IOCBPOINTER       GET THE TARGET POINTER
        LDX     IOCBPOINTER
        ;LDX    IOCB:NEXTBYTE,X
        LDX     IOCB:NEXTBYTE,X
        STX     TOPOINTER       AND SAVE IT
DSKWRITEACHUNKL   ; COPY BYTES FROM SECTOR TO BUFFER
        ;LDX    BUFFERPOINTER
        LDX     BUFFERPOINTER
        ;LDA     ,X+     COPY A BYTE...
        LDAA      0,X
        INX
        STX     BUFFERPOINTER
        ;JSR    ADJUSTCOLUMNCOUNT  NEED I SAY MORE ?
        JSR     ADJUSTCOLUMNCOUNT
        ;LDX    TOPOINTER       TO THE DATA SECTOR
        LDX     TOPOINTER
        ;STA     ,X+
        STAA      0,X
        INX
        STX     TOPOINTER
        ;INC     TRANSFERCOUNT+1   DOWN COUNT # BYTES TO MOVE
        INC      TRANSFERCOUNT+1
        BNE      DSKWRITEACHUNKL   B/ MORE TO MOVE
        ;INC     TRANSFERCOUNT
        INC      TRANSFERCOUNT
        BNE      DSKWRITEACHUNKL   B/ MORE
        ELSE    (M6809)
        LDY     USEDCOUNT        = # BYTES TO MOVE
        ;LDX    IOCBPOINTER       GET TARGET POINTER TO (U)
        LDX     IOCBPOINTER
        LDU     IOCB:NEXTBYTE,X
        ;LDX    BUFFERPOINTER    SOURCE POINTER
        LDX     BUFFERPOINTER
DSKWRITEACHUNKL ; COPY BYTES FROM SECTOR TO USER SPACE BUFFER
        ;LDA     ,X+     COPY A BYTE...
        LDAA      0,X
        INX
        ;JSR    ADJUSTCOLUMNCOUNT  NEED I SAY MORE?
        JSR     ADJUSTCOLUMNCOUNT
        ;STA     ,U+     ... TO TARGET SECTOR BUFFER
        STAA      
        LEAY     -1,Y    DOWN COUNT NUMBER OF BYTES TO MOVE
        BNE      DSKWRITEACHUNKL   B/ MORE BYTES TO MOVE!
        STX     BUFFERPOINTER    MAKE SURE BUFFERPOINTER IS UP TO DATE ON EXIT
        FIN
        RTS
        PAGE
*
*       DSKDWRITEA -- WRITE ASCII TO DISK DEVICE
*
DSKDWRITEA       EQU     *
        ;JSR    DSKDIMPLIEDPOSITION     HANDLE IMPLIED POSITIONING IF REQUESTED
        JSR     DSKDIMPLIEDPOSITION
        ;JSR    SETUPFORWRITE   AND SET UP DISKINFO POINTER
        JSR     SETUPFORWRITE
DSKDWRITEAL      EQU     *
        ;JSR    CHECKWRITEDONE    ALL BYTES WRITTEN ?
        JSR     CHECKWRITEDONE
        BEQ      DSKFWRITEADONE   B/ YES, QUIT NOW
        ;JSR    LOCDSKD  GO FIGURE OUT THE BOUNDARIES OF THE CHUNK
        JSR     LOCDSKD
        BSR      DSKWRITEACHUNK    GO COPY THE BYTES TO A DISK SECTOR
        ;JSR    UPDATECURBYTED     UPDATE THE DISK DEVICE POINTERS
        JSR     UPDATECURBYTED
        BCC        DSKDWRITEAL      AND LOOP UNTIL ALL THE BYTES ARE COPIED
        BRA       DSKDWRITEAL      IGNORE EOF ERROR
        PAGE
*
*       TABLEBRANCH -- BRANCH THRU TABLE ON (A)
*       ENTERED WITH POINTER TO TABLE IN (X)
*       @X IS BYTE CONTAINING MINIMUM VALUE FOR (A)
*       @(X+1) IS BYTE CONTAINING MAXIMUM VALUE FOR (A) [ MUST BE < MIN + 64]
*       @(X+2) IS POINTER TO ROUTINE FOR MIN VALUE OF (A)
*       @(X+4) IS POINTER TO ROUTINE FOR MIN VALUE OF (A), + 1
*               ETC.
*       CONTROL IS RETURNED ONLY IF (A) IS NOT IN BOUNDS SPECIFIED BY TABLE
*
TABLEBRANCH
        ;CMPA     ,X      < MIN VALUE?
        CMPA      0,X
        BCS       TABLEBRANCHCANT        B/ NOT IN RANGE FOR THIS TABLE
        ;CMPA     1,X     <= MAX VALUE?
        CMPA      1,X
        BHI      TABLEBRANCHCANT        B/ NOT IN RANGE FOR THIS TABLE
        ;LEAS    2,S     MAKE RETURN ADDRESS GO AWAY...
        IF      2<0
        RPT     -2
        DES
        ELSE
        RPT     2
        INS
        FIN
        SUBA      ,X      FORM 0-ORIGIN OFFSET INTO BRANCH TABLE
        ASLA              ASSERT: CAN'T OVERFLOW OR SET THE SIGN BIT!
        TAB
        IF      M6800!M6801
        CLRA              COMPUTE POINTER INTO TABLE
        STX     TEMPX
        ;ADDD    TEMPX
        ADDB      TEMPX+1
        ADCA       TEMPX
        ;TDX
        STAA      TEMPA
        STAB      TEMPB
        LDX     TEMPX
        ELSE    (M6809)
        ;LEAX    B,X
        IF      B<0
        RPT     -B
        DEX
        ELSE
        RPT     B
        INX
        FIN
        FIN
        ;JMP    [2,X]   GO TO ROUTINE
        LDX     2,X
        JMP     0,X

TABLEBRANCHCANT        RTS
        PAGE
DSKFSETDATE      ; SET DATE OF DISK FILE
        ;JSR    CHECKWRLEN        WRITE BUFFER FORMAT MATCHES CLOCK
        JSR     CHECKWRLEN
        FDB      6
        ;LDX    SCBLK:WRBUF,X
        LDX     SCBLK:WRBUF,X
        ;LDA     CONTROL:DATA+3,X   FETCH NEW DAY NUMBER
        LDAA      CONTROL:DATA+3,X
        PSHA             AND SAVE IT
        ;LDD    CONTROL:DATA+4,X   FETCH MONTH AND YEAR NUMBER
        LDAB      (CONTROL:DATA+4)+1,X
        LDAA      CONTROL:DATA+4,X
        ;LDX    FCBPOINTER        THIS FCB, PLEASE...
        LDX     FCBPOINTER
        ;STD    FCB:MONTH,X       SET MONTH AND YEAR
        STAB      (FCB:MONTH)+1,X
        STAA      FCB:MONTH,X
        PULA             GET DAY NUMBER BACK
        STAA      FCB:DAY,X  AND STORE IT
DSKFSET1 ; MARK DIRECTORY ENTRY AS CHANGED
        LDAA      FCB:FLAGS,X        NOTE: SETTING DATE DOES NOT ALTER "BACKUP" BIT
        ORAA      #FCBFLG::UPDATEDIR
        STAA      FCB:FLAGS,X
        OKRTS

DSKFSETPROT     ; SET PROTECTION BITS
        ;JSR    CHECKWRLEN
        JSR     CHECKWRLEN
        FDB      1       SINGLE BYTE WRITE BUFFER
        ;LDX    SCBLK:WRBUF,X      GET POINTER TO WRITE BUFFER
        LDX     SCBLK:WRBUF,X
        LDAA      CONTROL:DATA,X     GET NEW PROTECTION BITS
        ;LDX    FCBPOINTER        WHICH FILE TO CHANGE
        LDX     FCBPOINTER
        STAA      FCB:PROT,X        CHANGE PROT AFTER UPDATEFILEDATE...
        BRA       DSKFSET1        GO MARK DIRECTORY ENTRY AS CHANGED
        PAGE
*       DSKFCONTROL -- DO A CONTROL OPERATION ON DISK FILE
*
DSKFCONTROL      EQU     *
        ;JSR    GETFCBFROMIOCB      SET UP FCB POINTER
        JSR     GETFCBFROMIOCB
        ;LDX    #DSKFCONTROL0    BRANCH ON STANDARD DISK FILE CONTROL OPERATIONS
        LDX     #DSKFCONTROL0
        ;JSR    TABLEBRANCH
        JSR     TABLEBRANCH
        ;LDX    #DSKFCONTROL10   BRANCH ON DISK FILE SPECIFIC CONTROL OPERATIONS
        LDX     #DSKFCONTROL10
        ;JSR    TABLEBRANCH
        JSR     TABLEBRANCH
ERRILLDEVOP     EQU     *
        ;JSR    ERRET   NO, NOT A VALID CONTROL REQUEST
        JSR     ERRET
        FDB      ERR:ILLDEVICEOP

DSKFCONTROL0 ; BRANCH TABLE FOR STANDARD DISK FILE CONTROL OPERATIONS
        FCB       CC:POSITION,CC:DUMPBUFFERS
        #DSKFPOSITION   CC:POSITION
        #DSKDUMPBUFFERS  CC:DUMPBUFFERS

DSKFCONTROL10    ; BRANCH TABLE FOR DISK FILE SPECIFIC CONTROL OPERATIONS
        FCB       CC:SETFILEDATE,CC:POSITIONTOEND
        #DSKFSETDATE     CC:SETFILEDATE
        #DSKFSETPROT    CC:SETFILEPROT
        #DSKFSETSIZE    CC:SETFILESIZE
        #DSKFPOSITIONTOEND      CC:POSITIONTOEND
*       #DSKFTABS CC:TABS
*       #DSKDFSETACTBLOCK   CC:SETACTBLOCK

DSKFOPENERRORFILE       ; INTENDED FOR USE ONLY WITH SYSIOCB
        ;LDX    ERRFCBPOINTER     DOES ERROR FILE EXIST?
        LDX     ERRFCBPOINTER
        BEQ      ERRNOERRMSGS    B/ NO ERROR FILE!?
        STX     FCBPOINTER        RECORD FCB ADDRESS OF ERROR FILE
        ;INC     FCB:REFCOUNT,X     SINCE THIS IS SECOND TIME WE'LL OPEN...
        INC      FCB:REFCOUNT,X
        ;LDX    FCB:DISKINFO,X    SET UP DISKINFO POINTER...
        LDX     FCB:DISKINFO,X
        STX     DCBPOINTER        JUST LIKE A CALL TO OPEN WOULD HAVE DONE
        ;JMP    DSKFOPENSYSIOCB   DO REST LIKE A NORMAL OPEN
        JMP     DSKFOPENSYSIOCB

ERRNOERRMSGS    EQU     *
        ;JSR    ERRET
        JSR     ERRET
        FDB      ERR:NOERRORMSGS
        PAGE
DSKFSETSIZE     ; SET SIZE OF DISK FILE TO CURRENT FILE POSITION
        ;JSR    UPDATEFILEDATE    CHANGE DATE OF FILE
        JSR     UPDATEFILEDATE
        ;LDX    IOCBPOINTER       GET FILE SIZE DESIRED
        LDX     IOCBPOINTER
        ;LDD    IOCB:CURBYTE,X
        LDAB      (IOCB:CURBYTE)+1,X
        LDAA      IOCB:CURBYTE,X
        ;PSHD
        PSHB
        PSHA
        ;LDD    IOCB:CURBYTE+2,X
        LDAB      (IOCB:CURBYTE+2)+1,X
        LDAA      IOCB:CURBYTE+2,X
        ;LDX    FCBPOINTER        STUFF INTO FCB
        LDX     FCBPOINTER
        ;STD    FCB:FILESIZE+2,X
        STAB      (FCB:FILESIZE+2)+1,X
        STAA      FCB:FILESIZE+2,X
        ;PULD
        PULA
        PULB
        ;STD    FCB:FILESIZE,X
        STAB      (FCB:FILESIZE)+1,X
        STAA      FCB:FILESIZE,X
        BSR      DSKFEOFTEST     SET EOF FLAG
        BCS       *+2     SURPRESS EOF ERROR THAT WILL OCCUR
DSKFIMPLIEDPOSOKRTS
        OKRTS

DSKFIMPLIEDPOSITION     ; HANDLE IMPLIED CC:POSITION BEFORE READ/WRITE
        ;JSR    GETFCBFROMIOCB      THIS IS REQUIRED BEFORE WE DO ANYTHING...
        JSR     GETFCBFROMIOCB
        ;LDB     #RWPOSITION:SCLEN        IS SYSCALL BLOCK LONG ENOUGH TO INCLUDE A POSITION ?
        LDAB      #RWPOSITION:SCLEN
        ;JSR    CHECKSCLEN ...?
        JSR     CHECKSCLEN
        BCS       DSKFIMPLIEDPOSOKRTS     B/ NO, SO DON'T POSITION THE FILE
        ;LDD    RW:POSITION,X   YES, GET THE DESIRED FILE POSITION
        LDAB      (RW:POSITION)+1,X
        LDAA      RW:POSITION,X
        ;PSHD
        PSHB
        PSHA
        ;LDD    RW:POSITION+2,X
        LDAB      (RW:POSITION+2)+1,X
        LDAA      RW:POSITION+2,X
        BRA       DSKFPOSITION1   GO DO FILE POSITION, GIVE EOF ERROR IF PAST EOF

DSKFPOSITIONTOEND ; POSITION FILE TO END
        BSR      DSKFPOSITIONTOEND1
        BCS       *+2     IGNORE EOF ERROR IF IT OCCURS
        OKRTS

DSKFPOSITIONTOEND1      ; SUBROUTINE FOR DSKFPOSITIONTOEND
        ;LDX    FCBPOINTER        GET FILESIZE, SO WE CAN...
        LDX     FCBPOINTER
        ;LDD    FCB:FILESIZE,X    POSITION TO EOF
        LDAB      (FCB:FILESIZE)+1,X
        LDAA      FCB:FILESIZE,X
        ;PSHD
        PSHB
        PSHA
        ;LDD    FCB:FILESIZE+2,X
        LDAB      (FCB:FILESIZE+2)+1,X
        LDAA      FCB:FILESIZE+2,X
        BRA       DSKFPOSITION1   GO DO POSITIONING

DSKFPOSITION    ; SET IOCB:CURBYTE TO POSITION:DIST
        ;JSR    CHECKWRLEN        MAKE SURE THERE ARE AT LEAST...
        JSR     CHECKWRLEN
        FDB      4       BYTES IN WRITE LENGTH
        ;LDX    SCBLK:WRBUF,X
        LDX     SCBLK:WRBUF,X
        ;LDD    CONTROL:DATA,X     COPY POSITION DATA TO (TOS,TOS-1),(A,B)
        LDAB      (CONTROL:DATA)+1,X
        LDAA      CONTROL:DATA,X
        ;PSHD
        PSHB
        PSHA
        ;LDD    CONTROL:DATA+2,X
        LDAB      (CONTROL:DATA+2)+1,X
        LDAA      CONTROL:DATA+2,X
DSKFPOSITION1   ; ENTRY POINT FOR DSKFCLOSE
        ;LDX    IOCBPOINTER       NOW COPY TO IOCB:CURBYTE
        LDX     IOCBPOINTER
        ;CLR     IOCB:LOCATEDF,X     MARK "LOCATECURBYTE REQ'D"
        CLR      IOCB:LOCATEDF,X
        ;CLR     IOCB:COLCNT,X       ALSO, ZERO THE COLUMN COUNTER
        CLR      IOCB:COLCNT,X
        ;STD    IOCB:CURBYTE+2,X
        STAB      (IOCB:CURBYTE+2)+1,X
        STAA      IOCB:CURBYTE+2,X
        ;PULD
        PULA
        PULB
        ;STD    IOCB:CURBYTE,X
        STAB      (IOCB:CURBYTE)+1,X
        STAA      IOCB:CURBYTE,X
        BMI      ERRBADPOSITION    B/ POSITION < 0!!
*       BRA       DSKFEOFTEST     GO TEST FOR EOF HIT
        PAGE
*
*       DSKFEOFTEST -- TEST FOR CURBYTE >= FILESIZE
*               SET EOFFLAG IF SO, TAKE ERRET
*
DSKFEOFTEST     ; TEST TO SEE IF POSITION OFF END OF FILE
        ;LDX    FCBPOINTER        NOW MOVE FCB:FILESIZE...
        LDX     FCBPOINTER
        ;LDD    FCB:FILESIZE,X    TO (TOS-2),(TOS-1),(TOS),(A)
        LDAB      (FCB:FILESIZE)+1,X
        LDAA      FCB:FILESIZE,X
        ;PSHD
        PSHB
        PSHA
        ;LDD    FCB:FILESIZE+2,X
        LDAB      (FCB:FILESIZE+2)+1,X
        LDAA      FCB:FILESIZE+2,X
        ;LDX    IOCBPOINTER       COMPUTE FCB:FILESIZE-IOCB:CURBYTE-1
        LDX     IOCBPOINTER
        ;CLR     IOCB:EOFFLAG,X     ASSUME NOT EOF
        CLR      IOCB:EOFFLAG,X
        SEC              (THE -1 IS BECAUSE FILESIZE IS 1 ORIGIN)
        SBCB       IOCB:CURBYTE+3,X    I.E., CHECK IF IOCB:CURBYTE >= FCB:FILESIZE
        SBCA       IOCB:CURBYTE+2,X
        ;PULD
        PULA
        PULB
        SBCB       IOCB:CURBYTE+1,X
        SBCA       IOCB:CURBYTE,X
DSKFEOFTESTROL  ; ENTRY POINT FOR DSKDEOFTEST
        ROL     IOCB:EOFFLAG,X     A BORROW BIT IN CARRY --> EOF
        BNE      ERREOFHIT       B/ RAN OFF END OF FILE
        OKRTS

ERREOFHIT       EQU     *
        ;JSR    ERRET
        JSR     ERRET
        FDB      ERR:EOFHIT

ERRBADPOSITION    EQU     *
        ;CLR     IOCB:CURBYTE,X      RESET POINTER TO FILE START
        CLR      IOCB:CURBYTE,X
        ;CLR     IOCB:CURBYTE+1,X
        CLR      IOCB:CURBYTE+1,X
        ;CLR     IOCB:CURBYTE+2,X
        CLR      IOCB:CURBYTE+2,X
        ;CLR     IOCB:CURBYTE+3,X
        CLR      IOCB:CURBYTE+3,X
        BSR      DSKFEOFTEST     IN CASE THE FILE IS EMPTY
        ;JSR    ERRET
        JSR     ERRET
        FDB      ERR:BADPOSITION
        PAGE
DSKFGETFILESIZE ; GET FILE SIZE BACK FROM FILE
        ;JSR    CHECKRDLEN        MAKE SURE THERE ARE 4 BYTES IN THE READ-BACK BUFFER
        JSR     CHECKRDLEN
        FDB      4
        ;LDX    FCBPOINTER        COPY FCB:FILESIZE...
        LDX     FCBPOINTER
        ;LDD    FCB:FILESIZE,X    TO (TOS,TOS-1), (A,B)
        LDAB      (FCB:FILESIZE)+1,X
        LDAA      FCB:FILESIZE,X
        ;PSHD
        PSHB
        PSHA
        ;LDD    FCB:FILESIZE+2,X
        LDAB      (FCB:FILESIZE+2)+1,X
        LDAA      FCB:FILESIZE+2,X
        BRA       DSKFGETPOS4     GO COPY TO READ BACK BUFFER
*
DSKFGETPOS      ; GET POSITION BACK FROM FILE
        ;JSR    CHECKRDLEN        MAKE SURE THERE IS A 4 BYTE BUFFER
        JSR     CHECKRDLEN
        FDB      4
        ;LDX    IOCBPOINTER       COPY IOCB:CURBYTE...
        LDX     IOCBPOINTER
        ;LDD    IOCB:CURBYTE,X      TO (TOS,TOS-1), (A,B)
        LDAB      (IOCB:CURBYTE)+1,X
        LDAA      IOCB:CURBYTE,X
        ;PSHD
        PSHB
        PSHA
        ;LDD    IOCB:CURBYTE+2,X
        LDAB      (IOCB:CURBYTE+2)+1,X
        LDAA      IOCB:CURBYTE+2,X
DSKFGETPOS4     EQU     *
        ;LDX    CODE+SDOS:IOBLOCKPTR       AND THEN TO TARGET BUFFER
        LDX     CODE+SDOS:IOBLOCKPTR
        ;LDX    SCBLK:RDBUF,X      GET POINTER TO PLACE TO PUT POSITION
        LDX     SCBLK:RDBUF,X
        STAB      STATUS:DATA+3,X
DSKFGETPOS3     ; STORE 3 BYTES INTO READ-BACK BUFFER
        STAA      STATUS:DATA+2,X
        ;PULD
        PULA
        PULB
        ;STD    STATUS:DATA+0,X
        STAB      (STATUS:DATA+0)+1,X
        STAA      STATUS:DATA+0,X
        OKRTS
        PAGE
DSKDGETBADLSN     ; READ BACK THE LAST BAD LSN
        ;JSR    CHECKRDLEN        MAKE SURE WE HAVE ROOM FOR REPLY
        JSR     CHECKRDLEN
        FDB      3
        ;LDX    DCBPOINTER        COPY LAST BAD LSN TO (TOS,TOS-1,A)
        LDX     DCBPOINTER
        ;LDD    DSKINFO:BADLSN,X
        LDAB      (DSKINFO:BADLSN)+1,X
        LDAA      DSKINFO:BADLSN,X
        ;PSHD
        PSHB
        PSHA
        LDAA      DSKINFO:BADLSN+2,X
        LDAB      #$FF    FORGET WE HAD A BAD LSN
        STAB      DSKINFO:BADLSN,X
        STAB      DSKINFO:BADLSN+1,X
        STAB      DSKINFO:BADLSN+2,X
DSKFGETPOS3A     EQU     *
        ;LDX    CODE+SDOS:IOBLOCKPTR       GET POINTER TO READ BACK BUFFER
        LDX     CODE+SDOS:IOBLOCKPTR
        ;LDX    SCBLK:RDBUF,X
        LDX     SCBLK:RDBUF,X
        BRA       DSKFGETPOS3     GO STORE 3 BYTES INTO READ-BACK BUFFER

DSKFGETPARAMS     ; GET FILE "DEVICE" PARAMETERS
        ;JSR    CHECKRDLEN        = SECTOR SIZE, NUMBER OF SECTORS PER CLUSTER
        JSR     CHECKRDLEN
        FDB      2+1     2 BYTES FOR SECTOR SIZE; 1 FOR # SECTORS PER CLUSTER
        ;LDX    DCBPOINTER        GET POINTER TO TABLE
        LDX     DCBPOINTER
        ;LDD    DSKINFO:NBPS,X   GRAB SECTOR SIZE
        LDAB      (DSKINFO:NBPS)+1,X
        LDAA      DSKINFO:NBPS,X
        ;PSHD
        PSHB
        PSHA
        LDAA      DSKINFO:NSPC,X   GET CLUSTER SIZE
        BRA       DSKFGETPOS3A
        PAGE
*
*       DSKFSTATUS -- DO A STATUS READ ON DISK FILE
*
DSKFSTATUS       EQU     *
        ;JSR    GETFCBFROMIOCB      SET UP FCB POINTER
        JSR     GETFCBFROMIOCB
        ;LDX    #DSKFSTATUS0     BRANCH TABLE FOR STANDARD DISK FILE STATUS OPERATIONS
        LDX     #DSKFSTATUS0
        ;JSR    TABLEBRANCH
        JSR     TABLEBRANCH
        ;LDX    #DSKFSTATUS10    BRANCH TABLE FOR DISK FILE SPECIFIC STATUS
        LDX     #DSKFSTATUS10
        ;JSR    TABLEBRANCH
        JSR     TABLEBRANCH
        ;JMP    ERRILLDEVOP
        JMP     ERRILLDEVOP

DSKFSTATUS0      ; BRANCH TABLE FOR STANDARD DISK FILE STATUS OPERATIONS
        FCB       SC:GETPOS,SC:GETPARAMS
        #DSKFGETPOS     SC:GETPOS
        #DSKFGETCOL      SC:GETCOL
        #DSKFGETEOF     SC:GETEOF
        #DSKFGETFILESIZE        SC:GETFILESIZE
        #DSKFGETTYPE    SC:GETTYPE
        #DSKFGETPARAMS    SC:GETPARAMS

DSKFSTATUS10     ; BRANCH TABLE FOR DISK FILE SPECIFIC OPERATIONS
        FCB       SC:GETFILEDATE,SC:GETFILEPROT
        #DSKFGETDATE     SC:GETFILEDATE
        #DSKFGETPROT    SC:GETFILEPROT
        PAGE
*
*       DSKDSTATUS -- DO A STATUS READ ON DISK DEVICE
*
DSKDSTATUS       EQU     *
        ;LDX    #DSKDSTATUS0     BRANCH TABLE FOR DISK DEVICE STANDARD STATUS CALLS
        LDX     #DSKDSTATUS0
        ;JSR    TABLEBRANCH
        JSR     TABLEBRANCH
        ;LDX    #DSKDSTATUS10    BRANCH TABLE FOR DISK DEVICE SPECIFIC STATUS CALLS
        LDX     #DSKDSTATUS10
        ;JSR    TABLEBRANCH
        JSR     TABLEBRANCH
        ;LDX    DCBPOINTER        I DON'T RECOGNIZE THE STATUS CALL...
        LDX     DCBPOINTER
        ;LDX    DCB:DRIVER,X      SO LET I/O PACKAGE DISK DRIVER HANDLE IT
        LDX     DCB:DRIVER,X
        ;JMP    [DRIVER:DISKSTATUS,X]    WITH (A) = STATUS REQUEST CODE
        LDX     DRIVER:DISKSTATUS,X
        JMP     0,X

DSKDSTATUS0 ; BRANCH TABLE FOR DISK DEVICE STANDARD STATUS CALLS
        FCB       SC:GETPOS,SC:GETPARAMS
        #DSKFGETPOS     SC:GETPOS
        #DSKFGETCOL      SC:GETCOL
        #DSKFGETEOF     SC:GETEOF
        #ERRILLDEVOP    SC:GETFILESIZE   CAN'T WE DO THIS BETTER?
        #DSKDGETTYPE    SC:GETTYPE
        #DSKDGETPARAMS    SC:GETPARAMS

DSKDSTATUS10     ; BRANCH TABLE FOR DISK DEVICE SPECIFIC STATUS CALLS
        FCB       SC:GETLASTBADLSN,SC:GETERRORSTATS
        #DSKDGETBADLSN    SC:GETLASTBADLSN
        #DSKDGETERRORSTATS       SC:GETERRORSTATS
        PAGE
DSKDGETERRORSTATS ; GET DISK DEVICE ERROR STATISTICS
        ;JSR    CHECKRDLEN        ENOUGH ROOM IN REPLY BUFFER FOR ERROR STATS?
        JSR     CHECKRDLEN
        FDB      (DSKINFO:ERRLSN+LSN:SIZE)-DSKINFO:SEEKERRCNT
        IF      M6800!M6801
        ;LDD    SCBLK:RDBUF,X      GET TARGET ADDRESS
        LDAB      (SCBLK:RDBUF)+1,X
        LDAA      SCBLK:RDBUF,X
        ;STD    TOPOINTER
        STAB      TOPOINTER+1
        STAA      TOPOINTER
        ELSE    (M6809)
        LDY     SCBLK:RDBUF,X
        FIN
        IF      M6800!M6801
        ;LDD    DCBPOINTER        FIGURE OUT THE SOURCE ADDRESS
        LDAB      DCBPOINTER+1
        LDAA      DCBPOINTER
        ;ADDD    #DSKINFO:SEEKERRCNT
        ADDB      #(DSKINFO:SEEKERRCNT)&$FF
        ADCA       #(DSKINFO:SEEKERRCNT)/256
        ;STD    FROMPOINTER
        STAB      FROMPOINTER+1
        STAA      FROMPOINTER
        ;LDD    SCBLK:RPLEN,X     HOW MANY BYTES TO MOVE...
        LDAB      (SCBLK:RPLEN)+1,X
        LDAA      SCBLK:RPLEN,X
        ;LDX    FROMPOINTER
        LDX     FROMPOINTER
        ELSE    (M6809)
        ;LDD    SCBLK:RPLEN,X     HOW MANY BYTES TO MOVE...
        LDAB      (SCBLK:RPLEN)+1,X
        LDAA      SCBLK:RPLEN,X
        ;LDX    DCBPOINTER        = WHERE TO GET BYTES FROM
        LDX     DCBPOINTER
        ;LEAX    DSKINFO:SEEKERRCNT,X
        IF      DSKINFO:SEEKERRCNT<0
        RPT     -DSKINFO:SEEKERRCNT
        DEX
        ELSE
        RPT     DSKINFO:SEEKERRCNT
        INX
        FIN
        FIN
        ;JSR    CODE+SDOS:BLOCKMOVE        USE ENTRY POINT VECTOR SO BLOCKMOVE CAN BE REPLACED BY USER ROUTINE
        JSR     CODE+SDOS:BLOCKMOVE
        OKRTS
        PAGE
DSKFGETPROT     ; GET FILE PROTECTION/BACKUP BITS
        ;JSR    CHECKRDLEN        MAKE SURE REPLY BUFFER IS LARGE ENOUGH!
        JSR     CHECKRDLEN
        FDB      1
        ;LDX    FCBPOINTER        THIS FILE...
        LDX     FCBPOINTER
        LDAA      FCB:PROT,X
        BRA       DSKFGETCOL1      GO STORE FLAG DATA IN USER BUFFER

DSKFGETDATE ; GET CREATION DATE INFORMATION IN CLOCK FORMAT
        ;JSR    CHECKRDLEN        MUST BE 6 BYTES
        JSR     CHECKRDLEN
        FDB      6
        ;LDX    FCBPOINTER        THIS FILE...
        LDX     FCBPOINTER
        LDAA      FCB:DAY,X
        PSHA
        ;LDD    FCB:MONTH,X       AND THE YEAR
        LDAB      (FCB:MONTH)+1,X
        LDAA      FCB:MONTH,X
        ;LDX    CODE+SDOS:IOBLOCKPTR       = USER SYSCALL BLOCK
        LDX     CODE+SDOS:IOBLOCKPTR
        ;LDX    SCBLK:RDBUF,X      WHERE TO PUT REPLY
        LDX     SCBLK:RDBUF,X
        ;STD    STATUS:DATA+4,X
        STAB      (STATUS:DATA+4)+1,X
        STAA      STATUS:DATA+4,X
        PULA
        STAA      STATUS:DATA+3,X
        ;CLR     STATUS:DATA,X      SET TIME TO MIDNITE
        CLR      STATUS:DATA,X
        ;CLR     STATUS:DATA+1,X
        CLR      STATUS:DATA+1,X
        ;CLR     STATUS:DATA+2,X
        CLR      STATUS:DATA+2,X
        OKRTS

DSKDGETTYPE     ; GET DISK DEVICE TYPE
        ;JSR    CHECKRDLEN        MAKE SURE READ-BACK BUFFER HAS ENOUGH ROOM
        JSR     CHECKRDLEN
        FDB      1
*
*       IT SHOULD WORK THIS WAY! (SDOS1.2)
*       LDX     DCBPOINTER
*       LDA      DCB:DVTYP,X
*
        LDAA      #DVTYP.DISK
        BRA       DSKFGETCOL1

DSKFGETTYPE     ; GET (DISK) FILE DEVICE TYPE
        ;JSR    CHECKRDLEN        MAKE SURE READ-BACK BUFFER HAS ENOUGH ROOM
        JSR     CHECKRDLEN
        FDB      1
        LDAA      #DVTYP.FILE
        BRA       DSKFGETCOL1
        PAGE
DSKFGETCOL       ; GET COLUMN COUNTER FOR FILE
        ;JSR    CHECKRDLEN        MAKE SURE READ BACK BUFFER HAS ONE BYTE
        JSR     CHECKRDLEN
        FDB      1
        ;LDX    IOCBPOINTER
        LDX     IOCBPOINTER
        LDAA      IOCB:COLCNT,X
DSKFGETCOL1      EQU     *
        ;LDX    CODE+SDOS:IOBLOCKPTR
        LDX     CODE+SDOS:IOBLOCKPTR
        ;LDX    SCBLK:RDBUF,X      GET ADDRESS OF PLACE TO STORE COLUMN
        LDX     SCBLK:RDBUF,X
        STAA      STATUS:DATA,X
        OKRTS

DSKFGETEOF      ; GET END OF FILE FLAG FOR FILE
        ;JSR    CHECKRDLEN        ENSURE AT LEAST 1 BYTE READ BUFFER
        JSR     CHECKRDLEN
        FDB      1
        ;LDX    IOCBPOINTER
        LDX     IOCBPOINTER
        LDAA      IOCB:EOFFLAG,X
        BRA       DSKFGETCOL1

DSKDGETPARAMS     ; GET DISK DEVICE PARAMETERS
        ;JSR    CHECKRDLEN        MAKE SURE THERE'S ENOUGH SPACE TO READ TYPE DATA BACK
        JSR     CHECKRDLEN
        FDB      DSKINFO:NCYL+1-DSKINFO:NBPS+1
        IF      M6800!M6801
        ;LDX    SCBLK:RDBUF,X      GET POINTER TO READ-BACK BUFFER
        LDX     SCBLK:RDBUF,X
        STX     TOPOINTER       SET UP TO COPY DISKINFO PHYSICAL DISK DATA
        ELSE    (M6809)
        LDY     SCBLK:RDBUF,X      GET POINTER TO TARGET BUFFER
        FIN
        ;LDX    DCBPOINTER        GET POINTER TO SOURCE BUFFER
        LDX     DCBPOINTER
        ;LEAX    DSKINFO:NBPS,X
        IF      DSKINFO:NBPS<0
        RPT     -DSKINFO:NBPS
        DEX
        ELSE
        RPT     DSKINFO:NBPS
        INX
        FIN
        ;LDD    #DSKINFO:NCYL+1-DSKINFO:NBPS+1    = BYTE COUNT TO COPY
        LDAB      #(DSKINFO:NCYL+1-DSKINFO:NBPS+1)&$FF
        LDAA      #(DSKINFO:NCYL+1-DSKINFO:NBPS+1)/256
        ;JSR    CODE+SDOS:BLOCKMOVE        MOVE THE DATA TO USERS BUFFER
        JSR     CODE+SDOS:BLOCKMOVE
        OKRTS           ALL DONE!
        PAGE
*       DSKDSETMAPALGORITHM -- SETS DSKINFO:MAPALGORITHM TO SPECIFIED VALUE
*
DSKDSETMAPALGORITHM       EQU     *
        ;JSR    CHECKWRLEN        MAKE SURE AT LEAST 2 BYTES IN WRITE BUFFER
        JSR     CHECKWRLEN
        FDB      2
        ;LDX    SCBLK:WRBUF,X      GET POINTER TO MAPALGORITHM DESIRED
        LDX     SCBLK:WRBUF,X
        ;LDD    CONTROL:DATA,X     GET DESIRED MAP ALGORITHM NUMBER
        LDAB      (CONTROL:DATA)+1,X
        LDAA      CONTROL:DATA,X
        ;LDX    DCBPOINTER        UPDATE THE DISKINFO TABLE
        LDX     DCBPOINTER
        TST     DSKINFO:DIRFCB,X  IS THIS DRIVE DISMOUNTED ?
        BNE      ERRDISKMOUNTED  B/ NO, CAN'T CHANGE MAP ALGORITHM UNLESS DISMOUNTED!
*
*       DSKDSETMAPALGDUMP -- CHECK TO SEE IF DUMPBUFFERS IS REQUIRED...
*       BEFORE WE SET THE MAP ALGORITHM
*       (A,B) CONTAINS NEW MAP ALGORITHM
*       (X) = DCBPOINTER
*
DSKDSETMAPALGDUMP EQU     *
        ;CMPD    DSKINFO:MAPALGORITHM,X    SAME MAP ALGORITHM AS LAST TIME ?
        CMPA      DSKINFO:MAPALGORITHM,X
        BNE      MACRO:0015
        CMPB      (DSKINFO:MAPALGORITHM)+1,X
MACRO:0015
        BEQ      DSKDSETMAPALGRTS  B/ YES, DON'T NEED TO DO ANYTHING!
DSKDSETMAPALG0    ; MUST DUMP BUFFERS BEFORE CHANGING MAPALGORITHM
        ;PSHD           SAVE NEW MAP ALGORITHM
        PSHB
        PSHA
        ;JSR    DSKDUMPBUFFERS   USING OLD ALGORITHM
        JSR     DSKDUMPBUFFERS
        BCC        DSKDSETMAPALG1    B/ NO ERRORS
        ;LEAS    2,S     ERROR OCCURRED! FORGET NEW MAP ALGORITHM
        IF      2<0
        RPT     -2
        DES
        ELSE
        RPT     2
        INS
        FIN
        ;JMP    ERRORED AND RETURN TO CALLER
        JMP     ERRORED

DSKDSETMAPALG1    ; BUFFERS ARE DUMPED
        ;PULD           RETRIEVE NEW MAP ALGORITHM
        PULA
        PULB
DSKDSETMAPALG2    ; ENTRY POINT FOR DISK DISMOUNT
        ;LDX    DCBPOINTER
        LDX     DCBPOINTER
        ;STD    DSKINFO:MAPALGORITHM,X    UPATE THE TABLE TO REFLECT NEW ALGORITHM NUMBER
        STAB      (DSKINFO:MAPALGORITHM)+1,X
        STAA      DSKINFO:MAPALGORITHM,X
        ;JSR    MARKINVALID       MARK ALL SECTORS IN POOL FROM DISK AS INVALID
        JSR     MARKINVALID
        ;JSR    FORGETLASTBADLSN   MAKE LAST BAD LSN DATA DISAPPEAR
        JSR     FORGETLASTBADLSN
DSKDSETMAPALGRTS  EQU     *
        OKRTS

ERRDISKMOUNTED  EQU     *
        ;JSR    ERRET
        JSR     ERRET
        FDB      ERR:DISKMOUNTED
        PAGE
*
*       DSKDOPEN -- OPEN THE DISK DEVICE
*
DSKDOPEN        EQU     *
        ;LDX    DCBPOINTER        IS THE DISK MOUNTED ?
        LDX     DCBPOINTER
        LDAA      DSKINFO:DIRFCB,X  ... ?
        BNE      DSKDOPEN1       B/ YES, USE MAP ALGORITHM SPECIFIED BY DISK
        LDAB      #1      NO, DEFAULT TO MAPALGORITHM :0001
        BSR      DSKDSETMAPALGDUMP GO SET THE MAP ALGORITHM
DSKDOPEN1       ; NOW SET UP THE IOCB
        ;LDX    IOCBPOINTER
        LDX     IOCBPOINTER
        ;LDD    #0
        LDAB      #(0)&$FF
        LDAA      #(0)/256
        STAA      IOCB:COLCNT,X       ZERO THE COLUMN COUNT
        ;STD    IOCB:CURBYTE,X      SET FILE POSITION TO START OF DISK
        STAB      (IOCB:CURBYTE)+1,X
        STAA      IOCB:CURBYTE,X
        ;STD    IOCB:CURBYTE+2,X
        STAB      (IOCB:CURBYTE+2)+1,X
        STAA      IOCB:CURBYTE+2,X
        ;STD    IOCB:DRDSI,X      FLAG 'NO DATA SECTOR READ'
        STAB      (IOCB:DRDSI)+1,X
        STAA      IOCB:DRDSI,X
        INCA              = LDAA #1
        STAA      IOCB:DISKWRITELOCKED,X     MUST "UNLOCK" BEFORE ANY WRITES
        BRA       DSKDEOFTEST     GO COMPUTE CURLSN
        PAGE
*       DSKDCONTROL -- DO A CONTROL OPERATION ON THE DISK DEVICE
*
DSKDCONTROL      EQU     *
        ;LDX    #DSKDCONTROL0    BRANCH TABLE FOR DISK DEVICE STANDARD CONTROL OPERATORS
        LDX     #DSKDCONTROL0
        ;JSR    TABLEBRANCH
        JSR     TABLEBRANCH
        ;LDX    #DSKDCONTROL10   BRANCH TABLE FOR DISK DEVICE SPECIFIC CONTROL OPERATIONS
        LDX     #DSKDCONTROL10
        ;JSR    TABLEBRANCH
        JSR     TABLEBRANCH
DSKDCONTROL1     ; RE-ENTRY POINT FOR "DSKDDISMOUNT"
        ;LDX    DCBPOINTER        NOT ANY CONTROL OPERATION I RECOGNIZE...
        LDX     DCBPOINTER
        ;LDX    DCB:DRIVER,X      SO LET I/O PACKAGE HANDLE IT
        LDX     DCB:DRIVER,X
        ;JMP    [DRIVER:DISKCONTROL,X]   WITH (A) = CONTROL CODE
        LDX     DRIVER:DISKCONTROL,X
        JMP     0,X

DSKDCONTROL0     ; BRANCH TABLE FOR DISK DEVICE STANDARD CONTROL OPERATIONS
        FCB       CC:POSITION,CC:DUMPBUFFERS
        #DSKDPOSITION   CC:POSITION
        #DSKDUMPBUFFERS  CC:DUMPBUFFERS

DSKDCONTROL10    ; BRANCH TABLE FOR DISK DEVICE SPECIFIC CONTROL OPERATIONS
        FCB       CC:UNLOCKDISK,CC:SETMAPALGORITHM
        #DSKDUNLOCK      CC:UNLOCKDISK
        #DSKDDISMOUNT   CC:DISMOUNTDISK
        #DSKDSETMAPALGORITHM      CC:SETMAPALGORITHM
        PAGE
*       DSKDIMPLIEDPOSITION -- DO IMPLIED POSITIONING ON DISK DEVICE, IF REQUESTED
*
DSKDIMPLIEDPOSITION
        ;LDB     #RWPOSITION:SCLEN        DOES SYSCALL BLOCK CONTAIN FILE POSITION ?
        LDAB      #RWPOSITION:SCLEN
        ;JSR    CHECKSCLEN ...?
        JSR     CHECKSCLEN
        BCS       DSKDIMPLIEDPOSOKRTS     B/ NO, DON'T POSITION DISK DEVICE
        ;LDD    RW:POSITION+2,X GET, GET THE POSITION DESIRED
        LDAB      (RW:POSITION+2)+1,X
        LDAA      RW:POSITION+2,X
        ;PSHD
        PSHB
        PSHA
        ;LDD    RW:POSITION,X
        LDAB      (RW:POSITION)+1,X
        LDAA      RW:POSITION,X
        BRA       DSKDPOSITION1   GO SET POSITION OF DISK DEVICE AND CAUSE EOF IF PAST END
*
*       DSKDPOSITION -- DO POSITIONING ON DISK DEVICE
*
DSKDPOSITION    EQU     *
        ;JSR    CHECKWRLEN        MUST HAVE AT LEAST 4 BYTES OF POSITION DATA
        JSR     CHECKWRLEN
        FDB      4
        ;LDX    SCBLK:WRBUF,X      GET POINTER TO POSITIONING DATA
        LDX     SCBLK:WRBUF,X
        ;LDD    CONTROL:DATA+2,X   COPY DESIRED POSITION TO (A,B,TOS,TOS-1)
        LDAB      (CONTROL:DATA+2)+1,X
        LDAA      CONTROL:DATA+2,X
        ;PSHD
        PSHB
        PSHA
        ;LDD    CONTROL:DATA+0,X
        LDAB      (CONTROL:DATA+0)+1,X
        LDAA      CONTROL:DATA+0,X
DSKDPOSITION1   ; ENTRY POINT FOR DSKDIMPLIEDPOSITION
        ;LDX    IOCBPOINTER       NOW COPY DESIRED POSITION INTO CURBYTE
        LDX     IOCBPOINTER
        ;STD    IOCB:CURBYTE,X
        STAB      (IOCB:CURBYTE)+1,X
        STAA      IOCB:CURBYTE,X
        ;PULD
        PULA
        PULB
        ;STD    IOCB:CURBYTE+2,X
        STAB      (IOCB:CURBYTE+2)+1,X
        STAA      IOCB:CURBYTE+2,X
        ;CLR     IOCB:COLCNT,X       ZERO THE COLUMN COUNTER
        CLR      IOCB:COLCNT,X
*
*       DSKDEOFTEST -- COMPUTE "EOFFLAG" AND CURLSN
*
DSKDEOFTEST     EQU     *
        ;LDX    DCBPOINTER        SET CURLSN = CURBYTE / (2^LOG2NBPS)
        LDX     DCBPOINTER
        LDAB      DSKINFO:LOG2NBPS,X       I.E., THE DESIRED SECTOR NUMBER ON THE DISK
        ;LDX    IOCBPOINTER       FIRST, SET (A,CURLSN) := CURBYTE
        LDX     IOCBPOINTER
        LDAA      IOCB:CURBYTE+3,X
        STAA      IOCB:CURLSN+2,X
        LDAA      IOCB:CURBYTE+2,X
        STAA      IOCB:CURLSN+1,X
        LDAA      IOCB:CURBYTE+1,X
        STAA      IOCB:CURLSN,X
        LDAA      IOCB:CURBYTE,X
DSKDEOFTESTL    ; DIVIDE CURLSN BY 2^1
        LSRA             NOW, SET CURLSN := CURLSN / (2^LOG2NBPS)
        ROR     IOCB:CURLSN,X
        ROR     IOCB:CURLSN+1,X
        ROR     IOCB:CURLSN+2,X
        DECB              DOWN COUNT # RIGHT SHIFTS TO MAKE
        BNE      DSKDEOFTESTL    B/ MUST RIGHT SHIFT SOME MORE
        ;CLR     IOCB:BYTECOUNT,X    FORCE LOCATION OF NEXT BYTE AGAIN
        CLR      IOCB:BYTECOUNT,X
        ;CLR     IOCB:BYTECOUNT+1,X
        CLR      IOCB:BYTECOUNT+1,X
        ;CLR     IOCB:EOFFLAG,X     ASSUME WE'RE NOT AT EOF
        CLR      IOCB:EOFFLAG,X
        ;LDX    DCBPOINTER        NOW DECIDE IF WE'RE AT EOF ON DISK DEVICE
        LDX     DCBPOINTER
        LDAA      DSKINFO:NLSN,X  I.E., IF CURLSN >= NLSN...
        PSHA             I.E., IF 0 > NLSN - CURLSN - 1...
        ;LDD    DSKINFO:NLSN+1,X        I.E., IF NLSN - CURLSN CAUSES A BORROW
        LDAB      (DSKINFO:NLSN+1)+1,X
        LDAA      DSKINFO:NLSN+1,X
        ;LDX    IOCBPOINTER       SUBTRACT CURLSN, LOOKING FOR BORROW
        LDX     IOCBPOINTER
        SEC              THIS DOES THE "...- 1" PART
        SBCB       IOCB:CURLSN+2,X
        SBCA       IOCB:CURLSN+1,X
        PULA
        SBCA       IOCB:CURLSN,X
        ;JMP    DSKFEOFTESTROL  CARRY NOW CONTAINS BORROW BIT; GO SAVE IT
        JMP     DSKFEOFTESTROL
*
*       DSKDUNLOCK -- UNLOCK THE DISK DEVICE WRITE PROTECT
*
DSKDUNLOCK       EQU     *
        ;LDX    IOCBPOINTER       TURN THE WRITE LOCK FLAG OFF
        LDX     IOCBPOINTER
        ;CLR     IOCB:DISKWRITELOCKED,X
        CLR      IOCB:DISKWRITELOCKED,X
*
*       DSKDCLOSE -- CLOSE A DISK DEVICE
*
DSKDCLOSE        EQU     *
DSKDIMPLIEDPOSOKRTS     ; NO IMPLIED POSITION REQUIRED
        OKRTS
        PAGE
*       FORGETLASTBADLSN -- RESET DSKINFO:BADLSN TO :FFFFFF
*
FORGETLASTBADLSN
        ;LDX    DCBPOINTER
        LDX     DCBPOINTER
        LDAA      #$FF    FORGET ANY LAST BAD LSN
        STAA      DSKINFO:BADLSN,X
        STAA      DSKINFO:BADLSN+1,X
        STAA      DSKINFO:BADLSN+2,X
        RTS
*
*       ERRFCBOPENQ -- TEST FOR ERRORMSGS.SYS FCB SET UP ON DISK "DCBPOINTER"
*       RETURN CARRY RESET IF ERRORMSGS.SYS FCB SET UP ON DISK "DCBPOINTER"
*       ELSE RETURN WITH CARRY SET
*
ERRFCBOPENQ
        ;LDX    ERRFCBPOINTER     IS ERR FCB SET UP AT ALL?
        LDX     ERRFCBPOINTER
        BEQ      ERRFCBOPENERRRTS  B/ NOT OPEN
        ;LDX    FCB:DISKINFO,X    ARE ERRORMESSAGES ON CURRENTLY SELECTED DRIVE ?
        LDX     FCB:DISKINFO,X
        CPX      DCBPOINTER        ...
        BNE      ERRFCBOPENERRRTS  B/ NO, LEAVE ERROR MESSAGE FILE ALONE
        ;LDX    ERRFCBPOINTER     THIS WILL BE CONVENIENT FOR CALLER
        LDX     ERRFCBPOINTER
        OKRTS

ERRFCBOPENERRRTS ; ERROR MSG FCB NOT OPEN TO THIS DRIVE
        ERRORRTS
        PAGE
*
*       DSKDDISMOUNT -- DUMP ALL DISK DEPENDENT DATA BACK TO DISK
*       RELEASES ALL FCBS ATTACHED TO DISK
*       ALSO ZEROS DISKINFO'S IN RDSI'S
*       IF DISK I/O ERROR, LEAVE "DISK MOUNTED"
*
DSKDDISMOUNT    ; DISMOUNT A DISK DRIVE
*       FIRST, MAKE SURE THERE ARE NO OPEN FILES!
        LDAA      NFCBS     # FCBS TO SEARCH
        STAA      COUNT
        ;LDX    CODE+SDOS:CONFIGURATION    NOW SCAN ALL THE FCBS
        LDX     CODE+SDOS:CONFIGURATION
        ;LDD    [CNFG:IOCBPOINTERS,X]      = ADDRESS OF LAST FCB + FCB:SIZE
        LDX     CNFG:IOCBPOINTERS,X
        LDAB      1,X
        LDAA      0,X
DSKDDISMOUNTL   ; CHECK NEXT FCB TO SEE IF OPEN TO THIS DRIVE
        ;SUBD    #FCB:SIZE FIND NEXT FCB
        SUBB      #(FCB:SIZE)&$FF
        SBCA       #(FCB:SIZE)/256
        ;STD    FCBPOINTER
        STAB      FCBPOINTER+1
        STAA      FCBPOINTER
        ;LDX    FCBPOINTER        IS THIS FCB ACTIVE ?
        LDX     FCBPOINTER
        ;LDA     FCB:REFCOUNT,X     ...?
        LDAA      FCB:REFCOUNT,X
        BEQ      DSKDDISMOUNT0   B/ NO, IGNORE IT!
        ;LDX    FCB:DISKINFO,X    IS THIS FCB FOR DISK BEING DISMOUNTED?
        LDX     FCB:DISKINFO,X
        CPX      DCBPOINTER        ...?
        BNE      DSKDDISMOUNT0   B/ NOPE, IGNORE IT
        ;CMPA     #1      IS IT A SYSTEM FILE OPEN ON SOME I/O CHANNEL ?
        CMPA      #1
        BHI      ERRFILEISOPEN   (REF COUNT > 1 ?)
        ;LDX    DSKINFO:DIRFCB,X  NO, DIRECTORY FCB FOR THIS DRIVE ?
        LDX     DSKINFO:DIRFCB,X
        CPX      FCBPOINTER        ... ?
        BEQ      DSKDDISMOUNT0   B/ YES, THAT'S OK...
        ;LDX    FCB:DISKINFO,X    NO, MAYBE DISKMAP.SYS FCB ?
        LDX     FCB:DISKINFO,X
        ;LDX    DSKINFO:MAPFCB,X   ... ?
        LDX     DSKINFO:MAPFCB,X
        CPX      FCBPOINTER        ... ?
        BEQ      DSKDDISMOUNT0   B/ YES, THAT'S OK
        ;LDX    ERRFCBPOINTER     IS IT THE ERROR MESSAGE FILE ?
        LDX     ERRFCBPOINTER
        CPX      FCBPOINTER        ... ?
        BNE      ERRFILEISOPEN   B/ NO, A NON-SYSTEM FILE IS STILL OPEN!
DSKDDISMOUNT0   ; THIS FCB IS NOT OPEN TO THIS DISK, OR IS A SYSTEM FILE OPEN ONLY ONCE
        ;LDD    FCBPOINTER        GET FCB ADDRESS
        LDAB      FCBPOINTER+1
        LDAA      FCBPOINTER
        ;DEC     COUNT    DECREMENT # FCBS TO SEARCH
        DEC      COUNT
        BNE      DSKDDISMOUNTL   B/ MORE FCBS TO CHECK FOR OPEN TO THIS DISK
*       ASSERT: NO NON-SYSTEM FCBS ARE OPEN TO DISK BEING DISMOUNTED
        BSR      ERRFCBOPENQ       IS FCB FOR ERRORMSGS.SYS SET UP?
        BCS       DSKDDISMOUNT2   B/ NOPE
        STX     FCBPOINTER        YES, CHECK TO SEE IF ERRORMSGS.SYS IS DELETED
        LDAA      FCB:FLAGS,X        IS IT DELETED?
        BITA      #FCBFLG::DELETED  ...?
        BEQ      DSKDDISMOUNT2   B/ NO, NO SPECIAL ACTION NEEDED
        ;JSR    DSKFDELETESYSIOCB YES, PUT CLUSTERS BACK IN FREE SPACE
        JSR     DSKFDELETESYSIOCB
DSKDDISMOUNT2   ; RELEASE HOLD ON DISKMAP.SYS
        ;JSR    DSKDUMPBUFFERS   DUMP ALL THE SECTOR BUFFERS BACK TO DISK
        JSR     DSKDUMPBUFFERS
        LDAA      #CC:DISMOUNTDISK  LET DRIVER KNOW THAT WE ARE DONE WITH THIS DISK
        ;JSR    DSKDCONTROL1     (DO A CONTROL OPERATION!)
        JSR     DSKDCONTROL1
        ;LDD    #1              NOW SET DISK MAP ALGORITHM BACK TO ONE, JUST TO BE SAFE
        LDAB      #(1)&$FF
        LDAA      #(1)/256
        ;JSR    DSKDSETMAPALG2    MARK ALL SECTORS INVALID, FORGET LAST BAD LSN
        JSR     DSKDSETMAPALG2
        ;LDX    DCBPOINTER        RESET THE ERROR STATISTICS
        LDX     DCBPOINTER
        ;LDA     #$FF    MARK "NO ERROR LSN"
        LDAA      #$FF
        ;STA     DSKINFO:ERRLSN,X
        STAA      DSKINFO:ERRLSN,X
        ;STA     DSKINFO:ERRLSN+1,X
        STAA      DSKINFO:ERRLSN+1,X
        ;STA     DSKINFO:ERRLSN+2,X
        STAA      DSKINFO:ERRLSN+2,X
        ;LDB     #DSKINFO:ERRLSN-DSKINFO:SEEKERRCNT
        LDAB      #DSKINFO:ERRLSN-DSKINFO:SEEKERRCNT
DSKDDISMOUNTZ   ; ZERO THE ERROR STATISTICS LOOP
        ;CLR     DSKINFO:SEEKERRCNT,X     ZERO A STATISTIC BYTE
        CLR      DSKINFO:SEEKERRCNT,X
        INX
        DECB
        BNE      DSKDDISMOUNTZ   B/ MORE BYTES TO ZERO
        ;LDX    DCBPOINTER        RELEASE DIRFCB
        LDX     DCBPOINTER
        ;LDX    DSKINFO:DIRFCB,X
        LDX     DSKINFO:DIRFCB,X
        BEQ      DSKDDISMOUNTOKRTS       B/ NOT BUSY, THIS DRIVE WASN'T MOUNTED
        ;CLR     FCB:REFCOUNT,X     WAS BUSY, LET GO OF FCB
        CLR      FCB:REFCOUNT,X
        ;LDX    DCBPOINTER
        LDX     DCBPOINTER
        ;LDX    DSKINFO:MAPFCB,X
        LDX     DSKINFO:MAPFCB,X
        BEQ      DSKDDISMOUNT1   B/ UNUSUAL, THERE WAS NO MAP FILE!
        ;CLR     FCB:REFCOUNT,X     LET GO OF MAP FCB
        CLR      FCB:REFCOUNT,X
DSKDDISMOUNT1   EQU     *
        ;LDX    DCBPOINTER        MARK ALL SYSTEM FCBS OPEN TO DISK AS AVAILABLE
        LDX     DCBPOINTER
        CLRA              THE UNIVERSAL "INITIAL" VALUE
        CLRB
        ;STD    DSKINFO:DIRFCB,X  MARK DISKINFO FCBS AS NOT SET UP
        STAB      (DSKINFO:DIRFCB)+1,X
        STAA      DSKINFO:DIRFCB,X
        ;STD    DSKINFO:MAPFCB,X   (I.E., MARK DISK AS DISMOUNTED)
        STAB      (DSKINFO:MAPFCB)+1,X
        STAA      DSKINFO:MAPFCB,X
        ;JSR    ERRFCBOPENQ       IS ERRORMSGS.SYS FCB SET UP?
        JSR     ERRFCBOPENQ
        BCS       DSKDDISMOUNTOKRTS       B/ NO, LEAVE ERR FCB ALONE
        ;CLR     FCB:REFCOUNT,X     RELEASE OUR HOLD ON ERRORMSGS.SYS FILE
        CLR      FCB:REFCOUNT,X
        ;STD    ERRFCBPOINTER     AND FORGET THE FCB
        STAB      ERRFCBPOINTER+1
        STAA      ERRFCBPOINTER
DSKDDISMOUNTOKRTS
        OKRTS

ERRFILEISOPEN   ; SOMETHING OTHER THAN A SYSTEM FILE IS OPEN!
        ;JSR    ERRET
        JSR     ERRET
        FDB      ERR:FILEISOPEN
*                       NOTE: DELETED FILES ARE IMPORTANT...
*                       BECAUSE THEY STILL OWN VALUABLE DISK SPACE
*                       THAT HAS NOT YET BEEN DE-ALLOCATED!
        PAGE
*       MARKINVALID -- MARK DISK SECTORS FROM DISK "DCBPOINTER" AS INVALID
*
MARKINVALID
        ;LDX    LASTSECTORREADQ+RDSI:FLINK POINTER TO BASE OF LRU QUEUE
        LDX     LASTSECTORREADQ+RDSI:FLINK
MARKINVALIDL      ; MARK THIS DISK SECTOR AS INVALID IF FROM DISK "DCBPOINTER"
        ;LDD    RDSI:DISKINFO,X IS SECTOR FROM DISK WE'RE MARKING INVALID?
        LDAB      (RDSI:DISKINFO)+1,X
        LDAA      RDSI:DISKINFO,X
        ;CMPD    DCBPOINTER        ...?
        CMPA      DCBPOINTER
        BNE      MACRO:0016
        CMPB      DCBPOINTER+1
MACRO:0016
        BNE      MARKINVALID1      B/ NO, LEAVE SECTOR BUFFER ALONE
        ;CLR     RDSI:MODIFIED,X MARK SECTOR AS INVALID.
        CLR      RDSI:MODIFIED,X
        ;CLR     RDSI:STATE,X     ASSERT: MODIFIED=STATE=0, BUT I'M PARANOID ANYWAY!
        CLR      RDSI:STATE,X
        ;CLR     RDSI:DISKINFO,X MARK RDSI AS "INITRDSIS" DID...
        CLR      RDSI:DISKINFO,X
        ;CLR     RDSI:DISKINFO+1,X       SO THEY POINT TO DUMMY DISKINFO TABLE
        CLR      RDSI:DISKINFO+1,X
        ;LDA     #1      AND MAKE SURE IT DOESN'T SELECT MAGIC "0" SECTOR!
        LDAA      #1
        STAA      RDSI:LSN,X      (I.E., RDSI:LSN,...+1,...+2 <> 0)
*       THIS IS IN CASE MAP ALGORITHM GETS CHANGED...
*       WHICH INVALIDATES THE LOGICAL TO PHYSICAL MAPPING!
        STX     RDSIPOINTER     SAVE POINTER FOR NEXT ITERATION
        ;JSR    REMOVERDSI      SO THAT IOCB REFERENCES TO SECTOR DISAPPEAR
        JSR     REMOVERDSI
MARKINVALID1      ; PROCESS NEXT SECTOR ON LIST
        ;LDX    RDSI:FLINK,X    FIND NEXT RDSI
        LDX     RDSI:FLINK,X
        CPX      #LASTSECTORREADQ
        BNE      MARKINVALIDL      B/ NOT END OF LRU QUEUE
        OKRTS           ALL DONE!
        PAGE     DISK FILE DRIVERS -- DIRECTORY MANAGEMENT ROUTINES
*  SEARCHDIR -- SEARCHES DIRECTORY FILE FOR NAME (X)...
*       ON DRIVE SPECIFIED BY DCBPOINTER
*       IF DSKINFO:DIRFCB IS ZERO FOR THIS DRIVE,
*               SEARCHDIR AUTOMATICALLY LOCATES DIRECTORY.SYS, DISKMAP.SYS, AND ERRORMSGS.SYS
*               AND FILLS IN THE FCBS IN THE DISKINFO TABLE FOR THESE FILES
*               (EFFECTIVELY AN AUTOMATIC "MOUNT" DISK COMMAND)
*       OKRTS MEANS "FILE FOUND" (BUT DIR:HCSIC MIGHT BE ZERO!)
*               (X), DIRENTRY POINTS TO DIRECTORY ENTRY
*               DIRENTRYDISP SPECIFIES DISPLACEMENT INTO SECTOR OF DIRECTORY ENTRY
*               SYSIOCB:CURLSN CONTAINS LOGICAL SECTOR NUMBER OF DIRECTORY SECTOR
*               FCBPOINTER SELECTS DIRECTORY.SYS FILE
*               RDSIPOINTER SELECTS DIRECTORY SECTOR POINTED TO BY (X)
*       ERRET ON EXIT WITH (X) = "NOT FOUND" MEANS:
*               FREEDIRLSN CONTAINS LSN OF DIRECTORY SECTOR CONTAINING FREE ENTRY
*                = 0 --> DIRECTORY IS FULL
*               FREEDIRENTRYDISP SPECIFIES DISPLACEMENT INTO SECTOR OF DIRECTORY ENTRY
*               FCBPOINTER SELECTS DIRECTORY.SYS FILE
*       ERRET WITH (X) <> "FILE NOT FOUND" MEANS
*               SOME FATAL PROBLEM OCCURRED
*               NO GAURANTEES ABOUT ANYTHING!
*
*  SEARCHDIRCREATE -- SEARCH DIRECTORY FOR FILENAME(X)
*       AND CREATE EMPTY DIRECTORY SLOT IF FILENAME IS NOT IN DIRECTORY
*       OKRTS MEANS EITHER THE NAME WAS FOUND, OR AN EMPTY SLOT WAS FOUND
*               SYSIOCB:CURLSN CONTAINS LSN OF DIRECTORY SECTOR
*               (X), DIRENTRY CONTAINS POINTER TO DIRECTORY ENTRY (SECTOR IS READ IN)
*               RDSIPOINTER SELECTS DIRECTORY SECTOR POINTED TO BY (X)
*               DIRENTRYDISP CONTAINS DISPLACEMENT TO DIRECTORY ENTRY FROM SECTORBASE
*               IF DIR:HCSIC(DIRENTRY) <> 0, THEN AN OLD FILE EXISTS TO BE REPLACED
*               IF =0, THIS DIRECTORY ENTRY IS FREE IF NO CURRENTLY OPEN FCB OWNS IT
*               IF DIRECTORY WAS FULL, AND NO FREE SLOTS WERE AVAILABLE,
*               THE DIRECTORY WAS AUTOMATICALLY EXPANDED BY MINALLOC CLUSTERS
*               FCBPOINTER SELECTS DIRECTORY.SYS FILE
*       ERRET MEANS DIRECTORY IS FULL, AND CANNOT BE EXPANDED
*               SO THERE IS NO ROOM FOR NEW FILE
*               FCBPOINTER SELECTS DIRECTORY.SYS FILE
        PAGE
*  NOTES:
*  SEARCHDIR ALWAYS COMPARES DESIRED FILENAME WITH DIRENTRY
*  IF MATCH, THEN SEARCHDIR CHECKS VALIDITY OF DIRENTRY (DIR:HCSIC<>0)
*  IF AN "EMPTY" DIRENTRY SLOT IS MATCHED, AND SLOT IS OWNED BY AN OPEN FCB,
*  THEN SEARCHDIR TREATS SLOT AS IF A REAL FILE EXISTED THERE
*  FILES WHICH ARE BRAND NEW (AREN'T REPLACEMENTS) BUT HAVE NOT YET
*  BEEN CLOSED MUST HAVE THEIR NAME PLACED IN A DIRENTRY WITH DIR:HCSIC=0
*  SO IF SYSTEM CRASHES, DIRENTRY IS AUTOMATICALLY FREE
        PAGE
SEARCHDIR ; SEARCH DIRECTORY FOR FILENAME (X)
        BSR      SAVEUSERIOCB       SO WE CAN SET UP OUR OWN AS "IOCBPOINTER"
        BSR      SEARCHDIRE        GO SEARCH DIRECTORY USING SYSIOCB
        BCS       SEARCHDIRERRED    B/ CAN'T FIND IT
*
*       RESTOREUSERIOCB -- RESTORES IOCBPOINTER TO USERIOCBPOINTER
*               RESTORES FCBPOINTER TO IOCB:FCB(USERIOCBPOINTER)
*
RESTOREUSERIOCB   EQU     *
        ;LDX    USERIOCBPOINTER   RESTORE VALUES TO THOSE OF INITIAL CALL TO DRIVER
        LDX     USERIOCBPOINTER
        STX     IOCBPOINTER
        ;LDX    IOCB:FCB,X  RESTORE FCB POINTER TO ITS ORIGINAL VALUE, TOO
        LDX     IOCB:FCB,X
        STX     FCBPOINTER
        ;LDX    #0      MARK SYSTEM IOCB AS "CLOSED"
        LDX     #0
        STX     SYSIOCB+IOCB:DRIVER
        ;LDX    DIRENTRY        TO BE NICE
        LDX     DIRENTRY
        OKRTS           SAY "WE FOUND AN ENTRY.."

SEARCHDIRERRED    ; DIDN'T FIND THE FILE NAME IN THE DIRECTORY
        BSR      RESTOREUSERIOCB   SWITCH BACK TO ORIGINAL IOCBPOINTER
        ;JMP    ERRORED GRAB THE ERROR CODE AND EXIT AGAIN
        JMP     ERRORED
*
*       SAVEUSERIOCB -- COPIES IOCBPOINTER INTO USERIOCBPOINTER
*               PRESERVES (X) ON ENTRY AS "SEARCHNAMEP"
*
SAVEUSERIOCB       EQU     *
        STX     SEARCHNAMEP        SAVE POINTER TO DESIRED NAME
        ;LDX    IOCBPOINTER       SAVE USER'S DESIRED IOCB
        LDX     IOCBPOINTER
        STX     USERIOCBPOINTER   SO WE CAN SET UP SYSIOCB AS "THE" IOCB
        ;LDX    SEARCHNAMEP        TO BE COMPATIBLE WITH THE SPECIAL ENTRY POINT
        LDX     SEARCHNAMEP
        RTS
        PAGE
*
*       SEARCHDIRE -- ENTRY POINT TO SEARCH DIRECTORY...
*               ASSUMING IOCBPOINTER IS FREE
*
SEARCHDIRE        EQU     *
        STX     SEARCHNAMEP        SAVE POINTER TO NAME TO SEARCH FOR
*       NOW SET UP TO USE SYSIOCB FOR DIRECTORY SEARCH
*               MAKES IOCBPOINTER POINT TO SYSIOCB
*               MAKES SYSIOCB+IOCB:FCB, FCBPOINTER POINT TO...
*               FCB FOR DIRECTORY.SYS IN DISKINFO TABLES
*
        ;LDX    DCBPOINTER        NOW SET UP SYSIOCB
        LDX     DCBPOINTER
        ;LDX    DSKINFO:DIRFCB,X  GET FCB ADDRESS
        LDX     DSKINFO:DIRFCB,X
        STX     FCBPOINTER
        ;JSR    DSKFOPENSYSIOCB   SET UP SYSIOCB SO WE CAN SEARCH THE DIRECTORY
        JSR     DSKFOPENSYSIOCB
        LDAA      FCBPOINTER        GET FCB ADDRESS FOR DIRECTORY
        BEQ      SEARCHDIRMOUNT    B/ MUST MOUNT THE DISK
        ;JMP    SEARCHDIR1        B/ DISK HAS ALREADY BEEN MOUNTED
        JMP     SEARCHDIR1

ERRBOOTCKSUMFAIL   EQU     *
        ;JSR    ERRET
        JSR     ERRET
        FDB      ERR:BOOTCKSUMFAIL

ERRNBPCTOOBIG      EQU     *
        ;JSR    ERRET
        JSR     ERRET
        FDB      ERR:NBPCTOOBIG

ERRWRONGFILESYSTEM      ; FILE STRUCTURE FORMAT IS WRONG VERSION
        ;JSR    ERRET
        JSR     ERRET
        FDB      ERR:WRONGFILESYSTEM
        PAGE
**** MUST MOUNT DISK, SET UP DIRECTORY.SYS, DISKMAP.SYS, AND ERRORMSGS.SYS FCBS
**** FIRST, SET UP DSKINFO INFORMATION
SEARCHDIRMOUNT    EQU     *
        ;JSR    DSKDDISMOUNT    DUMP BUFFERS, WAIT FOR READAHEADS TO QUIT;
        JSR     DSKDDISMOUNT
**** SHOULD THIS CALL DUMP BUFFERS INSTEAD???
*                               MARK THE MAP ALGORITHM AS INVALID
        ;LDX    #SYSIOCB  GO READ BOOT SECTOR FOR DISK
        LDX     #SYSIOCB
        ;CLR     IOCB:CURLSN,X      = SECTOR ZERO
        CLR      IOCB:CURLSN,X
        ;CLR     IOCB:CURLSN+1,X
        CLR      IOCB:CURLSN+1,X
        ;CLR     IOCB:CURLSN+2,X
        CLR      IOCB:CURLSN+2,X
        ;JSR    FETCHSECTOR
        JSR     FETCHSECTOR
        ;LDX    RDSI:SECTORBASE,X  GET ADDRESS OF BOOT SECTOR
        LDX     RDSI:SECTORBASE,X
        STX     FROMPOINTER     SAVE BOOT SECTOR ADDRESS
        LDAA      BOOT:FILESYSTEMVERSION,X PROPER FILE SYSTEM VERSION ?
        SUBA      #FILESYSTEMVERSION      ...?
        BNE      ERRWRONGFILESYSTEM      B/ NOPE, WE CAN'T READ THIS DISKETTE!
        LDAB      #BOOT:DISKINFOLEN        DO CHECKSUM ON INFO STORED IN BOOT SECTOR
*       CLRA              ZERO THE CHECKSUM
SEARCHDI1 ; ADD BYTE TO CHECKSUM
        ADDA      BOOT:DISKINFO,X
        INX             BUMP CHECKSUM SCAN POINTER
        DECB              # BYTES LEFT TO CHECKSUM
        BNE      SEARCHDI1 B/ MORE TO CHECKSUM
        INCA              CHECKSUM OK (=-1)?
        NOP	;ZZZ BNE      ERRBOOTCKSUMFAIL   B/ BAD BOOT SECTOR, I QUIT!
        NOP
        IF      M6800!M6801
        ;LDD    FROMPOINTER     NOW COPY BOOTSECTOR STUFF TO DISKINFO TABLE
        LDAB      FROMPOINTER+1
        LDAA      FROMPOINTER
        ;ADDD    #BOOT:NSPC        = SOURCE OF BOOTSECTOR STUFF
        ADDB      #(BOOT:NSPC)&$FF
        ADCA       #(BOOT:NSPC)/256
        ;TDX
        STAA      TEMPA
        STAB      TEMPB
        LDX     TEMPX
        ;LDD    DCBPOINTER        FIGURE OUT WHERE TO PUT THE STUFF
        LDAB      DCBPOINTER+1
        LDAA      DCBPOINTER
        ;ADDD    #DSKINFO:NSPC
        ADDB      #(DSKINFO:NSPC)&$FF
        ADCA       #(DSKINFO:NSPC)/256
        ;STD    TOPOINTER       = TARGET
        STAB      TOPOINTER+1
        STAA      TOPOINTER
        ELSE    (M6809)
        ;LDX    FROMPOINTER     NOW COPY BOOTSECTOR STUFF TO DISKINFO TABLE
        LDX     FROMPOINTER
        ;LEAX    BOOT:NSPC,X       = WHERE TO GET BOOTSECTOR STUFF
        IF      BOOT:NSPC<0
        RPT     -BOOT:NSPC
        DEX
        ELSE
        RPT     BOOT:NSPC
        INX
        FIN
        LDY     DCBPOINTER        DECIDE WHERE TO PUT IT
        LEAY     BOOT:NSPC,Y
        FIN
        ;LDD    #BOOT:PARAMSIZE    = # BYTES TO COPY
        LDAB      #(BOOT:PARAMSIZE)&$FF
        LDAA      #(BOOT:PARAMSIZE)/256
        ;JSR    CODE+SDOS:BLOCKMOVE        GO MOVE IT!
        JSR     CODE+SDOS:BLOCKMOVE
        ;LDX    DCBPOINTER        COMPUTE NUMBER OF BYTES PER CLUSTER
        LDX     DCBPOINTER
        LDAA      DSKINFO:LOG2NBPS,X       = DSKINFO:NSPC*2^DSKINFO:LOG2NBPS
        STAA      TEMPA    (NUMBER OF TIMES TO LEFT SHIFT)
        CLRA              DO MULTIPLY BY SHIFTING
        LDAB      DSKINFO:NSPC,X   *** NOTE: DSKINFO:NBPC <= 65535 !! ****
SEARCHDI3 ; SHIFT LEFT ONE PLACE
        ;ASLD            * 2^1
        ASLB
        ROLA
        BCS       ERRNBPCTOOBIG      B/ DISKINFONBPC >= 65536!
        ;DEC     TEMPA    # PLACES LEFT TO LEFT SHIFT
        DEC      TEMPA
        BNE      SEARCHDI3 B/ SHIFT LEFT SOME MORE
        ;STD    DSKINFO:NBPC,X    STORE NUMBER OF BYTES PER CLUSTER
        STAB      (DSKINFO:NBPC)+1,X
        STAA      DSKINFO:NBPC,X
        PAGE
*
*       COMPUTE NLCN:=INT(NLSN/NSPC)
*
        LDAA      #17     # QUOTIENT BITS TO GENERATE
        STAA      TEMPA    (FIRST Q BIT MUST ALWAYS BE 0!)
        ;LDB     DSKINFO:NLSN+2,X        SET (A,B,TEMP.DIVIDEND):=NLSN
        LDAB      DSKINFO:NLSN+2,X
        ;STB     TEMPB
        STAB      TEMPB
        ;LDD    DSKINFO:NLSN,X
        LDAB      (DSKINFO:NLSN)+1,X
        LDAA      DSKINFO:NLSN,X
SEARCHDI5L        ; GENERATE COMPLEMENTED QUOTIENT BIT
        SUBA      DSKINFO:NSPC,X
        BCC        SEARCHDI5A B/ WENT IN, Q BIT = 1!
        ADDA      DSKINFO:NSPC,X   DIDN'T GO IN, RESTORE DIVIDEND (ASSERT: SETS CARRY)
SEARCHDI5A EQU     *
        ROL     DSKINFO:NLCN+1,X SHIFT COMPLEMENTED QUOTIENT BIT INTO QUOTIENT
        ROL     DSKINFO:NLCN,X
        ASL      TEMPB    SHIFT DIVIDEND LEFT ONE BIT
        ;ROLD
        ROLB
        ROLA
        ;DEC     TEMPA    DOWN COUNT # Q BITS TO GENERATE
        DEC      TEMPA
        BNE      SEARCHDI5L        B/ GEN ANOTHER Q BIT
        ;COM     DSKINFO:NLCN,X   COMPLEMENT QUOTIENT TO GET TRUE VALUE
        COM      DSKINFO:NLCN,X
        ;COM     DSKINFO:NLCN+1,X
        COM      DSKINFO:NLCN+1,X
        PAGE
*
*       NOW GO LOOK UP CRITICAL SYSTEM FILES ***
*
*
        ;LDD    DSKINFO:NLCN,X   COMPUTE LCN OF MIDDLE OF DISK
        LDAB      (DSKINFO:NLCN)+1,X
        LDAA      DSKINFO:NLCN,X
        ;LSRD           = INT(NLCN/2)
        LSRA
        RORB
        ;STD    DSKINFO:RANDMAP,X INITZ RANDMAP TO MIDDLE OF DISK
        STAB      (DSKINFO:RANDMAP)+1,X
        STAA      DSKINFO:RANDMAP,X
        ;LDX    RDSIPOINTER     USE BOOT:DIRLSN TO FIND DIRECTORY.SYS ENTRY
        LDX     RDSIPOINTER
        ;LDX    RDSI:SECTORBASE,X
        LDX     RDSI:SECTORBASE,X
        LDAA      BOOT:DIRLSN,X    FETCH BOOT:DIRLSN FROM BOOT SECTOR...
        STAA      SYSIOCB+IOCB:CURLSN  AND STUFF INTO SYSTEM IOCB
        ;LDX    BOOT:DIRLSN+1,X
        LDX     BOOT:DIRLSN+1,X
        STX     SYSIOCB+IOCB:CURLSN+1
        ;LDX    #SYSIOCB
        LDX     #SYSIOCB
        ;JSR    FETCHSECTOR       READ IN DIRECTORY DATA SECTOR
        JSR     FETCHSECTOR
*                       GET ADDRESS OF DIRECTORY.SYS ENTRY...
        ;LDX    RDSI:SECTORBASE,X  WHICH (RULE!!) MUST BE 1ST ENTRY BOOT:DIRLSN
        LDX     RDSI:SECTORBASE,X
        STX     DIRENTRY        SET UP SO WE CAN FIND A FREE FCB
        LDAA      DIR:HCSIC,X       IS DIRECTORY.SYS ENTRY VALID?
        ;LBEQ    ERRDIRECTORYDAMAGED        B/ NO
        BNE      MACRO:0017
        JMP     ERRDIRECTORYDAMAGED
MACRO:0017
        ;LDX    #0      SET UP DIRENTRYDISP CORRECTLY
        LDX     #0
        STX     DIRENTRYDISP
        ;LDX    #DIRECTORYNAME    VERIFY VALIDITY OF DIRECTORY.SYS ENTRY
        LDX     #DIRECTORYNAME
        ;JSR    COMPARENAMES
        JSR     COMPARENAMES
        ;LBNE    ERRDIRECTORYDAMAGED        B/ DIRECTORY.SYS NAME IS TRASH
        BEQ      MACRO:0018
        JMP     ERRDIRECTORYDAMAGED
MACRO:0018
        ;JSR    FINDFREEFCB       SINCE THIS DISK IS BEING MOUNTED, CAN'T BE ANY OPEN FCBS TO IT!
        JSR     FINDFREEFCB
        ;LDX    DCBPOINTER        SET UP FCB FOR DIRECTORY.SYS
        LDX     DCBPOINTER
        ;STD    DSKINFO:DIRFCB,X  SO THAT SUBSEQUENT CALLS TO "SEARCHDIR" WILL WORK
        STAB      (DSKINFO:DIRFCB)+1,X
        STAA      DSKINFO:DIRFCB,X
        ;LDX    SEARCHNAMEP        SAVE POINTER TO NAME THAT WE REALLY WANTED
        LDX     SEARCHNAMEP
        STX     SEARCHSAVEP        SO WE CAN SEARCH FOR DISKMAP.SYS, ERRORMSGS.SYS FILE
        ;LDX    #DISKMAPNAME      NOW GO FIND THE DISKMAP.SYS FILE
        LDX     #DISKMAPNAME
        ;JSR    SEARCHDIRE        (IOCBPOINTER IS FREE)
        JSR     SEARCHDIRE
        BCS       SEARCHDI3A B/ NO DISKMAP.SYS, WON'T BE ABLE TO MAKE NEW FILES
        ;JSR    FINDFREEFCB       FIND FCB FOR MAP FILE
        JSR     FINDFREEFCB
        ;LDX    DCBPOINTER        SAVE FCB ADDRESS OF MAP FILE
        LDX     DCBPOINTER
        ;STD    DSKINFO:MAPFCB,X   IN CASE SOMEONE INSISTS IN OPENING MAP
        STAB      (DSKINFO:MAPFCB)+1,X
        STAA      DSKINFO:MAPFCB,X
        ;CLR     SYSIOCB+IOCB:HRSN   COMPUTE LSN OF 1ST SECTOR IN MAP CLUSTER
        CLR      SYSIOCB+IOCB:HRSN
        ;JSR    GENHLSNPLUSHRSN SET UP TO READ 1ST SECTOR OF MAP HEADER CLUSTER
        JSR     GENHLSNPLUSHRSN
        ;JSR    FETCHSECTOR       GO READ SECTOR ZERO OF MAP HEADER
        JSR     FETCHSECTOR
        ;LDX    RDSI:SECTORBASE,X
        LDX     RDSI:SECTORBASE,X
        ;LDD    HEADER:LCN+LCN:SIZE,X      =2ND LCN IN HEADER
        LDAB      (HEADER:LCN+LCN:SIZE)+1,X
        LDAA      HEADER:LCN+LCN:SIZE,X
        ;CLR     SYSIOCB+IOCB:DRSN   SO CONVERSION WILL NOT BE AFFECTED
        CLR      SYSIOCB+IOCB:DRSN
        ;JSR    CONVERTLCNTOLSN   CONVERT LCN OF CLUSTER INTO LSN
        JSR     CONVERTLCNTOLSN
        LDAA      SECTORDB:LSN,X    COPY LSN TO (TOS), (A,B)
        PSHA     
        ;LDD    SECTORDB:LSN+1,X
        LDAB      (SECTORDB:LSN+1)+1,X
        LDAA      SECTORDB:LSN+1,X
        ;LDX    DCBPOINTER        NOW MOVE MAP CLUSTER LSN ...
        LDX     DCBPOINTER
        ;STD    DSKINFO:MAPLSN+1,X       INTO DISKINFO TABLE FOR EASY ACCESS
        STAB      (DSKINFO:MAPLSN+1)+1,X
        STAA      DSKINFO:MAPLSN+1,X
        PULA
        STAA      DSKINFO:MAPLSN,X
        PAGE
SEARCHDI3A EQU     *
        ;LDX    DEFAULTDISKDCB     ARE WE MOUNTING THE DEFAULTDISK ?
        LDX     DEFAULTDISKDCB
        CPX      DCBPOINTER        (I.E., DO WE NEED TO SET UP ERROR MESSAGE FCB ?)
        BNE      SEARCHDI4 B/ NO, WE'D NEVER USE IT!
        ;LDX    ERRFCBPOINTER     IS ERRORMESSAGE FILE ALREADY SET UP?
        LDX     ERRFCBPOINTER
        BNE      SEARCHDI4 B/ YES, LEAVE IT ALONE
        ;LDX    #ERRMSGSNAME     GO LOOK UP ERRORMSGS.SYS FILE
        LDX     #ERRMSGSNAME
*       IF FILE IS ALREADY SET UP ON SAME OTHER DISK, IT SHOULD BE RELEASED AND MOVED HERE!
        ;JSR    SEARCHDIRE        (IOCBPOINTER IS FREE)
        JSR     SEARCHDIRE
        BCS       SEARCHDI4 B/ NOT IN DIRECTORY, TOO BAD
        ;JSR    FINDFREEFCB       FOUND ERROR MESSAGES FILE
        JSR     FINDFREEFCB
        ;STD    ERRFCBPOINTER     SAVE ERRORMSGS.SYS FCB ADDRESS SO WE CAN DO A QUICK OPEN LATER
        STAB      ERRFCBPOINTER+1
        STAA      ERRFCBPOINTER
SEARCHDI4 EQU     *
        ;LDX    SEARCHSAVEP        GET POINTER TO NAME WE ORIGINALLY WANTED
        LDX     SEARCHSAVEP
        ;JMP    SEARCHDIRE        GO SEARCH THE DIRECTORY AS WE ORIGINALLY INTENDED!
        JMP     SEARCHDIRE

SEARCHDIRF        ; FOUND FILE NAME MATCH
        BSR      COMPUTEDIRENTRYDISPLACEMENT
        ;LDX    DIRENTRY        IS THIS DIRECTORY ENTRY ACTUALLY IN USE ?
        LDX     DIRENTRY
        LDAA      DIR:HCSIC,X       ...?
        BNE      SEARCHDIROKRTS    B/ YES, WE FOUND DESIRED DIRECTORY ENTRY
        ;JSR    SEARCHFCBINIT       START UP THE SEARCH
        JSR     SEARCHFCBINIT
        ;JSR    SEARCHFCBS  DOES SOME FCB OWN THIS SLOT ?
        JSR     SEARCHFCBS
        BCS       SEARCHDIRL1       ITS JUST AN EMPTY SLOT!!!
        ;LDX    DCBPOINTER        SET UP FCB POINTER TO SELECT DIRECTORY.SYS AGAIN
        LDX     DCBPOINTER
        ;LDX    DSKINFO:DIRFCB,X  SINCE SEARCHFCBS BOMBED IT
        LDX     DSKINFO:DIRFCB,X
        STX     FCBPOINTER
SEARCHDIROKRTS    EQU     *
        ;LDX    DIRENTRY        GRAB POINTER TO DIRECTORY ENTRY AGAIN
        LDX     DIRENTRY
        OKRTS           WE FOUND THE FILE!
*
*       COMPUTEDIRENTRYDISPLACEMENT -- COMPUTES DIRENTRYDISP
*
COMPUTEDIRENTRYDISPLACEMENT
        ;LDD    DIRENTRY        COMPUTE DIRECTORY ENTRY DISPLACEMENT
        LDAB      DIRENTRY+1
        LDAA      DIRENTRY
        ;LDX    SYSIOCB+IOCB:DRDSI  ASSERT: IOCB:DRDSI <> 0
        LDX     SYSIOCB+IOCB:DRDSI
        STX     RDSIPOINTER     CHEAT, CHEAT! MAKE THIS MOST RECENTLY READ SECTOR
        ;SUBD    RDSI:SECTORBASE,X
        SUBB      (RDSI:SECTORBASE)+1,X
        SBCA       RDSI:SECTORBASE,X
        ;STD    DIRENTRYDISP
        STAB      DIRENTRYDISP+1
        STAA      DIRENTRYDISP
        RTS

ERRDIRECTORYDAMAGED
        ;JSR    ERRET
        JSR     ERRET
        FDB      ERR:DIRECTORYDAMAGED
        PAGE
SEARCHDIR1        ; DISKINFO IS ALL SET, LET'S GO!
        ;LDX    SEARCHNAMEP        GET POINTER TO NAME
        LDX     SEARCHNAMEP
        ;JSR    HASHNAME  DO INITIAL HASH
        JSR     HASHNAME
        ;CLR     WRITEFLAG        TELL LOCATECURBYTE THAT WE'RE READING
        CLR      WRITEFLAG
        ;LDX    DCBPOINTER        GET DIRECTORY SECTOR SIZE
        LDX     DCBPOINTER
        ;LDD    DSKINFO:NBPS,X
        LDAB      (DSKINFO:NBPS)+1,X
        LDAA      DSKINFO:NBPS,X
        ;JSR    LOCATECURBYTE       GO FIND DIRECTORY ENTRY
        JSR     LOCATECURBYTE
        LDAA      SYSIOCB+IOCB:CURLSN  REMEMBER STARTING LSN OF DIRECTORY SEARCH
        STAA      SEARCHSTARTLSN     SO WE KNOW WHEN TO STOP
        ;LDX    SYSIOCB+IOCB:CURLSN+1
        LDX     SYSIOCB+IOCB:CURLSN+1
        STX     SEARCHSTARTLSN+1
        ;CLR     FREEDIRLSN      MARK 'NO FREE DIRECTORY ENTRY FOUND'
        CLR      FREEDIRLSN
        ;CLR     FREEDIRLSN+1
        CLR      FREEDIRLSN+1
        ;CLR     FREEDIRLSN+2
        CLR      FREEDIRLSN+2
        PAGE
SEARCHDIRS        ; SEARCH DIRECTORY SECTOR FOR NAME
        ;LDX    SYSIOCB+IOCB:DRDSI  GET ADDRESS OF DIRECTORY SECTOR
        LDX     SYSIOCB+IOCB:DRDSI
        ;LDX    RDSI:SECTORBASE,X  NOTE: THIS DEPENDS ON AT LEAST 2 RDSI'S AVAILABLE!
        LDX     RDSI:SECTORBASE,X
        STX     DIRENTRY        AND USE AS SEARCH STARTING POINT
        ;LDX    DCBPOINTER        COMPUTE END OF DIRECTORY SECTOR
        LDX     DCBPOINTER
        ;LDD    DSKINFO:NBPS,X   =SECTORBASE + DSKINFO:NBPS
        LDAB      (DSKINFO:NBPS)+1,X
        LDAA      DSKINFO:NBPS,X
        ;ADDD    DIRENTRY
        ADDB      DIRENTRY+1
        ADCA       DIRENTRY
        ;STD    DIRSECTOREND     REMEMBER END OF DIRSECTORY
        STAB      DIRSECTOREND+1
        STAA      DIRSECTOREND
SEARCHDIRL        EQU     *
        ;LDX    SEARCHNAMEP        GET ADDRESS OF NAME TO FIND
        LDX     SEARCHNAMEP
        ;JSR    COMPARENAMES       COMPARE AGAINST DIRECTORY ENTRY
        JSR     COMPARENAMES
        ;LBEQ    SEARCHDIRF        B/ WE FOUND IT!
        BNE      MACRO:0019
        JMP     SEARCHDIRF
MACRO:0019
        ;LDX    DIRENTRY        IS THIS DIRECTORY ENTRY VALID?
        LDX     DIRENTRY
        LDAA      DIR:HCSIC,X
        BNE      SEARCHDIRN        B/ YES, GO FIND NEXT ENTRY
SEARCHDIRL1       EQU     *
        LDAA      FREEDIRLSN      NO, FOUND EMPTY DIRECTORY ENTRY
        ORAA      FREEDIRLSN+1    HAVE WE RECORDED EXISTENCE...
        ORAA      FREEDIRLSN+2    OF FREE DIRECTORY ENTRY YET?
        BNE      SEARCHDIR2        B/ YES, DON'T RECORD ANOTHER
        BSR      COMPUTEDIRENTRYDISPLACEMENT
        ;JSR    SEARCHFCBINIT       SET UP TO SEARCH THE FCBS
        JSR     SEARCHFCBINIT
        ;JSR    SEARCHFCBS  IS THIS ENTRY IN USE?
        JSR     SEARCHFCBS
        BCC        SEARCHDIR2        B/ YES, FIND NEXT DIRECTORY ENTRY
        LDAA      SYSIOCB+IOCB:CURLSN  SAVE LSN OF CURRENT DIRECTORY SECTOR
        STAA      FREEDIRLSN      AS LSN OF FREE ENTRY
        ;LDX    SYSIOCB+IOCB:CURLSN+1
        LDX     SYSIOCB+IOCB:CURLSN+1
        STX     FREEDIRLSN+1
        ;LDD    DIRENTRYDISP    
        LDAB      DIRENTRYDISP+1
        LDAA      DIRENTRYDISP
        ;STD    FREEDIRENTRYDISP        AND SAVE IN CASE WE DON'T FIND THE NAME IN THE DIRECTORY
        STAB      FREEDIRENTRYDISP+1
        STAA      FREEDIRENTRYDISP
        PAGE
SEARCHDIR2        EQU     *
        ;LDX    DCBPOINTER        MAKE FCBPOINTER SELECT DIRECTORY.SYS FILE AGAIN
        LDX     DCBPOINTER
        ;LDX    DSKINFO:DIRFCB,X
        LDX     DSKINFO:DIRFCB,X
        STX     FCBPOINTER        SINCE SEARCHFCBS DESTROYED IT!
SEARCHDIRN        EQU     *
        ;LDD    DIRENTRY        NOT HERE, FIND NEXT DIRECTORY ENTRY
        LDAB      DIRENTRY+1
        LDAA      DIRENTRY
        ;ADDD    #DIR:ENTRYSIZE  =THIS ENTRY + DIR:ENTRYSIZE
        ADDB      #(DIR:ENTRYSIZE)&$FF
        ADCA       #(DIR:ENTRYSIZE)/256
        ;STD    DIRENTRY
        STAB      DIRENTRY+1
        STAA      DIRENTRY
        ;LDX    DIRENTRY        HIT END OF DIRECTORY SECTOR?
        LDX     DIRENTRY
        CPX      DIRSECTOREND
        BNE      SEARCHDIRL
        ;JSR    UPDATECURBYTEF     RECORD FILE ADVANCE DELTA
        JSR     UPDATECURBYTEF
        BCC        SEARCHDIRT        B/ NOT EOF, GO LOCATE NEXT SECTOR
        CPX      #ERR:EOFHIT     CHECK: END OF FILE HIT ?
        BNE      SEARCHDIRERRED4   B/ NO, SOME REAL PROBLEM!
        ;CLR     SYSIOCB+IOCB:EOFFLAG RESET "EOF HIT" FLAG
        CLR      SYSIOCB+IOCB:EOFFLAG
        ;LDX    #0      HIT END OF DIRECTORY
        LDX     #0
        STX     SYSIOCB+IOCB:CURBYTE  RESET CURBYTE TO START OF DIRECTORY
        STX     SYSIOCB+IOCB:CURBYTE+2
        ;CLR     SYSIOCB+IOCB:LOCATEDF FORCE RE-LOCATION OF SECTOR
        CLR      SYSIOCB+IOCB:LOCATEDF
SEARCHDIRT        ; TEST FOR ENTIRE DIRECTORY SEARCHED
        ;LDX    DCBPOINTER        GET DIRECTORY SECTOR SIZE
        LDX     DCBPOINTER
        ;LDD    DSKINFO:NBPS,X
        LDAB      (DSKINFO:NBPS)+1,X
        LDAA      DSKINFO:NBPS,X
        ;JSR    LOCATECURBYTE       AND GO LOCATE THE DESIRED SECTOR
        JSR     LOCATECURBYTE
        ;LDX    SYSIOCB+IOCB:CURLSN+1        I.E., IS CURLSN=START-OF-SEARCH LSN?
        LDX     SYSIOCB+IOCB:CURLSN+1
        CPX      SEARCHSTARTLSN+1   (TEST LS 16 BITS FIRST...
        BNE      SEARCHDIRSJ       BECAUSE OF HIGHEST PROBABILITY
        LDAA      SYSIOCB+IOCB:CURLSN  OF MISMATCH)
        ;CMPA     SEARCHSTARTLSN
        CMPA      SEARCHSTARTLSN
        BEQ      SEARCHDIRNF       B/ FILE NOT FOUND
SEARCHDIRSJ       EQU     *
        ;JMP    SEARCHDIRS        GO SEARCH ANOTHER DIRECTORY SECTOR
        JMP     SEARCHDIRS

SEARCHDIRERRED4   EQU     *
        RTS
        PAGE
SEARCHDIRNF       ; FILE NOT FOUND IN DIRECTORY
        ;JSR    ERRET   CAUSE AN ERROR OF APPROPRIATE TYPE
        JSR     ERRET
        FDB      ERR:FILENOTFOUND

DIRECTORYNAME     FCC       "DIRECTORY.SYS"
        RPT     DIR:NAMESIZE-(*-DIRECTORYNAME)
        FCC       " "

DISKMAPNAME       FCC       "DISKMAP.SYS"
        RPT     DIR:NAMESIZE-(*-DISKMAPNAME)
        FCC       " "

ERRMSGSNAME      FCC       "ERRORMSGS.SYS"
        RPT     DIR:NAMESIZE-(*-ERRMSGSNAME)
        FCC       " "
        PAGE
SEARCHDIRCREATE     ; SEARCH DIRECTORY AND EXPAND IF NECESSARY
        ;JSR    SAVEUSERIOCB       SO WE CAN SET UP SYSIOCB AS IOCBPOINTER
        JSR     SAVEUSERIOCB
SEARCHDIRCREAT1     EQU     *
        ;JSR    SEARCHDIRE        GO LOOK FOR FILE FIRST
        JSR     SEARCHDIRE
        BCC        SEARCHDIRCOKRTS    B/ FOUND IT, GET OUT!
        CPX      #ERR:FILENOTFOUND       A TRUE 'FILE NOT FOUND' ERROR ?
        BNE      SEARCHDIRCERRED    B/ NOPE, I GIVE UP!
        LDAA      FREEDIRLSN      NOT FOUND, DID WE FIND A FREE SLOT?
        ORAA      FREEDIRLSN+1
        ORAA      FREEDIRLSN+2
        BNE      SEARCHDIRCNEW      B/ YES, TAKE OK EXIT
        ;CLR     SYSIOCB+IOCB:EOFFLAG FORCE ALLOCCLUSTERS TO ZERO
        CLR      SYSIOCB+IOCB:EOFFLAG
        ;LDX    SYSIOCB+IOCB:FCB      SET UP IOCB:RDCN...
        LDX     SYSIOCB+IOCB:FCB
        ;LDX    FCB:NCLUSTERS,X    TO ALLOCATE ANOTHER CLUSTER
        LDX     FCB:NCLUSTERS,X
        STX     SYSIOCB+IOCB:RDCN
        ;LDD    #1      (A,B):= # CLUSTERS TO ALLOCATE
        LDAB      #(1)&$FF
        LDAA      #(1)/256
        ;JSR    ALLOCATECLUSTERS    GO ALLOCATE (AND ZERO!) ANOTHER CLUSTER
        JSR     ALLOCATECLUSTERS
        BCS       SEARCHDIRCERRED    B/ PROBABLY NO DISK SPACE
        ;LDX    DCBPOINTER        ADD 1 CLUSTER SIZE TO FILE LENGTH
        LDX     DCBPOINTER
        ;LDD    DSKINFO:NBPC,X
        LDAB      (DSKINFO:NBPC)+1,X
        LDAA      DSKINFO:NBPC,X
        ;LDX    SYSIOCB+IOCB:FCB
        LDX     SYSIOCB+IOCB:FCB
        ;ADDD    FCB:FILESIZE+2,X
        ADDB      (FCB:FILESIZE+2)+1,X
        ADCA       FCB:FILESIZE+2,X
        ;STD    FCB:FILESIZE+2,X
        STAB      (FCB:FILESIZE+2)+1,X
        STAA      FCB:FILESIZE+2,X
        BCC        SEARCHDIRCREAT2     B/ NO CARRY TO PROPOGATE
        ;INC     FCB:FILESIZE+1,X
        INC      FCB:FILESIZE+1,X
        BNE      SEARCHDIRCREAT2
        ;INC     FCB:FILESIZE,X
        INC      FCB:FILESIZE,X
SEARCHDIRCREAT2     EQU     *
        ;LDX    SEARCHNAMEP        GET POINTER TO DESIRED FILE NAME
        LDX     SEARCHNAMEP
        BRA       SEARCHDIRCREAT1     AND START OVER AGAIN
        PAGE
SEARCHDIRCNEW      ; MUST BE NEW SLOT
        ;LDX    FREEDIRENTRYDISP        SET UP DIRENTRYDISP
        LDX     FREEDIRENTRYDISP
        STX     DIRENTRYDISP
        ;LDX    FREEDIRLSN+1    MAKE SURE DIRECTORY ENTRY DESIRED...
        LDX     FREEDIRLSN+1
        STX     SYSIOCB+IOCB:CURLSN+1        IS IN MEMORY BY READING IT IN AGAIN!
        ;LDX    #SYSIOCB  COPY FREEDIRLSN TO SYSIOCB...
        LDX     #SYSIOCB
        LDAA      FREEDIRLSN      SO IT LOOKS JUST LIKE SEARCHDIR FOUND IT
        STAA      IOCB:CURLSN,X
        ;JSR    READSECTOR        READ IN THIS DISK SECTOR
        JSR     READSECTOR
        BCS       SEARCHDIRCERRED    B/ DISK I/O PROBLEM
        ;LDD    RDSI:SECTORBASE,X  COMPUTE DIRENTRY POINTER JUST LIKE SEARCHDIR WOULD HAVE
        LDAB      (RDSI:SECTORBASE)+1,X
        LDAA      RDSI:SECTORBASE,X
        ;ADDD    FREEDIRENTRYDISP
        ADDB      FREEDIRENTRYDISP+1
        ADCA       FREEDIRENTRYDISP
        ;STD    DIRENTRY
        STAB      DIRENTRY+1
        STAA      DIRENTRY
        ;JSR    WAITRDSI WAIT FOR SECTOR TO ARRIVE
        JSR     WAITRDSI
        BCS       SEARCHDIRCERRED    B/ DISK I/O ERROR
SEARCHDIRCOKRTS    ; FOUND A DIRECTORY ENTRY FOR NEW FILE
        ;JMP    RESTOREUSERIOCB   AND EXIT
        JMP     RESTOREUSERIOCB

SEARCHDIRCERRED    EQU     *
        ;JMP    SEARCHDIRERRED
        JMP     SEARCHDIRERRED
        PAGE
*
*       LOCATEDIRENTRY -- GET DIRECTORY SECTOR FOR FCB INTO MEMORY
*               SET UP DIRENTRY TO POINT TO DIRECTORY SLOT FOR FCB
*               EXIT PRODUCES EXACTLY THE SAME RESULTS AS OKRTS FROM "SEARCHDIR"
*                       (EXCEPT FCBPOINTER IS NOT DISTURBED!)
*
LOCATEDIRENTRY    EQU     *
        ;LDX    FCBPOINTER        GET POINTER TO DIRECTORY SECTOR DESCRIPTOR
        LDX     FCBPOINTER
        ;JSR    READSECTOR        READ IN DIRLSN
        JSR     READSECTOR
        LDAA      RDSI:LSN,X      SAVE LSN IN SYSIOCB IN CASE WE NEED IT LATER!
        STAA      SYSIOCB+IOCB:CURLSN
        ;LDD    RDSI:LSN+1,X
        LDAB      (RDSI:LSN+1)+1,X
        LDAA      RDSI:LSN+1,X
        ;STD    SYSIOCB+IOCB:CURLSN+1
        STAB      SYSIOCB+IOCB:CURLSN+1+1
        STAA      SYSIOCB+IOCB:CURLSN+1
        ;LDD    RDSI:SECTORBASE,X  ADD SECTOR BASE TO DIR DISPLACEMENT
        LDAB      (RDSI:SECTORBASE)+1,X
        LDAA      RDSI:SECTORBASE,X
        ;LDX    FCBPOINTER        TO GET DIRENTRY ADDRESS
        LDX     FCBPOINTER
        ;ADDD    FCB:DIRDISP,X
        ADDB      (FCB:DIRDISP)+1,X
        ADCA       FCB:DIRDISP,X
        ;STD    DIRENTRY
        STAB      DIRENTRY+1
        STAA      DIRENTRY
        ;LDD    FCB:DIRDISP,X     SET UP DIRECTORY ENTRY DISPLACEMENT
        LDAB      (FCB:DIRDISP)+1,X
        LDAA      FCB:DIRDISP,X
        ;STD    DIRENTRYDISP
        STAB      DIRENTRYDISP+1
        STAA      DIRENTRYDISP
        ;JSR    WAITRDSI WAIT FOR SECTOR TO ARRIVE
        JSR     WAITRDSI
        ;LDX    DIRENTRY
        LDX     DIRENTRY
        OKRTS
        PAGE
*
*       UPDATEDIRFROMFCB -- UPDATE DIRECTORY FROM FCB(FCBPOINTER)
*       UPDATE DIRECTORY ENTRY IF FCB IS MARKED AS "UPDATEDIR" AND NOT "DELETED"
*
UPDATEDIRFROMFCB   EQU     *
        ;LDX    FCBPOINTER        PEEK AT FCB
        LDX     FCBPOINTER
        LDAA      FCB:FLAGS,X        DELETED FILE ?
        BITA      #FCBFLG::DELETED  ...?
        BNE      UPDATEDIROKRTS   B/ YES, DON'T BOTHER UPDATING DIRECTORY
        BITA      #FCBFLG::UPDATEDIR MUST WE UPDATE THE DIRECTORY ?    
        BEQ      UPDATEDIROKRTS   B/ DON'T HAVE TO UPDATE DIRECTORY
LOCUPDATEDIRENTRY ; ENTRY POINT TO LOCATE AND UPDATE DIRECTORY ENTRY
        BSR      LOCATEDIRENTRY    RATS, MUST UPDATE DIRECTORY
UPDATEDIRENTRY   ; ENTRY FOR DIRENTRY ALREADY LOCATED
        STX     TOPOINTER       COPY ALL PERTINANT FCB DATA TO DIRECTORY ENTRY
        ;LDX    FCBPOINTER        FCB DATA IS STORED IN SAME FORMAT...
        LDX     FCBPOINTER
        LDAB      #DIR:FCBDATASIZE    (# FCB BYTES TO COPY TO DIR)
UPDATEDIRL       EQU     *
        LDAA      FCB:HLCN,X AS DIRECTORY ENTRY DATA
        INX             UPDATE "FROM" POINTER
        STX     FROMPOINTER
        ;LDX    TOPOINTER       STORE FCB ENTRY INTO DIRECTORY ENTRY
        LDX     TOPOINTER
        STAA      DIR:HLCN,X       
        INX             UPDATE "TO" POINTER
        STX     TOPOINTER
        ;LDX    FROMPOINTER
        LDX     FROMPOINTER
        DECB              DOWN COUNT # BYTES TO COPY
        BNE      UPDATEDIRL
        ;JSR    MARKMODIFIED     FORCE DIRECTORY SECTOR BACK TO DISK
        JSR     MARKMODIFIED
        ;LDX    FCBPOINTER        RESET THE "UPDATEDIR" FLAG
        LDX     FCBPOINTER
        LDAA      FCB:FLAGS,X
        ANDA      #(\FCBFLG::UPDATEDIR)&$FF
        STAA      FCB:FLAGS,X
UPDATEDIROKRTS   EQU     *
        OKRTS
        PAGE
*
*       COMPARENAMES -- COMPARES (X) TO (DIRENTRY) FOR DIR:NAMESIZE BYTES
*               DOES NOT DISTURB BUFFER
*               RETURNS Z SET IF MATCH
*               RESET IF NO MATCH
*
COMPARENAMES       EQU     *
        IF      M6800!M6801
        STX     TOPOINTER       SAVE "COMPARE TO" POINTER
        ;LDX    DIRENTRY        GET COMPARE AGAINST POINTER
        LDX     DIRENTRY
        ELSE    (M6809)
        LDY     DIRENTRY        GET COMPARE AGAINST POINTER
        FIN
        LDAB      #DIR:NAMESIZE    NUMBER OF BYTES TO COMPARE
*
*       BLOCKCOMPARE -- COMPARE (X) TO (Y) FOR (B) BYTES
*       (ON 6800/6801, (Y) IS LOCATION 0)
*       RETURN CC "Z" BIT SET IF MATCH, ELSE RESET IF NO MATCH
*
BLOCKCOMPARE        ; COMPARE (X) TO (Y) FOR (B) BYTES
        IF      M6800!M6801
        ;LDA     ,X+     GET BYTE TO COMPARE
        LDAA      0,X
        INX
        STX     FROMPOINTER     SAVE "FROM" POINTER
        ;LDX    TOPOINTER       = "TO" POINTER
        LDX     TOPOINTER
        ;CMPA     ,X      COMPARE BYTES
        CMPA      0,X
        BNE      BLOCKCOMPARERTS     B/ STRINGS DON'T MATCH
        INX
        STX     TOPOINTER       SAVE UPDATE "TO" POINTER
        ;LDX    FROMPOINTER     GET SOURCE POINTER BACK
        LDX     FROMPOINTER
        ELSE    (M6809)
        ;LDA     ,X+     GET A BYTE TO COMPARE
        LDAA      0,X
        INX
        ;CMPA     ,Y+     COMPARE THEM
        CMPA      
        BNE      BLOCKCOMPARERTS     B/ NO MATCH
        FIN
        DECB              DOWN COUNT # BYTES TO COMPARE
        BNE      BLOCKCOMPARE        B/ MORE TO COMPARE
BLOCKCOMPARERTS
        RTS
        PAGE
*
*       HASHFOLD -- SUM NEXT 4 BYTES(X), MASK TO 6 BITS
*               RETURN SIX BIT SUM IN (A)
*               BUMP (X) BY 4
*
HASHFOLD EQU     *
        LDAA      ,X      SUM NEXT 4 BYTES
        ADDA      1,X
        ADDA      2,X
        ADDA      3,X
        ANDA      #%00111111      MASK OFF ASCII ZONE BITS
        ;LEAX    4,X     BUMP (X) BY 4
        IF      4<0
        RPT     -4
        DEX
        ELSE
        RPT     4
        INX
        FIN
        RTS
*
*       HASHINSERT6 -- LEFT SHIFT (IOCB:CURBYTE+1,+2,(A)) 6 BITS
*
HASHINSERT6      EQU     *
        LDAB      #6      GET COUNT OF 6
HASHINSERT6L     EQU     *
        ASLA              SHIFT LEFT 1 BIT
        ROL     IOCB:CURBYTE+2,X
        ROL     IOCB:CURBYTE+1,X
        DECB              DO IT 6 TIMES
        BNE      HASHINSERT6L
        RTS
        PAGE
*
*       HASHNAME --  CONVERT NAME INTO INITIAL PROBE INTO DIRECTORY
*               FOLDS NAME(X) INTO 3 BYTES
*               DIVIDES BY DIRECTORYSIZE TO GET REMAINDER
*               AND PLACES REMAINDER IN IOCB:CURBYTE(SYSIOCB)
*               GUARANTEES INITIAL PROBE IS TO START OF SECTOR
*
HASHNAME  EQU     *
        BSR      HASHFOLD FOLD LEFT MOST 4 BYTES...
        PSHA             TO GET RIGHTMOST 6 BITS
        BSR      HASHFOLD FOLD MIDDLE LEFT 4 BYTES...
        PSHA             TO GET BITS 11-6
        BSR      HASHFOLD FOLD MIDDLE RIGHT 4 BYTES...
        PSHA             TO GET BITS 17-12
        BSR      HASHFOLD FOLD RIGHTMOST 4 BYTES...
        ;LDX    #SYSIOCB  TO GET LEFTMOST 6 BITS
        LDX     #SYSIOCB
        BSR      HASHINSERT6      INSERT BITS 17-12
        PULB
        ABA
        BSR      HASHINSERT6      INSERT BITS 11-7
        PULB
        ABA
        BSR      HASHINSERT6      INSERT BITS 6-0
        PULB
        ABA
        STAA      IOCB:CURBYTE+3,X    STORE RESULT IN IOCB:CURBYTE,X
*       CLR      IOCB:CURBYTE,X      NOW WE HAVE 24 BITS OF FOLDED NAME
        ;LDX    IOCB:DCB,X  NOW COMPUTE # SECTORS IN DIRECTORY
        LDX     IOCB:DCB,X
        LDAA      DSKINFO:LOG2NBPS,X       = DIRSIZE/NBPS
        STAA      COUNT    = DIRSIZE/2^LOG2NBPS
        PSHA             WE'LL NEED THIS LATER
        ;LDX    FCBPOINTER        GET ADDRESS OF DIRECTORY.SYS FCB
        LDX     FCBPOINTER
        ;LDD    FCB:FILESIZE+2,X  COPY DIRSIZE TO (A,B,TEMP.DIVISOR,TEMP.DIVISOR+1)
        LDAB      (FCB:FILESIZE+2)+1,X
        LDAA      FCB:FILESIZE+2,X
        ;STD    TEMP.DIVISOR
        STAB      TEMP.DIVISOR+1
        STAA      TEMP.DIVISOR
        ;LDD    FCB:FILESIZE,X
        LDAB      (FCB:FILESIZE)+1,X
        LDAA      FCB:FILESIZE,X
HASHNAMEL1        EQU     *
        ;LSRD           DIVISOR:=DIVISOR/2...
        LSRA
        RORB
        ROR     TEMP.DIVISOR
        ROR     TEMP.DIVISOR+1  NOTE: NUMBER OF SECTORS IN DIRECTORY <= 32767
        ;DEC     COUNT    LOG2NBPS TIMES
        DEC      COUNT
        BNE      HASHNAMEL1        LEAVING (A,B) = 0
*       NOW DIVIDE FOLDED NAME BY # OF SECTORS IN DIRECTORY TO GET REMAINDER
        ;LDX    #SYSIOCB  GET ADDRESS OF WORK IOCB
        LDX     #SYSIOCB
        LDAB      #24     # QUOTIENT BITS TO GENERATE
        STAB      COUNT    (AND IGNORE)
        CLRA              ZERO OUT THE REMAINDER
        CLRB
HASHNAMEL2        EQU     *
        ASL      IOCB:CURBYTE+3,X    SHIFT NEW DIVIDEND BIT INTO REMAINDER
        ROL     IOCB:CURBYTE+2,X    NOTE: CARRIES ARE NOT IMPORTANT...
        ROL     IOCB:CURBYTE+1,X    BECAUSE WE ONLY WANT REMAINDER, NOT QUOTIENT
        ;ROLD
        ROLB
        ROLA
        ;SUBD    TEMP.DIVISOR    DOES DIVISOR GO IN?
        SUBB      TEMP.DIVISOR+1
        SBCA       TEMP.DIVISOR
        BCC        HASHNAME2 B/ YEP, LEAVE IT IN
        ;ADDD    TEMP.DIVISOR    NO, RESTORE BACK
        ADDB      TEMP.DIVISOR+1
        ADCA       TEMP.DIVISOR
HASHNAME2 EQU     *
        ;DEC     COUNT    DOWN COUNT # QUOTIENT BITS TO IGNORE
        DEC      COUNT
        BNE      HASHNAMEL2        B/ MORE Q BITS TO IGNORE
        STAA      IOCB:CURBYTE+2,X    STORE FOLDEDNAME MOD NUMBERSECTORS...
        ;CLR     IOCB:CURBYTE+1,X    INTO (IOCB:CURBYTE,B)
        CLR      IOCB:CURBYTE+1,X
        ;CLR     IOCB:CURBYTE,X
        CLR      IOCB:CURBYTE,X
        PULA             NOW MULTIPLY BY 2^LOG2NBPS...
HASHNAMEL3        ; TO GET LOGICAL BYTE NUMBER OF DESIRED SECTOR
        ASLB
        ROL     IOCB:CURBYTE+2,X
        ROL     IOCB:CURBYTE+1,X
        ROL     IOCB:CURBYTE,X
        DECA              DOWN COUNT # TIMES TO LEFT SHIFT
        BNE      HASHNAMEL3
        STAB      IOCB:CURBYTE+3,X    STORE LAST BYTE OF :CURBYTE
        RTS             AND EXIT
        PAGE
*
*       FINDFREEFCB -- LOOKS FOR FCB WITH ZEROED REF COUNT
*               OKRTS IF FOUND
*                       FCB IS INITIALIZED FROM DIRENTRY
*                       REF COUNT IS SET TO ONE
*               FCBPOINTER, (X), (A,B) ARE LEFT POINTING TO FCB
*               ERRET IF NONE AVAIALABLE
*
FINDFREEFCB       EQU     *
        LDAA      NFCBS     GET # FCBS TO SEARCH
        IF      M6800!M6801
        STAA      COUNT
        ;LDX    CODE+SDOS:CONFIGURATION
        LDX     CODE+SDOS:CONFIGURATION
        ;LDD    [CNFG:IOCBPOINTERS,X]      GET ADDRESS OF 1ST IOCB
        LDX     CNFG:IOCBPOINTERS,X
        LDAB      1,X
        LDAA      0,X
FINDFREEFCBL      EQU     *
        ;SUBD    #FCB:SIZE BACK UP TO PREVIOUS FCB
        SUBB      #(FCB:SIZE)&$FF
        SBCA       #(FCB:SIZE)/256
        ;TDX
        STAA      TEMPA
        STAB      TEMPB
        LDX     TEMPX
        TST     FCB:REFCOUNT,X     IS THIS FCB BUSY?
        BEQ      SETUPFCB  B/ NO
        ;DEC     COUNT    YES, DOWN COUNT # FCB'S TO CHECK
        DEC      COUNT
        ELSE    (M6809)
        ;LDX    CODE+SDOS:CONFIGURATION
        LDX     CODE+SDOS:CONFIGURATION
        ;LDX    [CNFG:IOCBPOINTERS,X]      GET ADDRESS OF 1ST DCB
        LDX     CNFG:IOCBPOINTERS,X
        LDX     0,X
FINDFREEFCBL
        ;LEAX    -FCB:SIZE,X       FIND PREVIOUS FCB
        IF      -FCB:SIZE<0
        RPT     --FCB:SIZE
        DEX
        ELSE
        RPT     -FCB:SIZE
        INX
        FIN
        TST     FCB:REFCOUNT,X     IS THIS FCB BUSY?
        BEQ      SETUPFCB  B/ NO
        DECA                      YES, DOWN COUNT # FCBS TO SEARCH
        FIN
        BNE      FINDFREEFCBL      B/ MORE TO CHECK
        ;JSR    ERRET   OOPS... NO MORE FCBS???
        JSR     ERRET
        FDB      ERR:NOFREEFCBS
        PAGE
*       SETUPFCB -- COPY CRITICAL DIRENTRY DATA TO FCB(X)
*               SET REFCOUNT ON FCB(X) TO 1
*               ALSO COMPUTES FCB:HLSN FROM FCB:HLCN
*
SETUPFCB  EQU     *
        STX     FCBPOINTER        SAVE FCB ADDRESS
        STX     TOPOINTER       SET UP TARGET POINTER
        ;LDX    DIRENTRY        COPY MOST OF DIRECTORY ENTRY...
        LDX     DIRENTRY
        LDAB      #DIR:FCBDATASIZE    INTO THE FCB
SETUPFCBCL ; COPY A DIRECTORY ENTRY BYTE
        LDAA      DIR:HLCN,X
        INX
        STX     FROMPOINTER
        ;LDX    TOPOINTER       INTO FCB BYTE
        LDX     TOPOINTER
        STAA      FCB:HLCN,X NOTE: DIR AND FCB FORMATS...
        INX             ARE ISOMETRIC WRT DIRECTORY INFO
        STX     TOPOINTER
        ;LDX    FROMPOINTER
        LDX     FROMPOINTER
        DECB
        BNE      SETUPFCBCL B/ MORE BYTES TO COPY
        ;LDD    DCBPOINTER        NOW FINISH FILLING THE FCB
        LDAB      DCBPOINTER+1
        LDAA      DCBPOINTER
        ;LDX    FCBPOINTER
        LDX     FCBPOINTER
        ;STD    FCB:DISKINFO,X
        STAB      (FCB:DISKINFO)+1,X
        STAA      FCB:DISKINFO,X
        LDAA      #1      MARK FCB AS 'BUSY'
        STAA      FCB:REFCOUNT,X
        ;CLR     FCB:FLAGS,X        RESET ALL THE FLAG BITS
        CLR      FCB:FLAGS,X
        ;LDD    FCB:HLCN,X NOW COMPUTE FCB:HLSN = FCB:HLCN * DSKINFO:NSPC
        LDAB      (FCB:HLCN)+1,X
        LDAA      FCB:HLCN,X
        ;JSR    CONVERTLCNTO1ST
        JSR     CONVERTLCNTO1ST
        ;LDX    FCBPOINTER        MOVE LSN OF 1ST HEADER SECTOR INTO FCB
        LDX     FCBPOINTER
        ;STD    FCB:HLSN+1,X
        STAB      (FCB:HLSN+1)+1,X
        STAA      FCB:HLSN+1,X
        LDAA      SYSSECTORDB+SECTORDB:LSN
        STAA      FCB:HLSN,X
SETUPFCBDIRPOS    ; SETUP DIRENTRY DATA IN FCB
        LDAA      SYSIOCB+IOCB:CURLSN  SAVE LSN OF DIRECTORY SECTOR
        STAA      FCB:DIRLSN,X
        ;LDD    SYSIOCB+IOCB:CURLSN+1
        LDAB      SYSIOCB+IOCB:CURLSN+1+1
        LDAA      SYSIOCB+IOCB:CURLSN+1
        ;STD    FCB:DIRLSN+1,X
        STAB      (FCB:DIRLSN+1)+1,X
        STAA      FCB:DIRLSN+1,X
        ;LDD    DIRENTRYDISP    AND DISPLACEMENT TO ENTRY
        LDAB      DIRENTRYDISP+1
        LDAA      DIRENTRYDISP
        ;STD    FCB:DIRDISP,X
        STAB      (FCB:DIRDISP)+1,X
        STAA      FCB:DIRDISP,X
        ;LDD    FCBPOINTER        SET (A,B):=FCBPOINTER BECAUSE THIS IS SOMETIMES CONVENIENT
        LDAB      FCBPOINTER+1
        LDAA      FCBPOINTER
        OKRTS
        PAGE
*
*       SEARCHFCBINIT -- INITIALIZE FOR SEARCH OF FCBS
*               SETS UP FCBPOINTER, COUNT
*               SO THAT "SEARCHFCBS" MAY BE CALLED REPEATEDLY
*               UNTIL IT FAILS
*
SEARCHFCBINIT       EQU     *
        LDAA      NFCBS     GET # FCBS TO SEARCH
        STAA      COUNT
        ;LDX    CODE+SDOS:CONFIGURATION    GET ADDRESS OF FIRST IOCB
        LDX     CODE+SDOS:CONFIGURATION
        ;LDX    [CNFG:IOCBPOINTERS,X]
        LDX     CNFG:IOCBPOINTERS,X
        LDX     0,X
        STX     FCBPOINTER
        RTS
*
*       SEARCHFCBS -- SEARCH FCBS FOR MATCHING SYSIOCB+IOCB:CURLSN AND DIRENTRYDISP
*               OKRTS IF FOUND; DOES NOT BUMP REFCOUNT, SETS FCBPOINTER
*               WILL NOT MATCH AGAINST FCBS WHOSE "DELETED" BIT IS SET
*               ERRET IF NO MATCH
*
SEARCHFCBS  EQU     *
        ;LDD    FCBPOINTER        FIND NEXT FCB
        LDAB      FCBPOINTER+1
        LDAA      FCBPOINTER
        ;SUBD    #FCB:SIZE = THIS FCB - FCB:SIZE
        SUBB      #(FCB:SIZE)&$FF
        SBCA       #(FCB:SIZE)/256
        ;STD    FCBPOINTER        REMEMBER FCB ADDRESS
        STAB      FCBPOINTER+1
        STAA      FCBPOINTER
        ;LDX    FCBPOINTER        IS FCB FREE ?
        LDX     FCBPOINTER
        LDAA      FCB:REFCOUNT,X
        BEQ      SEARCHFCBCMPNO       B/ YES, CAN'T MATCH
        ;LDD    SYSIOCB+IOCB:CURLSN+1        (THESE TESTS ORDERED ACCORDING TO PROBABILTY OF FAILURE)
        LDAB      SYSIOCB+IOCB:CURLSN+1+1
        LDAA      SYSIOCB+IOCB:CURLSN+1
        ;CMPD    FCB:DIRLSN+1,X    DIRECTORY LSN = FCB:DIRLSN ?
        CMPA      FCB:DIRLSN+1,X
        BNE      MACRO:001A
        CMPB      (FCB:DIRLSN+1)+1,X
MACRO:001A
        BNE      SEARCHFCBCMPNO       B/ NOPE
        LDAA      SYSIOCB+IOCB:CURLSN
        ;CMPA     FCB:DIRLSN,X
        CMPA      FCB:DIRLSN,X
        BNE      SEARCHFCBCMPNO       B/ WRONG LSN
        ;LDD    DIRENTRYDISP    CORRECT DIR ENTRY DISPLACMENT ?
        LDAB      DIRENTRYDISP+1
        LDAA      DIRENTRYDISP
        ;CMPD    FCB:DIRDISP,X
        CMPA      FCB:DIRDISP,X
        BNE      MACRO:001B
        CMPB      (FCB:DIRDISP)+1,X
MACRO:001B
        BNE      SEARCHFCBCMPNO       B/ WRONG DISPLACEMENT
        LDAA      FCB:FLAGS,X        IS THIS FCB MARK AS DELETED ?
        BITA      #FCBFLG::DELETED  (IF SO, IGNORE IT)
        BNE      SEARCHFCBCMPNO       B/ NO
        ;LDX    FCB:DISKINFO,X    LAST BUT NOT LEAST,
        LDX     FCB:DISKINFO,X
        CPX      DCBPOINTER        IS FCB FOR FILE ON THE CORRECT DISK ?
        BEQ      SEARCHFCBRTS        B/ NO, WE FOUND A MATCH !
SEARCHFCBCMPNO       ; THIS FCB WASN'T IT!
        ;DEC     COUNT    DOWN COUNT # FCBS LEFT TO EXAMINE
        DEC      COUNT
        BNE      SEARCHFCBS  B/ MORE FCBS TO SEARCH
        ;JSR    ERRET
        JSR     ERRET
        FDB      ERR:NOMATCHFCB

SEARCHFCBRTS        EQU     *
        ;LDX    FCBPOINTER
        LDX     FCBPOINTER
        ;LDD    FCBPOINTER        BECAUSE THIS IS USEFUL, SOMETIMES
        LDAB      FCBPOINTER+1
        LDAA      FCBPOINTER
        OKRTS
        PAGE
*
*       PARSEFILENAME -- PASSED POINTER IN SYSCALL BLOCK TO FILENAME
*               BUILDS FILE NAME INTO "FILENAME" BLOCK
*               COLLECTS SPACE ALLOCATION IF SPECIFIED
*       OKRTS IF LEGAL NAME
*       SETS @SCBLK:RDBUF = # BYTES OF FILENAME ACTUALLY SCANNED
*       RETURNS (X) = POINTER TO FILENAME BLOCK
*       ERRET IF ILLEGAL NAME
*
PARSEFILENAME     EQU     *
        ;LDX    #0      ZERO OUT 4 BYTE REQUESTED FILE SIZE
        LDX     #0
        STX     FILESIZERQSTD
        STX     FILESIZERQSTD+2
        ;JSR    CHECKRDLEN        MAKE SURE THERE'S ENOUGH ROOM TO READ BACK THE FILE NAME SIZE
        JSR     CHECKRDLEN
        FDB      2
        ;LDB     #CREATE:FILESIZESCLEN      IS INITIAL FILE ALLOCATION INCLUDED IN CREATE BLOCK ?
        LDAB      #CREATE:FILESIZESCLEN
        ;JSR    CHECKSCLEN ...?
        JSR     CHECKSCLEN
        BCS       PARSENAME0        B/ NO, USE USER SPECIFIED SIZE OR 0
        ;LDD    CREATE:FILESIZE,X YES, GET SIZE FROM 1ST 4 BYTES OF DATA
        LDAB      (CREATE:FILESIZE)+1,X
        LDAA      CREATE:FILESIZE,X
        ;STD    FILESIZERQSTD
        STAB      FILESIZERQSTD+1
        STAA      FILESIZERQSTD
        ;LDD    CREATE:FILESIZE+2,X
        LDAB      (CREATE:FILESIZE+2)+1,X
        LDAA      CREATE:FILESIZE+2,X
        ;STD    FILESIZERQSTD+2
        STAB      FILESIZERQSTD+2+1
        STAA      FILESIZERQSTD+2
PARSENAME0 ; DEFAULT FILE SIZE SET, NOW PARSE THE NAME ITSELF
        ;LDX    CODE+SDOS:IOBLOCKPTR
        LDX     CODE+SDOS:IOBLOCKPTR
        ;LDD    SCBLK:WRLEN,X     GET SIZE OF USER-SPECIFIED FILE NAME
        LDAB      (SCBLK:WRLEN)+1,X
        LDAA      SCBLK:WRLEN,X
        ;LDX    SCBLK:RDBUF,X      SUBTRACT NUMBER OF CHARACTERS EXTRACTED FOR DEVICE NAME
        LDX     SCBLK:RDBUF,X
        ;SUBD    0,X
        SUBB      (0)+1,X
        SBCA       0,X
        ;STD    PARSECOUNT        SAVE SIZE OF FILENAME
        STAB      PARSECOUNT+1
        STAA      PARSECOUNT
        ;BEQD    ERRBADFILENAMEJ    B/ ZERO LENGTH FILE NAME
        BNE      MACRO:001C
        TSTB
        BEQ      ERRBADFILENAMEJ
MACRO:001C
        PAGE
        ;LDX    CODE+SDOS:IOBLOCKPTR       GRAB POINTER TO USER-SPECIFIED FILE NAME
        LDX     CODE+SDOS:IOBLOCKPTR
        ;LDD    SCBLK:WRBUF,X
        LDAB      (SCBLK:WRBUF)+1,X
        LDAA      SCBLK:WRBUF,X
        ;LDX    SCBLK:RDBUF,X      SKIP PAST DEVICE NAME
        LDX     SCBLK:RDBUF,X
        ;ADDD    0,X
        ADDB      (0)+1,X
        ADCA       0,X
        ;STD    NAMESCANPTR        SET UP TO SCAN FILE NAME
        STAB      NAMESCANPTR+1
        STAA      NAMESCANPTR
        ;LDA     [NAMESCANPTR]      GRAB THE FIRST BYTE OF THE FILE NAME
        LDX     NAMESCANPTR
        LDAA      0,X
        ;CMPA     #'.     A PERIOD ?
        CMPA      #'.
        BEQ      ERRBADFILENAMEJ    B/ YES, ILLEGAL FILE NAME
        ;JSR    ISDIG   NO, A DIGIT ?
        JSR     ISDIG
        BCC        ERRBADFILENAME     B/ YES, MUST START WITH ALPHA OR '$'!
        ;LDX    #FILENAMEBUF
        LDX     #FILENAMEBUF
        STX     TOPOINTER
        ;CLR     FILENAMELENGTH   = # CHARACTERS ACTUALLY COMPRISING FILENAME
        CLR      FILENAMELENGTH
        LDAB      #DIR:NAMESIZE
PARSENAME1        EQU     *
        ;JSR    PARSENAMEB
        JSR     PARSENAMEB
        ;LDX    TOPOINTER
        LDX     TOPOINTER
        ;STA     ,X+
        STAA      0,X
        INX
        STX     TOPOINTER       SAVE NEXT PLACE TO STORE BYTE
        DECB
        BNE      PARSENAME1
*       NOW SCAN PAST REST OF NAME
*
PARSESCANL EQU     *
        ;JSR    PARSENAMEB
        JSR     PARSENAMEB
        ;CMPA     #ASCII:SPACE
        CMPA      #ASCII:SPACE
        BNE      PARSESCANL B/ VALID CHARACTER FOR FILENAME, IGNORE IT
        LDAA      FILENAMELENGTH   IS NAME OF REASONABLE LENGTH ?
ERRBADFILENAMEJ
        BEQ      ERRBADFILENAME     B/ NAME IS OF ZERO LENGTH!
        ;CMPA     #DIR:NAMESIZE    ...?
        CMPA      #DIR:NAMESIZE
        BHI      ERRBADFNAMESIZE    B/ NO, ITS TOO LONG!
        PAGE
        ;JSR    PARSENAMEB1
        JSR     PARSENAMEB1
        ;CMPA     #'(     START OF REQUESTED FILESIZE ?
        CMPA      #'(
        BNE      PARSEQUIT        COLLECT # OF BYTES TO ALLOCATE FOR FILE
        ;LDX    #0      OVERRIDE THE DEFAULT GIVEN IN SYSCALL BLOCK
        LDX     #0
        STX     FILESIZERQSTD
        STX     FILESIZERQSTD+2
PARSESCAND EQU     *
        ;JSR    PARSENAMEB1        LOOKS LIKE DEFAULT FILESIZE
        JSR     PARSENAMEB1
        ;CMPA     #')     END OF FILESIZE
        CMPA      #')
        BEQ      PARSEQUIT        B/ YES
        ;JSR    ISDIG   NO, A DIGIT ?
        JSR     ISDIG
        BCS       ERRILLFILESIZE  NO, OOPS!
        SUBA      #'0     CONVERT TO BINARY
        STAA      FILESIZE2+3     SAVE THE DIGIT
        ;LDX    FILESIZERQSTD   MULTIPLY OLD FILESIZE BY 10
        LDX     FILESIZERQSTD
        STX     TEMP    FIRST COPY FILESIZERQSTD TO TEMP
        ;LDX    FILESIZERQSTD+2
        LDX     FILESIZERQSTD+2
        STX     TEMP+2
        ;LDX    #FILESIZERQSTD  COMPUTE...
        LDX     #FILESIZERQSTD
        BSR      ADDTOFILESIZE    2*FILESIZERQSTD
        BSR      ADDTOFILESIZE    4*FILESIZERQSTD
        ;LDX    #TEMP
        LDX     #TEMP
        BSR      ADDTOFILESIZE    5*FILESIZERQSTD
        ;LDX    #FILESIZERQSTD
        LDX     #FILESIZERQSTD
        BSR      ADDTOFILESIZE    10*FILESIZERQSTD
        ;LDX    #FILESIZE2      = (0,0,0,DIGIT)
        LDX     #FILESIZE2
        BSR      ADDTOFILESIZE    + DIGIT
        BRA       PARSESCAND

ERRBADFILENAME     EQU     *
        BSR      PARSEQUIT        GO SET LENGTH OF FILENAME INTO REPLY BUFFER
        ;JSR    ERRET
        JSR     ERRET
        FDB      ERR:BADFILENAME

PARSEQUIT        ; COMPUTE AND STORE LENGTH OF FILENAME
        ;LDD    NAMESCANPTR        = NAMESCANPTR - WRBUF FROM SYSCALL BLOCK
        LDAB      NAMESCANPTR+1
        LDAA      NAMESCANPTR
        ;LDX    CODE+SDOS:IOBLOCKPTR
        LDX     CODE+SDOS:IOBLOCKPTR
        ;SUBD    SCBLK:WRBUF,X
        SUBB      (SCBLK:WRBUF)+1,X
        SBCA       SCBLK:WRBUF,X
        ;STD    [SCBLK:RDBUF,X]    THIS IS READ-BACK BUFFER ADDRESS
        LDX     SCBLK:RDBUF,X
        STAB      1,X
        STAA      0,X
        ;LDX    #FILENAMEBUF      AS PROMISED
        LDX     #FILENAMEBUF
        OKRTS
        PAGE
ERRBADFNAMESIZE    EQU     *
        ;JSR    PARSEQUIT        SET FILE NAME LENGTH INTO REPLY BUFFER
        JSR     PARSEQUIT
        ;JSR    ERRET
        JSR     ERRET
        FDB      ERR:BADFNAMESIZE
*
*       ADDTOFILESIZE -- ADDS 4 BYTE NUMBER(X) TO FILESIZERQSTD
*       IF SUM >= 2^31, POPS RETURN OFF STACK AND EXITS TO ERRILLFILESIZE
*
ADDTOFILESIZE    EQU     *
        ;LDD    FILESIZERQSTD+2
        LDAB      FILESIZERQSTD+2+1
        LDAA      FILESIZERQSTD+2
        ;ADDD    2,X
        ADDB      (2)+1,X
        ADCA       2,X
        ;STD    FILESIZERQSTD+2
        STAB      FILESIZERQSTD+2+1
        STAA      FILESIZERQSTD+2
        ;LDD    FILESIZERQSTD
        LDAB      FILESIZERQSTD+1
        LDAA      FILESIZERQSTD
        ADCB       1,X
        ADCA       0,X
        BMI      ADDTOFILEOV
        BCS       ADDTOFILEOV
        ;STD    FILESIZERQSTD
        STAB      FILESIZERQSTD+1
        STAA      FILESIZERQSTD
        RTS

ADDTOFILEOV      ; ANSWER IS TOO BIG TO BE LEGAL
        ;LEAS    2,S
        IF      2<0
        RPT     -2
        DES
        ELSE
        RPT     2
        INS
        FIN
ERRILLFILESIZE  EQU     *
        BSR      PARSEQUIT        SET FILE NAME LENGTH INTO REPLY BUFFER
        ;JSR    ERRET
        JSR     ERRET
        FDB      ERR:ILLFILESIZE
        PAGE
*
*       PARSENAMEB -- GET BYTE OF FILE NAME PROPER
*               RETURN ASCII:SPACE IF END OF NAME, OR NOT ., $, A-Z, 0-9
*
PARSENAMEB EQU     *
        ;LDX    PARSECOUNT        CHECK FOR NO MORE BYTES IN SOURCE OF FILENAME
        LDX     PARSECOUNT
        BEQ      PARSENAMEBLANK      B/ NO MORE, USE A BLANK TO PAD
        ;LDX    NAMESCANPTR        GRAB NEXT BYTE FROM SOURCE STRING
        LDX     NAMESCANPTR
        LDAA      0,X
        ;CMPA     #'.     VALID CHARACTER FOR FILENAME ?
        CMPA      #'.
        BEQ      PARSENAMEBOK       B/ YES
        ;CMPA     #'$
        CMPA      #'$
        BEQ      PARSENAMEBOK       B/ YES
        ;JSR    ISALPHANUM        CHECK FOR ALPHA-NUMERIC AND FOLD
        JSR     ISALPHANUM
        BCC        PARSENAMEBOK       B/ IS OK.
PARSENAMEBLANK      EQU     *
        LDAA      #ASCII:SPACE        USE A BLANK TO PAD NAME
        RTS
*
PARSENAMEBOK       EQU     *
        ;INC     FILENAMELENGTH   SO WE KNOW HOW LONG THE ORIGINAL NAME WAS
        INC      FILENAMELENGTH
PARSENAMEBX        ; UPDATE POINTER TO SOURCE STRING
        INX
        STX     NAMESCANPTR
        ;LDX    PARSECOUNT        DOWN COUNT # CHARS REMAINING IN SOURCE STRING
        LDX     PARSECOUNT
        DEX
        STX     PARSECOUNT
        RTS
        PAGE
*
*       PARSENAMEB1 -- GET BYTE OF FILENAME
*               RETURN NEXT BYTE OF FILENAME OR BLANK
*
PARSENAMEB1        EQU     *
        ;LDX    PARSECOUNT        ANY BYTES OF SOURCE STRING UNPROCESSED ?
        LDX     PARSECOUNT
        BEQ      PARSENAMEBLANK      B/ NO, USE A BLANK INSTEAD
        ;LDX    NAMESCANPTR        YES, GRAB THE NEXT SOURCE STRING BYTE
        LDX     NAMESCANPTR
        LDAA      0,X
        BRA       PARSENAMEBX        AND EXIT WITH IT
*
ERRNODISKMAP     EQU     *
        ;JSR    ERRET
        JSR     ERRET
        FDB      ERR:NODISKMAP
        PAGE     DISK FILE DRIVERS -- DISK SPACE MANAGEMENT
*       ALLOCATECLUSTERS -- ALLOCATES (A,B) DATA CLUSTERS TO FILE
*               SPECIFIED IN IOCB, STARTING AT IOCB:RDCN
*               (A,B) MUST BE <> 0 ON ENTRY
*               CLUSTER SPECIFIED BY IOCB:RDCN MUST NOT CURRENTLY BE ALLOCATED
*               UPDATES FCB:NCLUSTERS, FCB:HCSIC
*               IOCBPOINTER POINTS TO IOCB WHOSE FILE IS TO BE IMPROVED
*               FCBPOINTER MUST SELECT FCB OF FILE TO BE IMPROVED
*               IF FCB:HCSIC = 0, A HEADER CLUSTER IS ALLOCATED
*               OKRTS TAKEN IF AT LEAST 1 DATA CLUSTER WAS ALLOCATED
*               DESTROYS RDCN!
*               ERRET TAKEN IF NO DISK SPACE AVAILABLE
*               ZEROES ALLOCATED DATA CLUSTERS IF IOCB:EOFFLAG IS RESET
*
ERRALLOC0CLUSTERS
        ;JSR    ERRET
        JSR     ERRET
        FDB      ERR:ALLOC0CLUSTERS

ALLOCATECLUSTERS    EQU     *
        ;STD    ALLOCATIONCOUNT     SAVE DESIRED ALLOCATION
        STAB      ALLOCATIONCOUNT+1
        STAA      ALLOCATIONCOUNT
        ;BEQD    ERRALLOC0CLUSTERS  B/ ALLOCATE ZERO CLUSTERS!!??
        BNE      MACRO:001D
        TSTB
        BEQ      ERRALLOC0CLUSTERS
MACRO:001D
        ;LDX    DCBPOINTER
        LDX     DCBPOINTER
        LDAA      DSKINFO:MAPFCB,X   MAKE SURE DISK HAS A DISKMAP
        BEQ      ERRNODISKMAP     B/ NOPE, I GIVE UP!
        ;LDX    FCBPOINTER        NOW CHECK EXISTENCE OF HEADER
        LDX     FCBPOINTER
        LDAA      FCB:HCSIC,X HCSIC = 0 ?
        BNE      ALLOC2    B/ HEADER CLUSTER IS ALLOCATED
        ;CLR     FCB:NCLUSTERS,X    MARK '0 CLUSTERS'
        CLR      FCB:NCLUSTERS,X
        ;CLR     FCB:NCLUSTERS+1,X  IN FILE
        CLR      FCB:NCLUSTERS+1,X
        ;LDX    ALLOCATIONCOUNT     BUMP DESIRED DATA CLUSTER COUNT...
        LDX     ALLOCATIONCOUNT
        INX             TO INSURE HEADER CLUSTER...
        STX     ALLOCATIONCOUNT     GETS INCLUDED IN MAP SEARCH
        ;LDD    #DUMMYLCN        GET 'CHOOSE RANDOM START POINT' CODE AS PREVIOUSLY ALLOCATED LCN
        LDAB      #(DUMMYLCN)&$FF
        LDAA      #(DUMMYLCN)/256
        ;JSR    SEARCHMAP  GO LOOK FOR DISK SPACE
        JSR     SEARCHMAP
        ;LDX    ALLOCATIONCOUNT     REMOVE HEADER CLUSTER...
        LDX     ALLOCATIONCOUNT
        DEX             FROM DESIRED ALLOCATION
        STX     ALLOCATIONCOUNT
        ;LDX    FCBPOINTER        STORE LCN OF HEADER CLUSTER
        LDX     FCBPOINTER
        ;STD    FCB:HLCN,X
        STAB      (FCB:HLCN)+1,X
        STAA      FCB:HLCN,X
        ;LDX    IOCBPOINTER
        LDX     IOCBPOINTER
        ;CLR     IOCB:DRSN,X       INVENT THE 1ST SECTOR OF HEADER...
        CLR      IOCB:DRSN,X
        ;JSR    CONVERTLCNTOLSN   SO WE CAN INITIALIZE IT
        JSR     CONVERTLCNTOLSN
        ;JSR    INVENTSECTOR
        JSR     INVENTSECTOR
        ;JSR    ALLOCINITHS       INITIALIZE THE 1ST SECTOR OF HEADER CLUSTER
        JSR     ALLOCINITHS
        ;LDX    FCBPOINTER        BUMP # SECTORS IN HEADER THAT ARE INITZED
        LDX     FCBPOINTER
        ;INC     FCB:HCSIC,X (=1)
        INC      FCB:HCSIC,X
        ;INC     FCB:NCLUSTERS+1,X  MAKE SURE HEADER CLUSTER IS COUNTED (=1)
        INC      FCB:NCLUSTERS+1,X
        LDAA      FCB:FLAGS,X        FORCE FCB CONTENTS BACK TO DIRECTORY, ALSO
        ORAA      #FCBFLG::UPDATEDIR
        STAA      FCB:FLAGS,X
        ;LDD    FCB:HLCN,X PUT SELF POINTER INTO 1ST BYTES OF SECTOR
        LDAB      (FCB:HLCN)+1,X
        LDAA      FCB:HLCN,X
        ;LDX    RDSIPOINTER
        LDX     RDSIPOINTER
        ;LDX    RDSI:SECTORBASE,X
        LDX     RDSI:SECTORBASE,X
        ;STD    HEADER:LCN,X      NOW 1ST SECTOR OF HEADER CLUSTER IS SET UP
        STAB      (HEADER:LCN)+1,X
        STAA      HEADER:LCN,X
        ;LDX    IOCBPOINTER       COPY LSN OF 1ST HEADER SECTOR...
        LDX     IOCBPOINTER
        LDAA      IOCB:CURLSN,X      INTO FCB FOR FILE
        PSHA             COPY LSN TO (TOS),(A,B)
        ;LDD    IOCB:CURLSN+1,X
        LDAB      (IOCB:CURLSN+1)+1,X
        LDAA      IOCB:CURLSN+1,X
        ;LDX    FCBPOINTER        THEN INTO FCB
        LDX     FCBPOINTER
        ;STD    FCB:HLSN+1,X
        STAB      (FCB:HLSN+1)+1,X
        STAA      FCB:HLSN+1,X
        PULA
        STAA      FCB:HLSN,X
        PAGE
ALLOC2    ; HEADER CLUSTER EXISTS, CHECK FOR INITIALIZED
        ;LDX    IOCBPOINTER
        LDX     IOCBPOINTER
        ;LDD    IOCB:RDCN,X        FIND OUT WHICH HEADER CLUSTER SECTOR...
        LDAB      (IOCB:RDCN)+1,X
        LDAA      IOCB:RDCN,X
        ;ADDD    ALLOCATIONCOUNT     CONTAINS LAST CLUSTER DESCRIPTOR WE'LL ALLOCATE
        ADDB      ALLOCATIONCOUNT+1
        ADCA       ALLOCATIONCOUNT
        ;SUBD    #1      = RDCN+ALLOCATIONCOUNT-1
        SUBB      #(1)&$FF
        SBCA       #(1)/256
        ;ASLD            CONVERT # CLUSTERS DESIRED INTO # BYTES REQUIRED TO HOLD CLUSTER NUMBERS
        ASLB
        ROLA
        ;LDX    DCBPOINTER        MAKE SURE WE DON'T OVERRUN THE HEADER CLUSTER
        LDX     DCBPOINTER
        ;CMPD    DSKINFO:NBPC,X    (I.E., # BYTES NEEDED IN HEADER CLUSTER < NBPC )
        CMPA      DSKINFO:NBPC,X
        BNE      MACRO:001E
        CMPB      (DSKINFO:NBPC)+1,X
MACRO:001E
        BCS       ALLOC2A    B/ WILL FIT IN HEADER CLUSTER
ALLOC2BIG  ; ALLOCATION REQUEST WILL RUN OFF END OF HEADER CLUSTER
        LDAB      DSKINFO:NSPC,X   MAKE SURE THIS MANY HEADER SECTORS ARE INITZED
        BRA       ALLOC2B    GO DO IT!
        PAGE
ALLOC2A    EQU     *
        ;JSR    COMPUTERSN       COMPUTE RELATIVE SECTOR NUMBER
        JSR     COMPUTERSN
        INCB              (B) NOW CONTAINS # HEADER SECTORS THAT NEED TO BE INITZ'D
ALLOC2B    EQU     *
        ;LDX    FCBPOINTER        CHECK TO MAKE SURE ALL OF THEM ARE INITZ'D
        LDX     FCBPOINTER
        ;CMPB     FCB:HCSIC,X (I.E., IS HCSIC >= NUMBER NEEDED ?)
        CMPB      FCB:HCSIC,X
        BCS       ALLOC3    B/ ALL NEEDED HEADER SECTORS ARE INITZ'D
        BEQ      ALLOC3    B/ # NEEDED = # INITZED, ALL IS OK
        LDAA      #FCBFLG::UPDATEDIR *** MUST INITZ HEADER CLUSTER SECTORS ***
        ORAA      FCB:FLAGS,X        MAKE SURE DIRECTORY GETS UPDATED
        STAA      FCB:FLAGS,X        SINCE WE'LL CHANGE FCB:HCSIC
        LDAA      FCB:HCSIC,X GRAB THE CURRENTLY INITZ'D COUNT
        STAB      FCB:HCSIC,X STORE THE NEW VALUE
        ;LDX    IOCBPOINTER       STUFF VALUE INTO IOCB
        LDX     IOCBPOINTER
        STAA      IOCB:HRSN,X       SO WE CAN USE GENHLSNPLUSHRSN
ALLOCINITHC        ; NOW INITIALIZE HEADER SECTORS
        ;JSR    GENHLSNPLUSHRSN GEN HLSN PLUS RELATIVE HEADER SECTOR NUMBER
        JSR     GENHLSNPLUSHRSN
        ;JSR    INVENTSECTOR     DON'T BOTHER READING THE SECTOR FROM THE DISK
        JSR     INVENTSECTOR
        ;JSR    ALLOCINITHS       GO INITIALIZE THE HEADER SECTOR
        JSR     ALLOCINITHS
        ;LDX    IOCBPOINTER       RETRIEVE NEXT RELATIVE SECTOR NUMBER TO INITZ
        LDX     IOCBPOINTER
        ;INC     IOCB:HRSN,X       = LAST RELATIVE SECTOR NUMBER + 1
        INC      IOCB:HRSN,X
        LDAA      IOCB:HRSN,X
        ;LDX    FCBPOINTER        DONE INITIALIZING HEADER SECTORS ?
        LDX     FCBPOINTER
        ;CMPA     FCB:HCSIC,X ...?
        CMPA      FCB:HCSIC,X
        BNE      ALLOCINITHC        B/ NO, GO INIT ANOTHER ONE
        PAGE
ALLOC3    ; REQUIRED HEADER SECTORS ARE ALL INITIALIZED
        ;JSR    LOCATERDCN JUST TO MAKE SURE THAT RDCN SLOT EXISTS IN HEADER
        JSR     LOCATERDCN
* WE'RE TRYING TO GAURANTEE AT LEAST 1 DATA CLUSTER GETS ALLOCATED TO FILE!
        ;LDX    IOCBPOINTER       TO MAKE SURE ITS RIGHT
        LDX     IOCBPOINTER
        ;LDD    IOCB:RDCN,X        FIND CLUSTER # ALLOCATED...
        LDAB      (IOCB:RDCN)+1,X
        LDAA      IOCB:RDCN,X
*       JUST PREVIOUS TO THE SLOT WE'RE ABOUT TO FILL
        ;SUBD    #1      FIND RELATIVE DATA CLUSTER NUMBER OF PREVIOUS DATA CLUSTER
        SUBB      #(1)&$FF
        SBCA       #(1)/256
        ;STD    IOCB:RDCN,X        AND SAVE IT (WE'LL BUMP IT BACK TO ORIGINAL VALUE LATER)
        STAB      (IOCB:RDCN)+1,X
        STAA      IOCB:RDCN,X
        ;JSR    LOCATERDCN GO FIND PREVIOUS LCN
        JSR     LOCATERDCN
        ;LDD    HEADER:LCN,X      NOW GET THE PREVIOUSLY ALLOCATED CLUSTER NUMBER
        LDAB      (HEADER:LCN)+1,X
        LDAA      HEADER:LCN,X
        ;JSR    SEARCHMAP  LET'S ALLOCATE THE FIRST DATA CLUSTER
        JSR     SEARCHMAP
        ;LDX    IOCBPOINTER       SET RDCN BACK TO ENTRY VALUE
        LDX     IOCBPOINTER
        ;INC     IOCB:RDCN+1,X
        INC      IOCB:RDCN+1,X
        BNE      ALLOCDC2
        ;INC     IOCB:RDCN,X
        INC      IOCB:RDCN,X
        BRA       ALLOCDC2   FOUND A FREE CLUSTER, SKIP INTO LOOP

ALLOCERRED        EQU     *
        RTS

ALLOCDC5   ; SEARCHMAP FAILED ON 2ND OR LATER DATA CLUSTER
        CPX      #ERR:NODISKSPACE  OUT OF DISK SPACE ?
        BNE      ALLOCERRED        B/ NO, PROBLEM IS MORE SERIOUS
        ;JMP    ALLOCDONE ELSE WE CAN QUIT; WE ALLOCATED A SECTOR
        JMP     ALLOCDONE
        PAGE
ALLOCDATACLUSTERS    ; ALLOCATE MORE DATA CLUSTERS TO FILE
        ;LDD    ALLOCATIONPLCN      GET PREVIOUSLY ALLOCATED LCN
        LDAB      ALLOCATIONPLCN+1
        LDAA      ALLOCATIONPLCN
        ;JSR    SEARCHMAP  GO FIND ME A PLACE!
        JSR     SEARCHMAP
        BCS       ALLOCDC5   NO MORE SECTORS AVAILABLE FOR ALLOCATION
ALLOCDC2   ; ENTRY POINT FOR FIRST DATA CLUSTER ALLOCATION
        ;STD    ALLOCATIONPLCN      SAVE LCN JUST FOUND FOR USE NEXT ROUND (POETIC, HUH?)
        STAB      ALLOCATIONPLCN+1
        STAA      ALLOCATIONPLCN
        ;JSR    LOCATERDCN GET POINTER TO RDCN IN SECTOR
        JSR     LOCATERDCN
        ;LDD    ALLOCATIONPLCN      STORE NEWLY ALLOCATED LCN INTO HEADER SECTOR OF FILE
        LDAB      ALLOCATIONPLCN+1
        LDAA      ALLOCATIONPLCN
        ;STD    HEADER:LCN,X
        STAB      (HEADER:LCN)+1,X
        STAA      HEADER:LCN,X
        ;LDX    IOCBPOINTER       MARK HEADER SECTOR AS MODIFIED
        LDX     IOCBPOINTER
        ;LDX    IOCB:HRDSI,X      LOCATERDCN MAKES THIS VALID!
        LDX     IOCB:HRDSI,X
        LDAA      #1
        STAA      RDSI:MODIFIED,X
        ;LDX    IOCBPOINTER       IS THIS ALLOCATION...
        LDX     IOCBPOINTER
        LDAA      IOCB:EOFFLAG,X     OCCURRING IN THE MIDDLE OF THE FILE ?
        BNE      ALLOCDC4   B/ NO, ALLOCATION OCCURRING PAST END OF FILE
        ;CLR     IOCB:LOCATEDF,X     FORCE RE-LOCATION TO OCCUR AGAIN
        CLR      IOCB:LOCATEDF,X
        ;CLR     IOCB:DRSN,X       SELECT SECTOR ZERO OF CLUSTER
        CLR      IOCB:DRSN,X
        ;LDD    ALLOCATIONPLCN      GET CLUSTER NUMBER
        LDAB      ALLOCATIONPLCN+1
        LDAA      ALLOCATIONPLCN
        ;JSR    ZEROCLUSTER      GO ZERO THE CLUSTER
        JSR     ZEROCLUSTER
ALLOCDC4   ; DONE ZEROING CLUSTER
        ;LDX    FCBPOINTER        BUMP # CLUSTERS ALLOCATED TO FILE
        LDX     FCBPOINTER
        ;INC     FCB:NCLUSTERS+1,X
        INC      FCB:NCLUSTERS+1,X
        BNE      ALLOCDC3
        ;INC     FCB:NCLUSTERS,X
        INC      FCB:NCLUSTERS,X
ALLOCDC3   EQU     *
        LDAA      FCB:FLAGS,X        FORCE FCB BACK TO DIRECTORY
        ORAA      #FCBFLG::UPDATEDIR
        STAA      FCB:FLAGS,X
        ;LDX    ALLOCATIONCOUNT     REMEMBER THAT WE ALLOCATED A CLUSTER
        LDX     ALLOCATIONCOUNT
        DEX             BY DECREMENTING NUMBER OF CLUSTERS LEFT TO ALLOCATE
        STX     ALLOCATIONCOUNT     REMEMBER NUMBER OF CLUSTERS LEFT TO ALLOCATE
        BEQ      ALLOCDONE B/ ALL DONE ALLOCATING
        ;LDX    IOCBPOINTER       BUMP RELATIVE DATA CLUSTER NUMBER...
        LDX     IOCBPOINTER
        ;INC     IOCB:RDCN+1,X      SO WE WILL FILL THE NEXT ONE
        INC      IOCB:RDCN+1,X
        BNE      ALLOCDC1   B/ NO CARRY TO PROPOGATE
        ;INC     IOCB:RDCN,X
        INC      IOCB:RDCN,X
ALLOCDC1   EQU     *
        ;LDD    IOCB:RDCN,X        WILL WE RUN OFF END OF HEADER CLUSTER ?
        LDAB      (IOCB:RDCN)+1,X
        LDAA      IOCB:RDCN,X
        ;ASLD            (I.E., IS RDCN*2 >= NBPC ? )
        ASLB
        ROLA
        ;LDX    DCBPOINTER
        LDX     DCBPOINTER
        ;SUBD    DSKINFO:NBPC,X    (I.E., IS RDCN-NBPC >= 0?)
        SUBB      (DSKINFO:NBPC)+1,X
        SBCA       DSKINFO:NBPC,X
        BCC        ALLOCDONE B/ YES, QUIT ALLOCATING NOW
        ;JSR    LOCATERDCN LOCATE NEXT LCN FOR DATA CLUSTER
        JSR     LOCATERDCN
        ;LDX    HEADER:LCN,X      IS LCN FOR :RDCN UNALLOCATED ?
        LDX     HEADER:LCN,X
        INX             ...?
        BEQ      ALLOCDATACLUSTJ      B/ YES, GO FILL UNALLOCATED SLOT
ALLOCDONE ; AT LEAST ONE DATA CLUSTER WAS ALLOCATED
        ;LDD    ALLOCATIONPLCN      UPDATE RANDOM MAP SEARCH START POINT
        LDAB      ALLOCATIONPLCN+1
        LDAA      ALLOCATIONPLCN
        ;LDX    DCBPOINTER        TO LAST ALLOCATED SECTOR...
        LDX     DCBPOINTER
        ;STD    DSKINFO:RANDMAP,X WHICH IS NEAR A REGION OF FREE CLUSTERS
        STAB      (DSKINFO:RANDMAP)+1,X
        STAA      DSKINFO:RANDMAP,X
        OKRTS

ALLOCDATACLUSTJ      EQU     *
        ;JMP    ALLOCDATACLUSTERS
        JMP     ALLOCDATACLUSTERS
        PAGE
*
*       ALLOCINITHS -- INITIALIZE HEADER CLUSTER SECTOR...
*               WHOSE RDSI IS IN RDSIPOINTER
*               RETURN (X)= IOCBPOINTER
*               MARKS SECTOR AS MODIFIED
*
ALLOCINITHS       EQU     *
        ;LDX    DCBPOINTER        GET NEGATIVE OF NUMBER OF BYTES PER SECTOR
        LDX     DCBPOINTER
        CLRA
        CLRB
        ;SUBD    DSKINFO:NBPS,X
        SUBB      (DSKINFO:NBPS)+1,X
        SBCA       DSKINFO:NBPS,X
        STAA      TEMPA
        ;LDX    RDSIPOINTER     TAG SECTOR AS MODIFIED
        LDX     RDSIPOINTER
        LDAA      #1
        STAA      RDSI:MODIFIED,X
        ;LDX    RDSI:SECTORBASE,X  GET SECTOR BUFFER ADDRESS
        LDX     RDSI:SECTORBASE,X
        NEGA             GET -1 CODE TO STORE INTO HEADER SECTOR
*
*       STAASECTORL -- COPY (A) INTO SECTOR BUFFER (X)
*               (TEMPA,B) = - # BYTES TO COPY
*
STAASECTORL        ; INITZ A SECTOR BYTE
        ;STA     ,X+     FILL SECTOR WITH -1'S
        STAA      0,X
        INX
        INCB
        BNE      STAASECTORL        B/ MORE TO FILL
        ;INC     TEMPA    = UPPER HALF OF COUNTER
        INC      TEMPA
        BNE      STAASECTORL        B/ MORE TO FILL
        ;LDX    IOCBPOINTER       AS PROMISED
        LDX     IOCBPOINTER
        RTS
        PAGE
*
*       ZEROSECTOR -- ZERO OUT THE SECTOR BUFFER OF RDSIPOINTER
*       DOES NOT MARK SECTOR AS MODIFIED
*       (BECAUSE IT MIGHT BE A READ OF A SPARSE SECTOR)
*
ZEROSECTOR       EQU     *
        ;LDX    DCBPOINTER        GET NEGATIVE OF NUMBER OF BYTES PER SECTOR
        LDX     DCBPOINTER
        CLRA              = 0 - DSKINFO:NBPS
        CLRB
        ;SUBD    DSKINFO:NBPS,X
        SUBB      (DSKINFO:NBPS)+1,X
        SBCA       DSKINFO:NBPS,X
        STAA      TEMPA    SINCE (A) WILL BE BUSY WITH ZERO
        ;LDX    RDSIPOINTER     MARK SECTOR AS MODIFIED
        LDX     RDSIPOINTER
        ;LDX    RDSI:SECTORBASE,X  GET SECTOR BUFFER ADDRESS
        LDX     RDSI:SECTORBASE,X
        CLRA              MAKE A ZERO TO STORE
        BRA       STAASECTORL        AND GO STORE A SECTORFUL
*
*       ZEROCLUSTER -- ZEROS OUT CLUSTER WHOSE LCN IS IN (A,B)
*
ZEROCLUSTER      EQU     *
        ;JSR    CONVERTLCNTOLSN   AND GO FIND FIRST SECTOR OF CLUSTER !
        JSR     CONVERTLCNTOLSN
ZEROCLUSTERL     ; ZERO OUT A DATA CLUSTER LOOP
        ;LDX    IOCBPOINTER       GET SECTOR DESCRIPTOR ADDRESS
        LDX     IOCBPOINTER
        ;JSR    INVENTSECTOR     INVENT THE DATA SECTOR ADDRESS
        JSR     INVENTSECTOR
        BSR      ZEROSECTOR       GO ZERO IT!
        ;JSR    MARKMODIFIED     MARK THIS SECTOR AS MODIFIED
        JSR     MARKMODIFIED
        ;JSR    INCIOCB:CURLSN      FIND NEXT DATA SECTOR ADDRESS
        JSR     INCIOCB:CURLSN
        ;INC     IOCB:DRSN,X       BUMP RELATIVE SECTOR NUMBER WITHIN CLUSTER
        INC      IOCB:DRSN,X
        LDAA      IOCB:DRSN,X       ZEROED ALL THE SECTORS IN THE CLUSTER ?
        ;LDX    IOCB:DCB,X  ...?
        LDX     IOCB:DCB,X
        ;CMPA     DSKINFO:NSPC,X   ...?
        CMPA      DSKINFO:NSPC,X
        BNE      ZEROCLUSTERL     B/ NO, GO ZERO ANOTHER!
        OKRTS
        PAGE
*       FREECLUSTER -- FREE CLUSTER (A,B) (I.E., RESET MAP BIT)
*       ERROR EXIT IF THAT CLUSTER WAS NOT PREVIOUSLY ALLOCATED
*
FREECLUSTER      EQU     *
        ;JSR    FINDLCNMAPBIT      GO LOCATE THE MAP BIT
        JSR     FINDLCNMAPBIT
        BITA      DISKMAP:BYTE,X    DOUBLE-CHECK: WAS MAP BIT SET ?
        BEQ      FREEERROR       B/ NO, TAKE ERROR EXIT
        COMA              YES, MAKE MASK TO RESET BIT
        ANDA      DISKMAP:BYTE,X    FREE THE CLUSTER
        STAA      DISKMAP:BYTE,X
        ;JMP    MARKMODIFIED     MAKE SURE MAP SECTOR GOES BACK TO DISK
        JMP     MARKMODIFIED

FREEERROR       EQU     *
        ;JSR    ERRET   LCN WASN'T MARKED AS ALLOCATED
        JSR     ERRET
        FDB      ERR:LCNWASNTALLOCATED
*
ERRNODISKMAPJ1   EQU     *
        ;JMP    ERRNODISKMAP
        JMP     ERRNODISKMAP
*
*       FREECLUSTERS -- FREE (D) DATA CLUSTERS FROM FILE(IOCB)
*               IF (D)=0, DELETES UNTIL END OF HEADER CLUSTER ENCOUNTERED ("CHOP")
*               DELETES STARTING AT IOCB:RDCN (0 IF DELETING FILE)
*               UPDATES IOCB:NCLUSTERS
*               IF FCB:NCLUSTERS DROPS TO 0 (HLCN DEALLOCATED)
*               THEN FCB:HCSIC IS ZEROED
*               IF DELETING FILE, DOESN'T WRITE HEADER BLOCKS BACK TO DISK
*               ERRET TAKEN IF ILLEGAL LCN OR UNALLOCATED LCN SEEN
*
FREECLUSTERS     EQU     *
        ;STD    ALLOCATIONCOUNT     REMEMBER HOW MANY CLUSTERS TO DELETE
        STAB      ALLOCATIONCOUNT+1
        STAA      ALLOCATIONCOUNT
        ;LDX    DCBPOINTER        MAP FILE EXIST ?
        LDX     DCBPOINTER
        LDAA      DSKINFO:MAPFCB,X   ...?
        BEQ      ERRNODISKMAPJ1   B/ NOPE, CAN'T DEALLOCATE
FREECLUSTERL     EQU     *
        ;JSR    LOCATERDCN ALSO CHECK FOR LEGAL RDCN
        JSR     LOCATERDCN
        BCS       FREECLUSTERE     B/ OFF END OF HEADER CLUSTER!
        ;LDD    HEADER:LCN,X      GET LCN FROM HEADER SECTOR
        LDAB      (HEADER:LCN)+1,X
        LDAA      HEADER:LCN,X
        ;CMPD    #DUMMYLCN        IS LCN UNALLOCATED?
        CMPA      #(DUMMYLCN)/256
        BNE      MACRO:001F
        CMPB      #(DUMMYLCN)&$FF
MACRO:001F
        BEQ      FREECLUSTERN     B/ NEVER WAS ALLOCATED, PROCESS NEXT
        ;CLR     HEADER:LCN,X      ZAP LCN IN HEADER SECTOR
        CLR      HEADER:LCN,X
        ;DEC     HEADER:LCN,X      (I.E., SET TO DUMMYLCN (=-1))
        DEC      HEADER:LCN,X
        ;CLR     HEADER:LCN+1,X
        CLR      HEADER:LCN+1,X
        ;DEC     HEADER:LCN+1,X
        DEC      HEADER:LCN+1,X
        ;LDX    FCBPOINTER        DELETING THE FILE ?
        LDX     FCBPOINTER
        ;LDX    FCB:NCLUSTERS,X    (I.E., IS # CLUSTERS TO DELETE...
        LDX     FCB:NCLUSTERS,X
        CPX      ALLOCATIONCOUNT     = # CLUSTERS REMAINING IN FILE ?)
        BEQ      FREECLUSTER0     B/ DON'T BOTHER MOVING HEADER SECTOR BACK TO DISK
        ;LDX    IOCBPOINTER       MAKE SURE HEADER SECTOR GOES BACK TO DISK
        LDX     IOCBPOINTER
        ;LDX    IOCB:HRDSI,X
        LDX     IOCB:HRDSI,X
        ;CLR     RDSI:MODIFIED,X MARK RDSI AS MODIFIED
        CLR      RDSI:MODIFIED,X
        ;INC     RDSI:MODIFIED,X
        INC      RDSI:MODIFIED,X
FREECLUSTER0     EQU     *
        ;JSR    FREECLUSTER      GO FREE THE CLUSTER WE FOUND
        JSR     FREECLUSTER
        ;LDX    FCBPOINTER        DOWN COUNT # CLUSTERS ALLOCATED TO FILE
        LDX     FCBPOINTER
        LDAA      FCB:NCLUSTERS+1,X
        BNE      FREECLUSTER3
        ;DEC     FCB:NCLUSTERS,X
        DEC      FCB:NCLUSTERS,X
FREECLUSTER3     EQU     *
        ;DEC     FCB:NCLUSTERS+1,X
        DEC      FCB:NCLUSTERS+1,X
        LDAA      FCB:FLAGS,X        MARK FCB AS REQUIRING...
        ORAA      #FCBFLG::UPDATEDIR A DIRECTORY UPDATE
        STAA      FCB:FLAGS,X
        ;LDX    ALLOCATIONCOUNT     DOWN COUNT # CLUSTERS LEFT TO DEALLOCATE
        LDX     ALLOCATIONCOUNT
        BEQ      FREECLUSTERN     B/ 0, DELETE TILL END OF HEADER CLUSTER
        DEX
        STX     ALLOCATIONCOUNT
        BEQ      FREECLUSTERDONE  B/ DEALLOCATION COMPLETED
FREECLUSTERN     ; PROCESS NEXT CLUSTER
        ;LDX    IOCBPOINTER       COMPUTE RELATIVE CLUSTER #
        LDX     IOCBPOINTER
        ;INC     IOCB:RDCN+1,X
        INC      IOCB:RDCN+1,X
        BNE      FREECLUSTER2
        ;INC     IOCB:RDCN,X
        INC      IOCB:RDCN,X
FREECLUSTER2     EQU     *
        BRA       FREECLUSTERL     GO FREE ANOTHER CLUSTER
        PAGE
FREECLUSTERE     ; ERROR ENCOUNTERED
        ;LDD    ALLOCATIONCOUNT     DELETEING TILL END OF HEADER CLUSTER ?
        LDAB      ALLOCATIONCOUNT+1
        LDAA      ALLOCATIONCOUNT
        ;BNED    FREECLUSTERE1    B/ NO, WE GOOFED SOMEHOW!
        BNE      FREECLUSTERE1
        TSTB
        BNE      FREECLUSTERE1
        CPX      #ERR:HCSICTOOSMALL YES, VALID REASON TO QUIT?
        BEQ      FREECLUSTERDONE  B/ YES
        CPX      #ERR:CLUSTERSIZELIMITSFILE       A DIFFERENT, BUT ALSO VALID REASON?
        BEQ      FREECLUSTERDONE  B/ YES
FREECLUSTERE1 ; FATAL ERROR IN FREE CLUSTER
        ;JMP    ERRORED
        JMP     ERRORED

FREECLUSTERDONE  EQU     *
        ;LDX    FCBPOINTER
        LDX     FCBPOINTER
        IF      M6800
        LDAA      FCB:NCLUSTERS,X    IS NCLUSTERS = 0?
        ORAA      FCB:NCLUSTERS+1,X
        ELSE    (M6801!M6809)
        ;LDD    FCB:NCLUSTERS,X    IS NCLUSTERS = 0 ?
        LDAB      (FCB:NCLUSTERS)+1,X
        LDAA      FCB:NCLUSTERS,X
        FIN
        BNE      FREECLUSTEREXIT  B/ NO, FILE JUST SMALLER
        STAA      FCB:HCSIC,X YES, ZAP :HCSIC
FREECLUSTEREXIT  EQU     *
        OKRTS
*       SEARCHMAP -- SEARCHES DISK MAP FOR ALLOCATIONCOUNT CONTIGUOUS CLUSTERS
*               STARTS WITH FORWARD SEARCH FROM LCN(A,B)
*               IF LCN(A,B) = :FFFF, CHOOSES RANDOM PLACE IN MAP
*               SEARCHES FOR CONTIGUOUS AREA OF ALLOCATIONCOUNT CLUSTERS
*               USES 1ST FREE CLUSTER FOUND IF ALLOCATION SPACE NOT AVAILABLE
*               QUITS IF FIRST FREE CLUSTER = 1 UNIT FORWARD FROM LCN(A,B)
*               IF FREE GROUP FOUND, FINDS BEGINNING OF GROUP
*               THEN TRIES BACKWARD SEARCH
*               ALSO RECORDS 1ST FREE CLUSTER IF CLOSER THAN FWD SEARCH POINT
*               UPDATES DISKMAP BY SETTING THE CORRESPONDING BIT
*               USES IOCB SELECTED BY IOCBPOINTER; DCB SELECTED BY DCBPOINTER
*       OKRTS: RETURNS ALLOCATED LCN IN (A,B); UPDATES MAP
*       ERRET: NO DISK BLOCK AVAILABLE
*
SEARCHMAP  EQU     *
        ;STD    DESIREDLCN       SAVE # OF (DESIRED LCN -1)
        STAB      DESIREDLCN+1
        STAA      DESIREDLCN
        ;LDX    #DUMMYLCN        SET BEST DISCOVERED LCN TO "DUMMY"
        LDX     #DUMMYLCN
        STX     AVAILABLELCN
        CPX      DESIREDLCN       IS (A,B) = DUMMYLCN ?
        BNE      SEARCHMAP1 (UNALLOCATED LCN AS START POINT?)
        ;LDX    DCBPOINTER        YES, CHOOSE "RANDOM" POINT IN MAP
        LDX     DCBPOINTER
        ;LDD    DSKINFO:RANDMAP,X = LAST PLACE WE FOUND SOME FREE SPACE
        LDAB      (DSKINFO:RANDMAP)+1,X
        LDAA      DSKINFO:RANDMAP,X
SEARCHMAP1 EQU     *
        ;STD    SEARCHLCN  REMEMBER SEARCH STARTING POINT
        STAB      SEARCHLCN+1
        STAA      SEARCHLCN
SEARCHM5  EQU     *
        ;LDD    SEARCHLCN  GET DESIRED START POINT
        LDAB      SEARCHLCN+1
        LDAA      SEARCHLCN
        ;JSR    FINDLCNMAPBIT
        JSR     FINDLCNMAPBIT
SEARCHM2  EQU     *
        BITA      DISKMAP:BYTE,X    ARE WE IN MIDDLE OF GROUP OF FREE CLUSTERS?
        BNE      SEARCHMF  B/ NO, START FORWARD SEARCH
        LDAB      SEARCHLCN+1        MUST SCAN BACKWARDS TO BEGINNING OF GROUP
        BNE      SEARCHM3  BACK UP LCN WE'RE LOOKING AT
        ;DEC     SEARCHLCN  DON'T YOU HATE DBL PRECISION DECREMENTS?
        DEC      SEARCHLCN
SEARCHM3  EQU     *
        ;DEC     SEARCHLCN+1
        DEC      SEARCHLCN+1
        LSRA             MOVE BIT MASK DOWN
        BCC        SEARCHM2  B/ NOT ALL BITS IN DISKMAP BYTE PROCESSED
SEARCHM4  ; ASSERT: SEARCHLCN MOD 8 = 7 HERE
        DEX             BACK UP THE BYTE POINTER
        CPX      DISKMAPSECTORSTART WILL WE RUN OFF BOTTOM OF MAP SECTOR?
        BEQ      SEARCHM5  B/ YEP, TIME TO READ ANOTHER MAP SECTOR
        LDAA      #$80    BE OPTIMISTIC, GET NEW MASK
        LDAB      DISKMAP:BYTE,X    DO QUICK CHECK ON MAP BYTE
        BNE      SEARCHM2  B/ WE'LL FIND AN ALLOCATED CLUSTER
        ;LDD    SEARCHLCN  SKIP UNALLOCATED CLUSTERS
        LDAB      SEARCHLCN+1
        LDAA      SEARCHLCN
*       *** ASSUMES LCN 0 ALWAYS ALLOCATED!
        ;SUBD    #NMBPB    NUMBER OF MAP BITS PER BYTE
        SUBB      #(NMBPB)&$FF
        SBCA       #(NMBPB)/256
        ;STD    SEARCHLCN  UPDATE NEXT LCN TO LOOK AT
        STAB      SEARCHLCN+1
        STAA      SEARCHLCN
        ;JMP    SEARCHM4  A SPEEDUP IS SPOSD TO BE FAST!
        JMP     SEARCHM4

SEARCHMFQJ1       EQU     *
        ;JMP    SEARCHMFQ
        JMP     SEARCHMFQ
        PAGE
SEARCHMFE ; EXHAUSTED MAP BYTE WHILE LOOKING FOR FREE LCN
        LDAA      #1      GET MASK FOR NEXT LCN TO CHECK
        INX             BUMP MAP BYTE POINTER
        CPX      DISKMAPSECTOREND  RUN OFF END OF MAP SECTOR?
        BEQ      SEARCHMFE1        B/ YES
SEARCHMFE2        EQU     *
        LDAB      DISKMAP:BYTE,X    NO, CHECK WHOLE MAP BYTE...
        INCB              TO SEE IF ALL ENTRIES IN IT ARE ALLOCATED
        BNE      SEARCHMF1A B/ NOPE, SEARCH MAP BYTE THE HARD WAY
        LDAB      SEARCHLCN+1        ENTIRE BYTE IS ALLOCATED
        ADDB      #NMBPB    SKIP SEARCHLCN FORWARD THAT MANY LCN'S
        STAB      SEARCHLCN+1
        BNE      SEARCHMFE AND GO CHECK NEXT MAP BYTE
        ;INC     SEARCHLCN  (PROPOGATE CARRY TO UPPER HALF)
        INC      SEARCHLCN
        BRA       SEARCHMFE

SEARCHMFE1        ; RAN OFF END OF MAP SECTOR LOOKING FOR FREE LCN
        ;LDD    SEARCHLCN  GO FIND THE MAP SECTOR...
        LDAB      SEARCHLCN+1
        LDAA      SEARCHLCN
        ;JSR    FINDLCNMAPBIT      WHICH CONTAINS THE BIT WE WANT
        JSR     FINDLCNMAPBIT
        BCS       SEARCHMFQJ1       OOPS, RAN OFF END OF MAP
        ;LDX    IOCBPOINTER       INITIATE READ-AHEAD OF NEXT MAP SECTOR
        LDX     IOCBPOINTER
        ;JSR    READAHEAD
        JSR     READAHEAD
        ;LDX    DISKMAPBYTEPOINTER        GET POINTER TO MAP BYTE
        LDX     DISKMAPBYTEPOINTER
        LDAA      DISKMAPMASK       AND BIT MASK FOR MAP BIT
        BRA       SEARCHMFE2        GO CHECK BYTE CONTENTS

SEARCHMFQXITJ1    EQU     *
        ;JMP    SEARCHMFQXIT
        JMP     SEARCHMFQXIT
        PAGE
SEARCHMF  ; NOW START FORWARD MAP SEARCH
        LDAB      SEARCHLCN  REMEMBER DIVIDING POINT IN MAP...
        STAB      DIVIDEPOINTLCN   SO WE CAN START BACKWARDS SEARCH LATER
        LDAB      SEARCHLCN+1
        STAB      DIVIDEPOINTLCN+1
SEARCHMF0 EQU     *
        ;INC     SEARCHLCN+1        BUMP LCN WE'RE ABOUT TO LOOK AT
        INC      SEARCHLCN+1
        BNE      SEARCHMF1
        ;INC     SEARCHLCN
        INC      SEARCHLCN
SEARCHMF1 ; LOOK AT NEXT BIT IN BIT MAP
        ASLA              SWITCH BIT MASK'S ATTN TO PROPER BIT
        BCS       SEARCHMFE B/ EXHAUSTED BYTE
SEARCHMF1A EQU     *
        BITA      DISKMAP:BYTE,X    IS THIS LCN ALSO ALLOCATED?
        BNE      SEARCHMF0 B/ YES, SKIP OVER IT
        STX     DISKMAPBYTEPOINTER        SAVE MAP BYTE ADDRESS
        ;LDX    AVAILABLELCN FOUND A FREE CLUSTER!
        LDX     AVAILABLELCN
        INX             SEE IF ANOTHER HAS ALREADY BEEN FOUND
        BNE      SEARCHMF4 B/ YES, DON'T RECORD THIS ONE
        ;LDX    SEARCHLCN  NO, SAVE LCN IN CASE...
        LDX     SEARCHLCN
        STX     AVAILABLELCN WE CAN'T FIND CONTIGUOUS ALLOCATION
        ;LDX    #1      SET GROUPSIZE TO 1
        LDX     #1
        STX     AVAILABLECOUNT
        LDAB      SEARCHLCN+1        IS JUST-FOUND CLUSTER...
        SEC              = DESIRED CLUSTER + 1 ?
        SBCB       DESIREDLCN+1     (I.E., IS SEARCHLCN-DESIREDLCN=1?)
        BNE      SEARCHMF4 B/ NO
        LDAB      SEARCHLCN  (I.E. IS SEARCHLCN-DESIREDLCN-1=0?)
        SBCB       DESIREDLCN       ...?
        BEQ      SEARCHMFQXITJ1    B/ YES, TAKE QUICK EXIT
        PAGE
SEARCHMF4 EQU     *
        ;LDX    DISKMAPBYTEPOINTER        GET ADDRESS OF MAP BYTE CONTAINING FREE CLUSTER
        LDX     DISKMAPBYTEPOINTER
        ;CLR     LCNGROUPLENGTH   FIND OUT HOW LONG...
        CLR      LCNGROUPLENGTH
        ;CLR     LCNGROUPLENGTH+1 THE GROUP OF FREE LCN'S IS
        CLR      LCNGROUPLENGTH+1
SEARCHMF2 EQU     *
        ;INC     LCNGROUPLENGTH+1 BUMP LENGTH OF FREE GROUP OF LCNS
        INC      LCNGROUPLENGTH+1
        BNE      SEARCHMF3
        ;INC     LCNGROUPLENGTH
        INC      LCNGROUPLENGTH
SEARCHMF3 ; LOOK AT NEXT BIT
        LDAB      LCNGROUPLENGTH   IS SIZE OF THIS FREE GROUP...
        ;CMPB     ALLOCATIONCOUNT     >= TO ALLOCATION COUNT?
        CMPB      ALLOCATIONCOUNT
        BCS       SEARCHMF5 B/ NO (ELSE MUST BE EQUAL!)
        LDAB      LCNGROUPLENGTH+1 = COMPARE IS SUFFICIENT, SINCE...
        ;CMPB     ALLOCATIONCOUNT+1   LCN GROUPLENGTH IS MONOTONICALLY INCREASING
        CMPB      ALLOCATIONCOUNT+1
        BEQ      SEARCHMFG AND WAS < ALLOCATION COUNT LAST TIME WE CHECKED
SEARCHMF5 EQU     *
        ;INC     SEARCHLCN+1        BUMP LCN TO LOOK AT
        INC      SEARCHLCN+1
        BNE      SEARCHMF6 B/ EXHAUSTED MAP BYTE
        ;INC     SEARCHLCN  BUMP LCN WE'LL BE LOOKING AT
        INC      SEARCHLCN
SEARCHMF6 EQU     *
        ASLA              SHIFT BIT MASK OVER
        BCS       SEARCHMF8 B/ EXHAUSTED MAP BYTE
SEARCHMF7 EQU     *
        BITA      DISKMAP:BYTE,X    LOOK AT NEXT LCN BIT
        BEQ      SEARCHMF2 B/ ITS FREE, COUNT IT
        BRA       SEARCHMF0 FREE GROUP NOT LONG ENOUGH TO USE
        PAGE
SEARCHMF8 ; EXHAUSTED MAP BYTE WHILE SCANNING FREE GROUP OF LCN'S
        LDAA      #1      GET MASK FOR MAP BIT IN NEXT BYTE
        INX             BUMP MAP BYTE POITER
        CPX      DISKMAPSECTOREND  EXHAUST MAP SECTOR?
        BNE      SEARCHMF7 B/ NO, KEEP SEARCHING
        ;LDD    SEARCHLCN  DISK MAP SECTOR EXHAUSTED, GET NEXT LCN TO CHECK
        LDAB      SEARCHLCN+1
        LDAA      SEARCHLCN
        ;JSR    FINDLCNMAPBIT      SET UP TO SEARCH NEXT MAP SECTOR
        JSR     FINDLCNMAPBIT
        BCS       SEARCHMFQ QUIT IF WE RUN OFF END OF MAP
        ;LDX    IOCBPOINTER       INITIATE PRE-FETCH...
        LDX     IOCBPOINTER
        ;JSR    READAHEAD  OF NEXT MAP SECTOR
        JSR     READAHEAD
        ;LDX    DISKMAPBYTEPOINTER        GET POINTER TO MAP BYTE...
        LDX     DISKMAPBYTEPOINTER
        LDAA      DISKMAPMASK       AND BIT MASK
        BRA       SEARCHMF7 GO CHECK BIT TO SEE IF FREE

SEARCHMFG ; FORWARD SEARCH FOUND ALLOCATION COUNT FREE CLUSTERS
        ;LDD    LCNGROUPLENGTH   RECORD SIZE OF FREE GROUP OF LCN'S
        LDAB      LCNGROUPLENGTH+1
        LDAA      LCNGROUPLENGTH
        ;STD    AVAILABLECOUNT
        STAB      AVAILABLECOUNT+1
        STAA      AVAILABLECOUNT
        ;COMD            COMPUTE LCN OF FIRST LCN IN THIS FREE GROUP
        COMB
        COMA
        ;ADDD    SEARCHLCN  = LCN OF CLUSTER TERMINATING GROUP
        ADDB      SEARCHLCN+1
        ADCA       SEARCHLCN
        ;ADDD    #2      - SIZE OF GROUP +1 = COMPLEMENT(GROUPLENGTH) + 2
        ADDB      #(2)&$FF
        ADCA       #(2)/256
        ;STD    AVAILABLELCN REMEMBER WHERE THE GROUP STARTS
        STAB      AVAILABLELCN+1
        STAA      AVAILABLELCN
SEARCHMFQ ; QUIT FORWARD SEARCH
        ;LDD    DIVIDEPOINTLCN   START BACKWARDS SEARCH...
        LDAB      DIVIDEPOINTLCN+1
        LDAA      DIVIDEPOINTLCN
        ;STD    SEARCHLCN  AT DIVIDING POINT IN MAP
        STAB      SEARCHLCN+1
        STAA      SEARCHLCN
        ;JSR    FINDLCNMAPBIT
        JSR     FINDLCNMAPBIT
        PAGE
        ;JSR    READBEHIND        INITIATE THE READ BEHIND
        JSR     READBEHIND
        ;LDX    DISKMAPBYTEPOINTER        GET MAP BYTE POINTER AND MASK
        LDX     DISKMAPBYTEPOINTER
        LDAA      DISKMAPMASK
SEARCHMR  EQU     *
        BITA      DISKMAP:BYTE,X    SCAN MAP BACKWARDS FOR FREE LCN
        BEQ      SEARCHMR1 B/ FOUND FREE LCN
SEARCHMR0 EQU     *
        LDAB      SEARCHLCN+1        THIS LCN NOT FREE
        BNE      SEARCHMR0A COMPUTE PREVIOUS LCN
        ;DEC     SEARCHLCN
        DEC      SEARCHLCN
SEARCHMR0A EQU     *
        ;DEC     SEARCHLCN+1
        DEC      SEARCHLCN+1
        LSRA             ADJUST BIT MASK FOR PREVIOUS LCN
        BCC        SEARCHMR  B/ MORE BITS TO CHECK IN MAP
SEARCHMRE EQU     *
        DEX             PROCESS PREVIOUS MAP BYTE
        CPX      DISKMAPSECTORSTART HIT BOTTOM OF MAP SECTOR?
        BEQ      SEARCHMRE1        B/ YES, MUST PROCESS PRECEDING SECTOR
SEARCHMRE2        EQU     *
        LDAA      #$80    SET UP MASK FOR NEXT MAP BYTE
        LDAB      DISKMAP:BYTE,X    TAKE QUICK LOOK AT ENTIRE BYTE
        INCB              ALL LCN'S IN BYTE ALLOCATED?
        BNE      SEARCHMR  B/ NO, LET'S GO FIND UNALLOCATED LCN
        LDAB      SEARCHLCN+1        YES, BACK UP OVER BYTE OF LCN'S
        ;CMPB     #NMBPB-1  NEED TO PROPOGATE A BORROW ?
        CMPB      #NMBPB-1
        BNE      SEARCHMRE3        ADJUST SEARCHLCN
        ;DEC     SEARCHLCN
        DEC      SEARCHLCN
SEARCHMRE3        EQU     *
        SUBB      #NMBPB
        STAB      SEARCHLCN+1
        ;JMP    SEARCHMRE CHECK NEXT MAP BYTE OUT
        JMP     SEARCHMRE
        PAGE
SEARCHMRE1        ; RAN OFF BOTTOM OF MAP SECTOR
        ;LDD    SEARCHLCN  GO FIND MAP SECTOR CONTAINING PREVIOUS BYTE
        LDAB      SEARCHLCN+1
        LDAA      SEARCHLCN
        ;JSR    FINDLCNMAPBIT
        JSR     FINDLCNMAPBIT
        BCS       SEARCHMREBJ1       B/ RAN OFF BOTTOM OF MAP
        ;JSR    READBEHIND        KEEP THE READ BEHIND RUNNING
        JSR     READBEHIND
        ;LDX    DISKMAPBYTEPOINTER        GET MAP BYTE POITER...
        LDX     DISKMAPBYTEPOINTER
        LDAA      DISKMAPMASK       AND MASK
        BRA       SEARCHMRE2

SEARCHMREBJ1       EQU     *
        ;JMP    SEARCHMREB
        JMP     SEARCHMREB
        PAGE
SEARCHMR1 ; FOUND FREE LCN DURING BACKWARDS SEARCH
        STX     DISKMAPBYTEPOINTER        SAVE ADDRESS OF MAP BYTE CONTAINING FREE CLUSTER
        ;LDX    AVAILABLELCN EFFECTIVELY THE SAME CODE AS SEARCHMF
        LDX     AVAILABLELCN
        INX             HAVE WE ALREADY FOUND A FREE CLUSTER ?
        BEQ      SEARCHMR4C B/ NO, RETAIN JUST-FOUND LCN
        ;LDX    AVAILABLECOUNT       FOUND FREE LCN, AVAILABLE LCN IS TAKEN
        LDX     AVAILABLECOUNT
        INX             IS IT TAKEN BY A FIRST FREE LCN FOUND ?
        BNE      SEARCHMR4 B/ AVAILABLELCN TAKEN BY ALLOCATIONCOUNT GROUP
*                       (WHICH MEANS A SINGLE FREE LCN DOESN'T OVERRIDE IT)
        PSHA             DON'T LOSE MAP MASK!
        ;JSR    SEARCHOOSE        DECIDE WHICH LCN IS CLOSEST
        JSR     SEARCHOOSE
        PULA             GET MAP MASK BACK
        BCS       SEARCHMR4 B/ AVAILABLELCN WAS CLOSEST
SEARCHMR4C EQU     *
        ;LDX    SEARCHLCN  RETAIN JUST-FOUND CLUSTER
        LDX     SEARCHLCN
        STX     AVAILABLELCN
        ;LDX    #1      SET GROUP SIZE TO "1"
        LDX     #1
        STX     AVAILABLECOUNT
SEARCHMR4 EQU     *
        ;LDX    #0      FIND OUT HOW LONG THIS GROUP OF FREE CLUSTERS IS
        LDX     #0
        STX     LCNGROUPLENGTH
        ;LDX    DISKMAPBYTEPOINTER        GET POINTER TO MAP BYTE BACK
        LDX     DISKMAPBYTEPOINTER
SEARCHMR2 EQU     *
        ;INC     LCNGROUPLENGTH+1
        INC      LCNGROUPLENGTH+1
        BNE      SEARCHMR3
        ;INC     LCNGROUPLENGTH
        INC      LCNGROUPLENGTH
SEARCHMR3 EQU     *
        LDAB      LCNGROUPLENGTH
        ;CMPB     ALLOCATIONCOUNT
        CMPB      ALLOCATIONCOUNT
        BCS       SEARCHMR5
        BHI      SEARCHMRG
        LDAB      LCNGROUPLENGTH+1
        ;CMPB     ALLOCATIONCOUNT+1
        CMPB      ALLOCATIONCOUNT+1
        BEQ      SEARCHMRG *** NOTE: ASSUMES LCN 0 IS ALWAYS ALLOCATED ***
SEARCHMR5 EQU     *
        LDAB      SEARCHLCN+1        DECREMENT POSITION IN MAP
        BNE      SEARCHMR6 B/ DON'T HAVE TO DECREMENT UPPER HALF
        ;DEC     SEARCHLCN
        DEC      SEARCHLCN
SEARCHMR6 EQU     *
        ;DEC     SEARCHLCN+1
        DEC      SEARCHLCN+1
        LSRA
        BCS       SEARCHMR8
SEARCHMR7 EQU     *
        BITA      DISKMAP:BYTE,X
        BEQ      SEARCHMR2
        ;JMP    SEARCHMR0
        JMP     SEARCHMR0
        PAGE
SEARCHMR8 ; RAN OFF END OF BYTE
        LDAA      #$80    PICK UP MASK FOR NEXT BYTE
        DEX             BACK UP POINTER
        CPX      DISKMAPSECTORSTART HIT BEGIN SECTOR ?
        BNE      SEARCHMR7 B/ NO, GO PROCESS BYTE
        ;LDD    SEARCHLCN  YES, MUST PROCESS PREVIOUS SECTOR
        LDAB      SEARCHLCN+1
        LDAA      SEARCHLCN
        ;JSR    FINDLCNMAPBIT      GO FIND IT
        JSR     FINDLCNMAPBIT
        BCS       SEARCHMREB OOPS...
        ;LDX    IOCBPOINTER       INITIATE READ-BEHIND
        LDX     IOCBPOINTER
        ;JSR    READBEHIND
        JSR     READBEHIND
        ;LDX    DISKMAPBYTEPOINTER        RESTORE BIT MASK
        LDX     DISKMAPBYTEPOINTER
        LDAA      DISKMAPMASK       AND MAP BYTE ADDRESS
        BRA       SEARCHMR7 GO PROCESS NEXT BYTE

SEARCHMRG ; FOUND ALLOCATION COUNT FREE CLUSTERS
        ;LDX    AVAILABLELCN ON BACKWARDS SEARCH
        LDX     AVAILABLELCN
        INX             FIRST DECIDE IF ANY ALLOCATION FOUND YET
        BEQ      SEARCHUS  B/ NO DISK SPACE FOUND PREVIOUSLY
        ;LDX    AVAILABLECOUNT       IF AVAILABLE COUNT = ALLOCATION COUNT,
        LDX     AVAILABLECOUNT
        CPX      ALLOCATIONCOUNT     THEN CHOOSE CLOSEST FREE GROUP
        BNE      SEARCHUS  ELSE USE JUST FOUND FREE GROUP
        BSR      SEARCHOOSE        CHOOSE CLOSER OF (SEARCHLCN,AVAILABLELCN)
        BCC        SEARCHFLCN AVAILABLELCN WAS CLOSER
SEARCHUS  ; USE SEARCHLCN AS RESULT
        ;LDD    SEARCHLCN  COPY TO AVAILABLELCN
        LDAB      SEARCHLCN+1
        LDAA      SEARCHLCN
        ;STD    AVAILABLELCN
        STAB      AVAILABLELCN+1
        STAA      AVAILABLELCN
SEARCHFLCN ; FOUND AVAILABLE LCN IN MAP
        ;LDD    AVAILABLELCN LOCATE IT AGAIN SINCE IT IS PROBABLY NOT...
        LDAB      AVAILABLELCN+1
        LDAA      AVAILABLELCN
        ;JSR    FINDLCNMAPBIT      IN CURRENT MAP BLOCK
        JSR     FINDLCNMAPBIT
SEARCHMFQXIT      ; QUICK EXIT
        ;LDX    DISKMAPBYTEPOINTER        GET POINTER TO MAP BYTE BACK
        LDX     DISKMAPBYTEPOINTER
        ORAA      DISKMAP:BYTE,X    SET BIT IN MAP...
        STAA      DISKMAP:BYTE,X    MARKING SECTOR AS ALLOCATED
        ;LDX    IOCBPOINTER       TAG SECTOR AS MODIFIED
        LDX     IOCBPOINTER
        ;LDX    IOCB:DRDSI,X      GET RDSI OF THIS MAP SECTOR
        LDX     IOCB:DRDSI,X
        STAA      RDSI:MODIFIED,X SINCE READAHEAD BOMBED RDSIPOINTER (A<>0)
        ;LDD    AVAILABLELCN AND RETURN THE LCN ALLOCATED
        LDAB      AVAILABLELCN+1
        LDAA      AVAILABLELCN
        OKRTS

SEARCHMREB ; BOTTOM OF MAP HIT
        CPX      #ERR:ILLEGALLCN   DOUBLE CHECK TO MAKE SURE
        BNE      SEARCHMERRED3     B/ WASN'T BOTTOM OF MAP!!?
        ;LDX    AVAILABLELCN ANY AVAILABLE LCN FOUND ?
        LDX     AVAILABLELCN
        INX             ...?
        BNE      SEARCHFLCN B/ YES, TAKE SUCCESS EXIT
        ;JSR    ERRET   NO, NO DISK SPACE AVAILABLE
        JSR     ERRET
        FDB      ERR:NODISKSPACE

SEARCHMERRED3     EQU     *
        ;JMP    ERRORED
        JMP     ERRORED
        PAGE
*
*       SEARCHOOSE -- DECIDE WHETHER AVAILABLELCN OR SEARCHLCN...
*               IS CLOSEST TO DIVIDEPOINTLCN
*               RETURN CARRY RESET IF AVAILABLELCN IS THE ONE TO KEEP
*
SEARCHOOSE        EQU     *
        ;LDD    DIVIDEPOINTLCN   IS ABS(DIVIDEPOINTLCN-AVAILABLELCN)
        LDAB      DIVIDEPOINTLCN+1
        LDAA      DIVIDEPOINTLCN
        ;SUBD    AVAILABLELCN > ABS(DIVIDEPOINTLCN-SEARCHLCN)?
        SUBB      AVAILABLELCN+1
        SBCA       AVAILABLELCN
        BCC        SEARCHOOSE1
        ;NEGD           (TAKE -(A,B) TO GET ABS VALUE)
        NEGA
        NEGB
        SBCA       #0
SEARCHOOSE1       EQU     *
        ;STD    TEMPX   SAVE ABS(DIVIDEPOINTLCN-AVAILABLELCN)
        STAB      TEMPX+1
        STAA      TEMPX
        ;LDD    DIVIDEPOINTLCN   (COMPUTE ABS(DIVIDEPOINTLCN-SEARCHLCN))
        LDAB      DIVIDEPOINTLCN+1
        LDAA      DIVIDEPOINTLCN
        ;SUBD    SEARCHLCN
        SUBB      SEARCHLCN+1
        SBCA       SEARCHLCN
        BCC        SEARCHOOSE2       B/ ITS ALREADY NEGATIVE
        ;NEGD           COMPUTE ABS(A,B)
        NEGA
        NEGB
        SBCA       #0
SEARCHOOSE2       EQU     *
        ;SUBD    TEMPX   = ABS(DIVIDEPOINTLCN-AVAILABLELCN)...
        SUBB      TEMPX+1
        SBCA       TEMPX
        RTS             -ABS(DIVIDEPOINTLCN-SEARCHLCN)

FINDLCNERREXIT   EQU     *
        ;JSR    ERRET   ILLEGAL LCN
        JSR     ERRET
        FDB      ERR:ILLEGALLCN
        PAGE
*       FINDLCNMAPBIT -- TAKES (D) AS LCN IN DISKMAP
*               RETURNS VIA ERRET IF ILLEGAL LCN
*               COMPUTES DESIRED LSN OF MAP, READS IT IN
*               RETURNS BYTE POINTER IN (X) AND BIT MASK IN (A) FOR LCN
*               ASSUMES IOCBPOINTER SET UP TO PROCESS MAP CLUSTER
*               SETS UP DISKMAPSECTORSTART TO BEGINNING OF BUFFER-1
*               SETS UP DISKMAPSECTOREND TO END OF BUFFER
*               RETURNS RDSIPOINTER, IOCB:RDSI POINTING TO MAP SECTOR
*
FINDLCNMAPBIT      EQU     *
        ;LDX    DCBPOINTER        CHECK LCN(A,B)...
        LDX     DCBPOINTER
        ;CMPD    DSKINFO:NLCN,X   TO MAKE SURE ITS LEGAL
        CMPA      DSKINFO:NLCN,X
        BNE      MACRO:0020
        CMPB      (DSKINFO:NLCN)+1,X
MACRO:0020
        BCC        FINDLCNERREXIT   B/ ILLEGAL LCN
        STAB      DISKMAPMASK       SAVE BIT NUMBER DESIRED
        ;LSRD           SHIFT OFF BIT NUMBER...
        LSRA
        RORB
        ;LSRD           TO GET BYTE ADDRESS WITHIN DISK MAP
        LSRA
        RORB
        ;LSRD
        LSRA
        RORB
        ;STD    DISKMAPBYTEPOINTER        SAVE BYTE NUMBER DESIRED
        STAB      DISKMAPBYTEPOINTER+1
        STAA      DISKMAPBYTEPOINTER
        ;JSR    COMPUTERSN       COMPUTE RELATIVE SECTOR NUMBER
        JSR     COMPUTERSN
        STAB      IOCB:DRSN,X       SAVE RELATIVE SECTOR # WITHIN MAP CLUSTER
        ;LDX    DCBPOINTER        COMPUTE LSN OF DESIRED MAP FILE SECTOR
        LDX     DCBPOINTER
        ADDB      DSKINFO:MAPLSN+2,X       = LSN(MAP CLUSTER)+RSN
        PSHB             (THIS IS VALID BECUZ ALLOC CHECKS ON ENTRY)
        ;LDD    DSKINFO:MAPLSN,X
        LDAB      (DSKINFO:MAPLSN)+1,X
        LDAA      DSKINFO:MAPLSN,X
        ADCB       #0      PROPOGATE ANY CARRY
        ADCA       #0
        ;LDX    IOCBPOINTER       STORE DESIRED LSN INTO IOCB
        LDX     IOCBPOINTER
        ;STD    IOCB:CURLSN,X
        STAB      (IOCB:CURLSN)+1,X
        STAA      IOCB:CURLSN,X
        PULA
        STAA      IOCB:CURLSN+2,X
        ;JSR    READSECTOR        AND GO GET MAP SECTOR
        JSR     READSECTOR
        ;LDX    IOCBPOINTER       REMEMBER RDSI FOR MAP SECTOR
        LDX     IOCBPOINTER
        ;STD    IOCB:DRDSI,X      SINCE READAHEAD WILL DESTROY RDSIPOINTER
        STAB      (IOCB:DRDSI)+1,X
        STAA      IOCB:DRDSI,X
        ;LDD    DISKMAPBYTEPOINTER        GET BYTE NUMBER DESIRED BACK
        LDAB      DISKMAPBYTEPOINTER+1
        LDAA      DISKMAPBYTEPOINTER
        ;LDX    DCBPOINTER        NOW MASK BYTE NUMBER...
        LDX     DCBPOINTER
        ANDA      DSKINFO:NBPSM1,X TO GET DESIRED BYTE DISPLACMENT INTO MAP SECTOR
        ANDB      DSKINFO:NBPSM1+1,X
        ;LDX    RDSIPOINTER     ADD SECTOR BUFFER BASE...
        LDX     RDSIPOINTER
        ;ADDD    RDSI:SECTORBASE,X  TO GET REAL POINTER TO MAP BYTE
        ADDB      (RDSI:SECTORBASE)+1,X
        ADCA       RDSI:SECTORBASE,X
        ;STD    DISKMAPBYTEPOINTER
        STAB      DISKMAPBYTEPOINTER+1
        STAA      DISKMAPBYTEPOINTER
        ;LDX    RDSI:SECTORBASE,X  COMPUTE START AND END OF
        LDX     RDSI:SECTORBASE,X
        DEX             AS A CONVENIENCE TO SEARCHMAP
        STX     DISKMAPSECTORSTART DISK BUFFERS FOR THIS BLOCK
        ;LDX    DCBPOINTER
        LDX     DCBPOINTER
        ;LDD    DSKINFO:NBPS,X
        LDAB      (DSKINFO:NBPS)+1,X
        LDAA      DSKINFO:NBPS,X
        SEC              TO OFFSET THE "DEX"
        ADCB       DISKMAPSECTORSTART+1
        ADCA       DISKMAPSECTORSTART
        ;STD    DISKMAPSECTOREND
        STAB      DISKMAPSECTOREND+1
        STAA      DISKMAPSECTOREND
        LDAB      DISKMAPMASK       GET DESIRED BIT # BACK
        ANDB      #NMBPB-1  TAKE MODULO # BITS PER MAP BYTE
        CLRA              CONVERT INTO A BIT MASK
        SEC
FINDLCNMAPBITL     EQU     *
        ROLA             BY SHIFTING
        DECB
        BPL      FINDLCNMAPBITL
        STAA      DISKMAPMASK
        ;JSR    WAITRDSI WAIT FOR MAP SECTOR TO ARRIVE
        JSR     WAITRDSI
        LDAA      DISKMAPMASK       GET BIT MASK FOR DISKMAP.SYS BYTE
        ;LDX    DISKMAPBYTEPOINTER        GET POINTER TO MAP BYTE
        LDX     DISKMAPBYTEPOINTER
        OKRTS
        PAGE     DISK FILE DRIVERS -- SUBROUTINES
*       LOCATECURBYTE -- PROCESSES IOCB:CURBYTE
*       TO SET UP VALUE FOR IOCB:CURLSN
*       ALSO SETS UP IOCB:FILESIZE, IOCB:BYTECOUNT, IOCB:CURLCN, IOCB:RSN
*       ASSUMES THAT IOCB:CURLCN IS VALID
*       ZEROS IOCB:DRDSI UNLESS BYTE IS IN LSN SELECTED BY RDSI
*       ASSUMES THAT IOCBPOINTER, DCBPOINTER ARE SET UP
*       (A,B) CONTAIN # BYTES REQUESTED FOR TRANSFER ON ENTRY
*       RETURNS VIA OKRTS:
*               IOCB:CURLCN<>-1 --> LOCATED BYTE
*               IOCB:CURLCN=-1  --> CLUSTER FOR BYTE NOT ALLOCATED
*               USEDCOUNT = # BYTES AVAILABLE TO BE MOVED
*               ( 0 < USEDCOUNT <= REQUESTED )
*               USEDCOUNT MUST BE ADJUSTED IF ALL THE BYTES ARE NOT USED
*               (X) = IOCBPOINTER
*       RETURN VIA ERRET:
*               DISK SPACE EXHAUSTED ON WRITE ATTEMPT
*       LOCATECURBYTE ENSURES DESIRED SECTOR IS BROUGHT INTO MEMORY
*       IF WRITEFLAG=0 (READ MODE) AND NON-EXISTENT DATA CLUSTER IS ENCOUNTERED,
*       AN IMAGINARY SECTOR IS ZEROED AND USED
*       NOBODY MAY MODIFY THIS IMAGINARY SECTOR!!!
*       IF WRITEFLAG<>0, AND LOCATE IS DIRECTED TO
*       BYTE BEYOND CURRENT LENGTH OF FILE, THEN
*       A ZEROED SECTOR IS INVENTED

LOCATECURBYTE       EQU     *
        ;STD    USEDCOUNT        STORE # BYTES REQUESTED FOR THIS TRANSFER
        STAB      USEDCOUNT+1
        STAA      USEDCOUNT
        ;LDX    IOCBPOINTER       LOCATE ALREADY DONE ?
        LDX     IOCBPOINTER
        LDAA      IOCB:LOCATEDF,X     ...?
        BEQ      LOCATECURBYTE0      B/ NO, GO DO IT IN ALL OF ITS GLORY
        ;LDX    IOCB:BYTECOUNT,X    ANY BYTES REMAINING TO BE PROCESSED ?
        LDX     IOCB:BYTECOUNT,X
        BEQ      LOCATECURBYTEE      B/ NO, GO FIGURE OUT WHY
        ;LDX    IOCBPOINTER       YES, IS THE DATA SECTOR STILL HERE ?
        LDX     IOCBPOINTER
        ;LDX    IOCB:DRDSI,X      ... ?
        LDX     IOCB:DRDSI,X
        BEQ      LOCATECURBYTEE3     B/ NO, GO FIGURE OUT STUFF THE HARD WAY!
        ;JSR    REQUERDSI       MAKE SURE THIS SECTOR DOESN'T GET KICKED OUT SOON
        JSR     REQUERDSI
        LDAA      WRITEFLAG        DATA SECTOR IS STILL AROUND, IS THIS A WRITE ?
        BNE      LOCATECURBYTEWJ     B/ YES, GO PROCESS
        ;JMP    LOCATECURBYTED      B/ READ MODE, GO SET UP XFER COUNT
        JMP     LOCATECURBYTED

LOCATECURBYTEWJ     EQU     *
        ;JMP    LOCATECURBYTEW
        JMP     LOCATECURBYTEW

LOCATECURBYTE9J     EQU     *
        ;JMP    LOCATECURBYTE9
        JMP     LOCATECURBYTE9

LOCATECURBYTEE      ; EXHAUSTED BYTECOUNT
        ;LDX    IOCBPOINTER       LOADING :BYTECOUNT INTO (X) DESTROYED THIS...
        LDX     IOCBPOINTER
        LDAA      WRITEFLAG        IS THIS A WRITE ?
        BNE      LOCATECURBYTEE2     B/ YES
        LDAA      IOCB:EOFFLAG,X     NO, ARE WE AT EOF ?
        BNE      LOCATECURBYTE9J     B/ YES, GO COMPLAIN!
LOCATECURBYTEE2     EQU     *
        ;LDD    IOCB:CURBYTE+2,X    HMMM... ARE WE ON A SECTOR BOUNDARY ?
        LDAB      (IOCB:CURBYTE+2)+1,X
        LDAA      IOCB:CURBYTE+2,X
        ;LDX    IOCB:DCB,X
        LDX     IOCB:DCB,X
        BITB      DSKINFO:NBPSM1+1,X
        BNE      LOCATECURBYTEGJ     B/ NO, GO RE-READ THE SECTOR
        BITA      DSKINFO:NBPSM1,X
        BNE      LOCATECURBYTEGJ     B/ NO, GO RE-READ THE SECTOR
        ;LDX    IOCBPOINTER       MUST BE AT END OF SECTOR
        LDX     IOCBPOINTER
        ;INC     IOCB:DRSN,X       FIGURE OUT DRSN OF NEXT SECTOR IN CLUSTER
        INC      IOCB:DRSN,X
        LDAA      IOCB:DRSN,X       GET NEXT SECTOR NUMBER WITHIN CLUSTER
        ;LDX    IOCB:DCB,X  CLUSTER EXHAUSTED ?
        LDX     IOCB:DCB,X
        ;CMPA     DSKINFO:NSPC,X   ...?
        CMPA      DSKINFO:NSPC,X
        BEQ      LOCATECURBYTEE4     B/ YES
        ;LDX    IOCBPOINTER       NO, IS THIS CLUSTER ALLOCATED ?
        LDX     IOCBPOINTER
        ;LDX    IOCB:CURLCN,X
        LDX     IOCB:CURLCN,X
        INX             ... ?
        BEQ      LOCATECURBYTE4      B/ NO, GO DECIDE WHAT TO DO
        ;JSR    INCIOCB:CURLSN      SELECT NEXT SECTOR NUMBER
        JSR     INCIOCB:CURLSN
        ;JMP    LOCATECURBYTE8      GO ISSUE THE READ TO GET THAT DATA SECTOR
        JMP     LOCATECURBYTE8
        PAGE
LOCATECURBYTEE4     ; CLUSTER IS EXHAUSTED
        ;LDX    IOCBPOINTER       YES, CLUSTER IS EXHAUSTED
        LDX     IOCBPOINTER
        ;CLR     IOCB:RBN,X SET RELATIVE BYTE # WITHIN CLUSTER...
        CLR      IOCB:RBN,X
        ;CLR     IOCB:RBN+1,X       TO ZERO
        CLR      IOCB:RBN+1,X
        ;INC     IOCB:RDCN+1,X      BUMP TO NEXT DATA CLUSTER NUMBER
        INC      IOCB:RDCN+1,X
        BNE      LOCATECURBYTEE1
        ;INC     IOCB:RDCN,X
        INC      IOCB:RDCN,X
LOCATECURBYTEE1     EQU     *
        ;JMP    LOCATECURBYTE3      GO LOCATE LCN FOR DATA CLUSTER
        JMP     LOCATECURBYTE3

LOCATECURBYTEE3     ; DATA SECTOR DISAPPEARED!
        ;LDX    IOCBPOINTER       BECAUSE X IS TRASHED
        LDX     IOCBPOINTER
        ;LDX    IOCB:CURLCN,X       IS CURRENT CLUSTER ALLOCATED ?
        LDX     IOCB:CURLCN,X
        INX             ... ?
        BEQ      LOCATECURBYTE4      B/ NO, GO DECIDE WHAT TO DO
LOCATECURBYTEGJ     EQU     *
        ;JMP    LOCATECURBYTEG      AND GO GET THE SECTOR AGAIN
        JMP     LOCATECURBYTEG
        PAGE
LOCATECURBYTE0      ; START WITH IOCB:CURBYTE AND DO A FULL LOCATE
        ;JSR    COMPUTERDCN       COMPUTE RELATIVE DATA CLUSTER NUMBER
        JSR     COMPUTERDCN
        ;CMPD    IOCB:RDCN,X        IN SAME DATA CLUSTER IOCB HAS ALREADY SELECTED?
        CMPA      IOCB:RDCN,X
        BNE      MACRO:0021
        CMPB      (IOCB:RDCN)+1,X
MACRO:0021
        BEQ      LOCATECURBYTE5      B/ YES, DON'T NEED TO READ HEADER CLUSTER
*** This is where Segment size stuff should be inserted!
LOCATECURBYTE1      ; MUST READ BLOCK OF HEADER CLUSTER (SIGH!)
        ;STD    IOCB:RDCN,X        SAVE NEW RELATIVE DATA CLUSTER NUMBER
        STAB      (IOCB:RDCN)+1,X
        STAA      IOCB:RDCN,X
        BRA       LOCATECURBYTE3      GO FIND LCN OF DATA CLUSTER

LOCATECURBYTE4      ; NO DATA LCN YET ALLOCATED
        LDAA      WRITEFLAG        IS THIS A WRITE ATTEMPT?
        BNE      LOCATECURBYTE2      B/ WRITE ATTEMPTED
        ;LDD    #DUMMYLCN        READ ATTEMPT, SET CURLCN:=DUMMY
        LDAB      #(DUMMYLCN)&$FF
        LDAA      #(DUMMYLCN)/256
        ;LDX    IOCBPOINTER       THIS SEEMS TO BE IMPORTANT
        LDX     IOCBPOINTER
        ;STD    IOCB:CURLCN,X
        STAB      (IOCB:CURLCN)+1,X
        STAA      IOCB:CURLCN,X
        ;LDX    #0      WATCH ME PULL A RABBIT OUT OF A HAT!
        LDX     #0
        STX     SYSSECTORDB+SECTORDB:DISKINFO       INVENT A ZERO SECTOR
        STX     SYSSECTORDB+SECTORDB:LSN+1  USE AN IMAGINARY DISK DRIVE
        ;LDX    #SYSSECTORDB      AND "READ" SECTOR ZERO FROM THAT DRIVE
        LDX     #SYSSECTORDB
        ;CLR     SECTORDB:LSN,X    THIS IMAGINARY SECTOR MATCHES ALL IMAGINARY SECTORS
        CLR      SECTORDB:LSN,X
        ;JSR    INVENTSECTOR     *** POOF ***
        JSR     INVENTSECTOR
        CLRA              NOW ZERO IT OUT
        CLRB
        ;SUBD    MAXSECTORSIZE     (GET - # BYTES TO ZAP)
        SUBB      MAXSECTORSIZE+1
        SBCA       MAXSECTORSIZE
        STAA      TEMPA    FOR STAASECTORL
        ;LDX    RDSI:SECTORBASE,X  GET SECTOR ADDRESS
        LDX     RDSI:SECTORBASE,X
        CLRA              MAKE THE ZERO FOR STAASECTORL TO STORE
        ;JSR    STAASECTORL        AND GO ZERO THE SECTOR OUT
        JSR     STAASECTORL
        BRA       LOCATECURBYTE5A      GO SET UP THE WORLD
        PAGE
LOCATECURBYTE3A      ; CAN'T LOCATE RDCN
        CPX      #ERR:HCSICTOOSMALL IS THIS WHY ?
        BEQ      LOCATECURBYTE4      B/ YES, MUST ALLOCATE MORE SPACE
        ;JMP    ERRORED NO, GO CAUSE AN ERROR
        JMP     ERRORED

LOCATECURBYTE2      ; WRITE TO UNALLOCATED CLUSTER
        ;LDX    DCBPOINTER        ALLOCATE CLUSTERS IN MIDDLE OF FILE
        LDX     DCBPOINTER
        ;LDD    DSKINFO:MIDALLOC,X        GET # TO ALLOCATE
        LDAB      (DSKINFO:MIDALLOC)+1,X
        LDAA      DSKINFO:MIDALLOC,X
        ;JSR    ALLOCATECLUSTERS
        JSR     ALLOCATECLUSTERS
        ;JSR    COMPUTERDCN       ALLOC BOMBED IOCB:RDCN...
        JSR     COMPUTERDCN
        ;STD    IOCB:RDCN,X        SO WE NEED TO RE-COMPUTE IT
        STAB      (IOCB:RDCN)+1,X
        STAA      IOCB:RDCN,X
LOCATECURBYTE3      ; GET LCN FROM HEADER CLUSTER
        ;JSR    LOCATERDCN GO LOCATE THE DATA CLUSTER NUMBER
        JSR     LOCATERDCN
        BCS       LOCATECURBYTE3A      B/ ERROR OCCURRED
        ;LDD    HEADER:LCN,X      GRAB DESIRED LCN
        LDAB      (HEADER:LCN)+1,X
        LDAA      HEADER:LCN,X
        ;LDX    IOCBPOINTER       AND SAVE IT FOR NEXT ROUND
        LDX     IOCBPOINTER
        ;STD    IOCB:CURLCN,X
        STAB      (IOCB:CURLCN)+1,X
        STAA      IOCB:CURLCN,X
LOCATECURBYTE5      EQU     *
        ;LDD    IOCB:RBN,X NOW DIVIDE RELATIVE BYTE # BY SECTOR SIZE
        LDAB      (IOCB:RBN)+1,X
        LDAA      IOCB:RBN,X
        ;JSR    COMPUTERSN       TO GET RELATIVE SECTOR #
        JSR     COMPUTERSN
        STAB      IOCB:DRSN,X
        ;LDX    IOCB:CURLCN,X       IS DATA LCN ALLOCATED ?
        LDX     IOCB:CURLCN,X
        INX             ...= DUMMYLCN ?
        BEQ      LOCATECURBYTE4      B/ DUMMY LCN, GO DECIDE WHAT TO DO
*       THE FOLLOWING IS THE "FAST PATH" FOR HANDLING WRITING AT END OF FILE
        LDAA      WRITEFLAG        ARE WE WRITING ?
        BEQ      LOCATECURBYTE5B      B/ NO, DON'T HAVE TO ZERO CLUSTERS OF SPARSE FILE
        ;LDX    IOCBPOINTER       AT END OF FILE ?
        LDX     IOCBPOINTER
        ;LDA     IOCB:EOFFLAG,X     ...?
        LDAA      IOCB:EOFFLAG,X
        BEQ      LOCATECURBYTE5B      B/ NO, DON'T HAVE TO ZERO CLUSTERS OF SPARSE FILE
        ;JSR    CHECKMUSTZERO     DOES SECTOR AT EOF CONTAIN IOCB:CURBYTE ?
        JSR     CHECKMUSTZERO
        ;LBCS     ZEROTOCURBYTE     B/ NO, MUST ZERO CLUSTERS AT END OF SPARSE FILE
        BCC        MACRO:0022
        JMP     ZEROTOCURBYTE
MACRO:0022
LOCATECURBYTE5B ; NOW COMPUTE LSN OF DESIRED SECTOR
        ;LDX    IOCBPOINTER       NOW FIND LSN OF DESIRED SECTOR
        LDX     IOCBPOINTER
        ;LDD    IOCB:CURLCN,X
        LDAB      (IOCB:CURLCN)+1,X
        LDAA      IOCB:CURLCN,X
        ;JSR    CONVERTLCNTOLSN
        JSR     CONVERTLCNTOLSN
        PAGE
LOCATECURBYTE8      ;  DATA CLUSTER CONTAINING CURBYTE EXISTS!
*       SEE IF WE CAN OPTIMIZE THE FETCH
        ;LDX    IOCBPOINTER       SIGH!
        LDX     IOCBPOINTER
        LDAA      IOCB:EOFFLAG,X     AT OR PAST END OF FILE ?
        BEQ      LOCATECURBYTEG      B/ NO, MUST FETCH DATA SECTOR
        ;LDX    FCBPOINTER        IS FILESIZE ON A SECTOR BOUNDARY ?
        LDX     FCBPOINTER
        ;LDD    FCB:FILESIZE+2,X  ...?
        LDAB      (FCB:FILESIZE+2)+1,X
        LDAA      FCB:FILESIZE+2,X
        ;LDX    DCBPOINTER        (I.E., IS FILESIZE MOD NBPS = 0 ?)
        LDX     DCBPOINTER
        BITB      DSKINFO:NBPSM1+1,X       ... ?
        BNE      LOCATECURBYTEG      B/ NO, MUST FETCH DATA SECTOR
        BITA      DSKINFO:NBPSM1,X ... ?
        BNE      LOCATECURBYTEG      B/ NO, MUST FETCH DATA SECTOR
        ;LDX    IOCBPOINTER       YES! INVENT A ZEROED SECTOR INSTEAD OF READING
        LDX     IOCBPOINTER
        ;JSR    INVENTSECTOR
        JSR     INVENTSECTOR
        ;JSR    ZEROSECTOR       GO ZERO THE SECTOR INVENTED
        JSR     ZEROSECTOR
        BRA       LOCATECURBYTE5A      AND CONTINUE AS THOUGH WE DID A READ

LOCATECURBYTEG      ; GET THE DATA SECTOR
        ;LDX    IOCBPOINTER       GET POINTER TO SECTOR DESCRIPTOR
        LDX     IOCBPOINTER
        ;JSR    READSECTOR        AND INITIATE THE READ
        JSR     READSECTOR
LOCATECURBYTE5A ; SECTOR HAS BEEN FETCHED
        ;LDX    IOCBPOINTER       SAVE RDSI ADDRESS IN IOCB
        LDX     IOCBPOINTER
        ;LDD    RDSIPOINTER
        LDAB      RDSIPOINTER+1
        LDAA      RDSIPOINTER
        ;STD    IOCB:DRDSI,X
        STAB      (IOCB:DRDSI)+1,X
        STAA      IOCB:DRDSI,X
        ;JSR    COMPUTENEXTBYTE   SET UP POINTER INTO DATA SECTOR
        JSR     COMPUTENEXTBYTE
        LDAA      WRITEFLAG        ARE WE WRITING ?
        ;LBNE    LOCATECURBYTEW      B/ YES
        BEQ      MACRO:0023
        JMP     LOCATECURBYTEW
MACRO:0023
LOCATECURBYTER      ; READING FROM THE FILE
        LDAA      IOCB:EOFFLAG,X     HIT EOF?
        BNE      LOCATECURBYTE9      B/ YES, GO BITCH
        ;LDX    IOCB:FCB,X  NO, COMPUTE FILESIZE - CURBYTE
        LDX     IOCB:FCB,X
        ;LDD    FCB:FILESIZE,X
        LDAB      (FCB:FILESIZE)+1,X
        LDAA      FCB:FILESIZE,X
        ;PSHD
        PSHB
        PSHA
        ;LDD    FCB:FILESIZE+2,X
        LDAB      (FCB:FILESIZE+2)+1,X
        LDAA      FCB:FILESIZE+2,X
        ;LDX    IOCBPOINTER       DO THE SUBTRACT
        LDX     IOCBPOINTER
        ;SUBD    IOCB:CURBYTE+2,X
        SUBB      (IOCB:CURBYTE+2)+1,X
        SBCA       IOCB:CURBYTE+2,X
        ;STD    TEMPX   WE NEED DISTANCE TO EOF LATER
        STAB      TEMPX+1
        STAA      TEMPX
        ;PULD           (RETREIVE UPPER HALF OF FCB:FILESIZE)
        PULA
        PULB
        SBCB       IOCB:CURBYTE+1,X
        SBCA       IOCB:CURBYTE,X
        BNE      LOCATECURBYTE7      B/ > 2^24 BYTES FROM END OF FILE
        TSTB
        BNE      LOCATECURBYTE7      B/ > 65536 BYTES FROM END OF FILE
        ;LDD    TEMPX   "CLOSE" TO END OF FILE
        LDAB      TEMPX+1
        LDAA      TEMPX
        ;CMPD    IOCB:BYTECOUNT,X    < 65536 BYTES FROM END OF FILE
        CMPA      IOCB:BYTECOUNT,X
        BNE      MACRO:0024
        CMPB      (IOCB:BYTECOUNT)+1,X
MACRO:0024
        BHI      LOCATECURBYTE7      B/ USE NBPS-DISPLACEMENT
LOCATECURBYTE6      EQU     *
        ;STD    IOCB:BYTECOUNT,X    SAVE # BYTES TO MOVE MAX
        STAB      (IOCB:BYTECOUNT)+1,X
        STAA      IOCB:BYTECOUNT,X
LOCATECURBYTE7      EQU     *
        ;JSR    WAITRDSI WAIT FOR I/O COMPLETED
        JSR     WAITRDSI
        ;LDX    IOCBPOINTER
        LDX     IOCBPOINTER
        LDAA      #1      FLAG "CURBYTE HAS BEEN LOCATED"
        STAA      IOCB:LOCATEDF,X
        ;JSR    READAHEAD  FIRE UP THE READ-AHEAD
        JSR     READAHEAD
LOCATECURBYTED      ; ALMOST DONE!
        ;LDX    IOCBPOINTER       COMPUTE MIN(BYTECOUNT,REQUESTED)
        LDX     IOCBPOINTER
        ;LDD    USEDCOUNT
        LDAB      USEDCOUNT+1
        LDAA      USEDCOUNT
        ;CMPD    IOCB:BYTECOUNT,X
        CMPA      IOCB:BYTECOUNT,X
        BNE      MACRO:0025
        CMPB      (IOCB:BYTECOUNT)+1,X
MACRO:0025
        BCS       LOCATECURBYTED2     B/ USE REQUESTED
        ;LDD    IOCB:BYTECOUNT,X    USE BYTECOUNT
        LDAB      (IOCB:BYTECOUNT)+1,X
        LDAA      IOCB:BYTECOUNT,X
        ;STD    USEDCOUNT        SAVE # BYTES USED AT THIS STEP
        STAB      USEDCOUNT+1
        STAA      USEDCOUNT
LOCATECURBYTED2     EQU     *
        ;LDX    IOCBPOINTER       AS PROMISED
        LDX     IOCBPOINTER
        OKRTS

LOCATECURBYTE9      ; WHEN WE GET HERE, IOCB:EOF IS ALREADY SET
        ;CLR     IOCB:BYTECOUNT,X    ZAP THE BYTECOUNT
        CLR      IOCB:BYTECOUNT,X
        ;CLR     IOCB:BYTECOUNT+1,X
        CLR      IOCB:BYTECOUNT+1,X
        ;JMP    ERREOFHIT
        JMP     ERREOFHIT
        PAGE
LOCATECURBYTEW      ; WRITING TO FILE
        ;LDX    IOCBPOINTER       JUST IN CASE
        LDX     IOCBPOINTER
        ;LDX    IOCB:DRDSI,X      DID WE END UP...
        LDX     IOCB:DRDSI,X
        LDAA      RDSI:DISKINFO,X TRYING TO WRITE ON THE IMAGINARY SECTOR ?
        ;LBEQ    LOCATECURBYTE2      B/ YES, GO ALLOCATE THE ACTUAL DATA CLUSTER
        BNE      MACRO:0026
        JMP     LOCATECURBYTE2
MACRO:0026
        STAA      RDSI:MODIFIED,X MAKE SURE THIS DATA SECTOR GOES BACK TO DISK
        ;LDX    IOCBPOINTER
        LDX     IOCBPOINTER
        ;LDD    USEDCOUNT        COMPUTE MIN OF REQUESTED COUNT,
        LDAB      USEDCOUNT+1
        LDAA      USEDCOUNT
        ;CMPD    IOCB:BYTECOUNT,X    AND NBPS-DISPLACMENT INTO SECTOR
        CMPA      IOCB:BYTECOUNT,X
        BNE      MACRO:0027
        CMPB      (IOCB:BYTECOUNT)+1,X
MACRO:0027
        BCS       LOCATECURBYTEW2     B/ REQUESTED COUNT IS SMALLER
        ;LDD    IOCB:BYTECOUNT,X    USE NBPS-DISPLACEMENT AS # BYTES
        LDAB      (IOCB:BYTECOUNT)+1,X
        LDAA      IOCB:BYTECOUNT,X
        ;STD    USEDCOUNT        SAVE # BYTES TO MOVE, MAX
        STAB      USEDCOUNT+1
        STAA      USEDCOUNT
LOCATECURBYTEW2     EQU     *
        ;ADDD    IOCB:CURBYTE+2,X    COMPUTE CURBYTE + # BYTES TO BE WRITTEN
        ADDB      (IOCB:CURBYTE+2)+1,X
        ADCA       IOCB:CURBYTE+2,X
        ;STD    TEMP+2
        STAB      TEMP+2+1
        STAA      TEMP+2
        ;LDX    IOCB:CURBYTE,X
        LDX     IOCB:CURBYTE,X
        BCC        LOCATECURBYTEW5
        INX
LOCATECURBYTEW5     EQU     *
        STX     TEMP
        ;LDX    FCBPOINTER        NOW COMPARE TO CURRENT FILESIZE
        LDX     FCBPOINTER
        ;LDD    FCB:FILESIZE+2,X  BY SUBTRACTING NEW FILE SIZE FROM FCB:FILESIZE
        LDAB      (FCB:FILESIZE+2)+1,X
        LDAA      FCB:FILESIZE+2,X
        ;SUBD    TEMP+2
        SUBB      TEMP+2+1
        SBCA       TEMP+2
        ;LDD    FCB:FILESIZE,X
        LDAB      (FCB:FILESIZE)+1,X
        LDAA      FCB:FILESIZE,X
        SBCB       TEMP+1
        SBCA       TEMP
        BCC        LOCATECURBYTEW4     B/ NEW "END OF FILE" < OLD, DON'T UPDATE
        ;LDD    TEMP    NEW EOF > OLD
        LDAB      TEMP+1
        LDAA      TEMP
        ;STD    FCB:FILESIZE,X    UPDATE FILESIZE
        STAB      (FCB:FILESIZE)+1,X
        STAA      FCB:FILESIZE,X
        ;LDD    TEMP+2
        LDAB      TEMP+2+1
        LDAA      TEMP+2
        ;STD    FCB:FILESIZE+2,X
        STAB      (FCB:FILESIZE+2)+1,X
        STAA      FCB:FILESIZE+2,X
        LDAA      FCB:FLAGS,X        MAKE SURE DIRECTORY GETS UPDATED
        ORAA      #FCBFLG::UPDATEDIR
        STAA      FCB:FLAGS,X
LOCATECURBYTEW4     EQU     *
        ;JSR    WAITRDSI WAIT FOR DISK SECTOR TO ARRIVE
        JSR     WAITRDSI
        ;LDX    IOCBPOINTER       NOW MARK CURBYTE...
        LDX     IOCBPOINTER
        LDAA      #1      AS "LOCATED"
        STAA      IOCB:LOCATEDF,X
        ;JSR    READAHEAD  GET READAHEAD FIRED UP.
        JSR     READAHEAD
        ;LDD    USEDCOUNT        GET # BYTES TO MOVE
        LDAB      USEDCOUNT+1
        LDAA      USEDCOUNT
        ;JMP    LOCATECURBYTED2
        JMP     LOCATECURBYTED2
        PAGE
*       ZEROTOCURBYTE -- ZEROS OUT SECTORS BETWEEN FILESIZE AND IOCB:CURBYTE
*               ONLY USED WHEN WRITING AT END-OF-FILE...
*               AND IOCB:CURBYTE IS FAR PAST FILESIZE
*
ZEROTOCURBYTE ; CURBYTE > 1 SECTOR PAST FILESIZE
*       JSR     CHECKMUSTZERO     MUST WE ZERO A SECTOR ?
*       BCS       ZEROTOCURBYTE3    B/ NO, GET OUT FAST !
        ;LDX    FCBPOINTER        IS FILESIZE **NOT** ON A SECTOR BOUNDARY ?
        LDX     FCBPOINTER
        ;LDD    FCB:FILESIZE+2,X  (I.E., IS SECTOR@FILESIZE ALREADY ZEROED?)
        LDAB      (FCB:FILESIZE+2)+1,X
        LDAA      FCB:FILESIZE+2,X
        ;LDX    DCBPOINTER        ...?
        LDX     DCBPOINTER
        BITB      DSKINFO:NBPSM1+1,X
        BNE      ZEROTOCURBYTEA     B/ NOT ON SECTOR BOUNDARY, GO ADVANCE TO NEXT
        BITA      DSKINFO:NBPSM1,X
        BNE      ZEROTOCURBYTEA     B/ NOT ON SECTOR BOUNDARY, GO ADVANCE TO NEXT
ZEROTOCURBYTEZ ; MUST ZERO SECTOR SELECTED BY FILESIZE
        ;JSR    COMPUTERDCNF      LOCATE LSN OF SECTOR TO BE ZEROED
        JSR     COMPUTERDCNF
        BCS       ZEROTOCURBYTE3    B/ FILESIZE = MAX LEGAL SIZE FOR THIS DISK !!
******** CAN FILESIZE BECOME > MAX LEGAL SIZE FOR THIS DISK ??????
        ;STD    IOCB:RDCN,X        SAVE RELATIVE DATA CLUSTER #
        STAB      (IOCB:RDCN)+1,X
        STAA      IOCB:RDCN,X
        ;LDD    IOCB:RBN,X COMPUTE RELATIVE SECTOR # NEEDED
        LDAB      (IOCB:RBN)+1,X
        LDAA      IOCB:RBN,X
        ;JSR    COMPUTERSN
        JSR     COMPUTERSN
        STAB      IOCB:DRSN,X       AND SAVE IT
        ;JSR    LOCATERDCN FIND LCN OF DATA CLUSTER
        JSR     LOCATERDCN
        BCS       ZEROTOCURBYTE5    B/ ERROR IN LOCATING LCN OF CLUSTER
        ;LDD    HEADER:LCN,X      GET CLUSTER # FROM HEADER
        LDAB      (HEADER:LCN)+1,X
        LDAA      HEADER:LCN,X
        ;LDX    IOCBPOINTER       TO BE COMPATIBLE...
        LDX     IOCBPOINTER
        ;STD    IOCB:CURLCN,X       WITH LOCATECURBYTE0
        STAB      (IOCB:CURLCN)+1,X
        STAA      IOCB:CURLCN,X
        ;LDX    IOCB:CURLCN,X       IS THIS CLUSTER ALLOCATED ?
        LDX     IOCB:CURLCN,X
        INX             ... ?
        BEQ      ZEROTOCURBYTEA     B/ NO, THIS SECTOR IS EFFECTIVELY ZEROED ALREADY !
        ;JSR    CONVERTLCNTOLSN   YES, CONVERT LCN TO DESIRED SECTOR #
        JSR     CONVERTLCNTOLSN
        ;JSR    INVENTSECTOR     OUT OF NOWHERE SO WE CAN ZERO IT!!
        JSR     INVENTSECTOR
        ;JSR    ZEROSECTOR       THEN ZERO IT...
        JSR     ZEROSECTOR
        ;JSR    MARKMODIFIED     AND MAKE THIS SECTOR GO TO THE DISK
        JSR     MARKMODIFIED
ZEROTOCURBYTEA ; ADVANCE FILESIZE PAST ZEROED SECTOR
        ;LDX    FCBPOINTER
        LDX     FCBPOINTER
        ;LDD    FCB:FILESIZE+2,X  (FIND LAST BYTE OF SECTOR)
        LDAB      (FCB:FILESIZE+2)+1,X
        LDAA      FCB:FILESIZE+2,X
        ;LDX    DCBPOINTER
        LDX     DCBPOINTER
        ;ORA     DSKINFO:NBPSM1,X
        ORAA      DSKINFO:NBPSM1,X
        ;ORB     DSKINFO:NBPSM1+1,X
        ORAB      DSKINFO:NBPSM1+1,X
        ;LDX    FCBPOINTER        (RESULT MUST GO BACK TO FCB)
        LDX     FCBPOINTER
        ;ADDD    #1              (ADD 1 TO GET 1ST BYTE OF NEXT SECTOR)
        ADDB      #(1)&$FF
        ADCA       #(1)/256
        ;STD    FCB:FILESIZE+2,X
        STAB      (FCB:FILESIZE+2)+1,X
        STAA      FCB:FILESIZE+2,X
        BCC        ZEROTOCURBYTEA1    B/ DON'T HAVE TO PROPOGATE CARRY
        ;INC     FCB:FILESIZE+1,X
        INC      FCB:FILESIZE+1,X
        BNE      ZEROTOCURBYTEA1    B/ DON'T HAVE TO PROPOGATE CARRY
        ;INC     FCB:FILESIZE,X
        INC      FCB:FILESIZE,X
ZEROTOCURBYTEA1
        ;LDA     FCB:FLAGS,X        MARK FCB AS MODIFIED
        LDAA      FCB:FLAGS,X
        ;ORA     #FCBFLG::UPDATEDIR
        ORAA      #FCBFLG::UPDATEDIR
        ;STA     FCB:FLAGS,X
        STAA      FCB:FLAGS,X
        BSR      CHECKMUSTZERO     MUST WE ZERO MORE SECTORS AT EOF ?
        BCS       ZEROTOCURBYTEZ    B/ YES, GO ZERO ANOTHER ONE!
ZEROTOCURBYTE3
        ;JMP    LOCATECURBYTE0      SINCE ZEROTOCURBYTE DESTROYS LOCATOR INFORMATION
        JMP     LOCATECURBYTE0

ZEROTOCURBYTE5    EQU     *
        CPX      #ERR:HCSICTOOSMALL VALID REASON PREVENTING US FROM LOCATING CLUSTER?
        BEQ      ZEROTOCURBYTE3    B/ YES, JUST QUIT
        ;JMP    ERRORED NO, GO BITCH AND SCREAM AND SHOUT!
        JMP     ERRORED
        PAGE
*       CHECKMUSTZERO -- CHECK IF WE MUST ZERO ANOTHER SECTOR
*       USED TO HELP HANDLE SPARSE FILE ZEROING AT END OF FILE
*       CHECKS TO SEE IF SECTOR SELECTED BY FCB:FILESIZE...
*       CONTAINS THE BYTE SELECTED BY IOCB:CURBYTE
*       RETURNS CARRY RESET IF YES, NO NEED TO ZERO
*       RETURNS CARRY SET IF NO, MUST ZERO ANOTHER SECOTR
*
CHECKMUSTZERO     ; CHECK IF WE MUST ZERO SECTORS
        ;LDX    FCBPOINTER        FETCH FILESIZE FOR COMPARE
        LDX     FCBPOINTER
        ;LDD    FCB:FILESIZE+2,X
        LDAB      (FCB:FILESIZE+2)+1,X
        LDAA      FCB:FILESIZE+2,X
        ;LDX    FCB:FILESIZE,X
        LDX     FCB:FILESIZE,X
        STX     TEMPX           TEMPX,D:=FILESIZE
        ;LDX    DCBPOINTER        FIND LAST BYTE OF SECTOR SELECTED BY FILESIZE
        LDX     DCBPOINTER
        ;ORA     DSKINFO:NBPSM1,X
        ORAA      DSKINFO:NBPSM1,X
        ;ORB     DSKINFO:NBPSM1+1,X
        ORAB      DSKINFO:NBPSM1+1,X
        ;LDX    IOCBPOINTER       NOW COMPARE TO IOCB:CURBYTE
        LDX     IOCBPOINTER
        ;SUBD    IOCB:CURBYTE+2,X
        SUBB      (IOCB:CURBYTE+2)+1,X
        SBCA       IOCB:CURBYTE+2,X
        ;LDD    TEMPX
        LDAB      TEMPX+1
        LDAA      TEMPX
        SBCB       IOCB:CURBYTE+1,X
        SBCA       IOCB:CURBYTE,X
        RTS             CARRY IS RESET IF CURBYTE IN SECTOR AT FILESIZE
        PAGE
*       UPDATECURBYTE -- BY ADDING USEDCOUNT
*               ALSO ADJUSTS BYTECOUNT, NEXTBYTE
*               CAN BE CALLED ONLY IF IOCB:LOCATEDF IS VALID
*
UPDATECURBYTE      EQU     *
        ;LDX    IOCBPOINTER       ADD # BYTES USED TO CURBYTE
        LDX     IOCBPOINTER
        ;LDD    IOCB:CURBYTE+2,X
        LDAB      (IOCB:CURBYTE+2)+1,X
        LDAA      IOCB:CURBYTE+2,X
        ;ADDD    USEDCOUNT
        ADDB      USEDCOUNT+1
        ADCA       USEDCOUNT
        ;STD    IOCB:CURBYTE+2,X
        STAB      (IOCB:CURBYTE+2)+1,X
        STAA      IOCB:CURBYTE+2,X
        BCC        UPDATECURBYTE1     B/ NO NEED TO UPDATE UPPER 16 BITS
        ;INC     IOCB:CURBYTE+1,X
        INC      IOCB:CURBYTE+1,X
        BNE      UPDATECURBYTE1
        ;INC     IOCB:CURBYTE,X
        INC      IOCB:CURBYTE,X
UPDATECURBYTE1     EQU     *
        ;LDD    IOCB:NEXTBYTE,X    NOW ADJUST POINTER TO NEXT BYTE IN SECTOR BUFFER
        LDAB      (IOCB:NEXTBYTE)+1,X
        LDAA      IOCB:NEXTBYTE,X
        ;ADDD    USEDCOUNT        BY ADVANCING IT BY # USED BYTES
        ADDB      USEDCOUNT+1
        ADCA       USEDCOUNT
        ;STD    IOCB:NEXTBYTE,X
        STAB      (IOCB:NEXTBYTE)+1,X
        STAA      IOCB:NEXTBYTE,X
        ;LDD    IOCB:BYTECOUNT,X    NOW ADJUST # BYTES REMAINING IN FILE/SECTOR
        LDAB      (IOCB:BYTECOUNT)+1,X
        LDAA      IOCB:BYTECOUNT,X
        ;SUBD    USEDCOUNT
        SUBB      USEDCOUNT+1
        SBCA       USEDCOUNT
        ;STD    IOCB:BYTECOUNT,X
        STAB      (IOCB:BYTECOUNT)+1,X
        STAA      IOCB:BYTECOUNT,X
        IF      M6800!M6801
        BNE      UPDATECURBYTERTS   B/ THERE ARE MORE IN THIS SECTOR
        TSTA             ANY BYTES LEFT IN THIS SECTOR ?
UPDATECURBYTERTS   EQU     *
        FIN
        RTS
        PAGE
*
*       UPDATECURBYTEF -- UPDATE CURBYTE FOR DISK FILES
*
UPDATECURBYTEF     EQU     *
        BSR      UPDATECURBYTE      GO DO THE STUFF WE HAVE IN COMMON WITH DISK DEVICE
        BNE      UPDATECURBYTEOKRTS B/ THERE ARE SOME BYTES LEFT IN THIS SECTOR, GET OUT!
        LDAA      IOCB:EOFFLAG,X     NO MORE, WERE WE AT EOF ?
        BNE      UPDATECURBYTEOKRTS B/ YES, LEAVE EOF FLAG SET
        ;JMP    DSKFEOFTEST     NO, GO SEE IF WE ARE AT EOF!
        JMP     DSKFEOFTEST
*                       WE USUALLY ONLY GET HERE IF WE'RE READING!
UPDATECURBYTEOKRTS EQU     *
        OKRTS
*
*       UPDATECURBYTED -- UPDATECURBYTE FOR DISK DEVICE
*
UPDATECURBYTED     EQU     *
        BSR      UPDATECURBYTE      GO DO THE COMMON STUFF
        BNE      UPDATECURBYTEOKRTS B/ MORE BYTES LEFT IN SECTOR, GET OUT!
        ;JMP    DSKDEOFTEST     SECTOR EXHAUSTED, GO CHECK FOR EOF
        JMP     DSKDEOFTEST
        PAGE
ERRDISKWRITELOCKED       EQU     *
        ;JSR    ERRET
        JSR     ERRET
        FDB      ERR:DISKWRITELOCKED

ERREOFHITJ2     EQU     *
        ;JMP    ERREOFHIT
        JMP     ERREOFHIT
*
*       LOCDSKD -- LOCATE CURBYTE FOR DISK DEVICE
*               ENTERED WITH CURLSN PRE-COMPUTED BY DSKDEOFTEST
*               (A,B) CONTAIN REQUEST COUNT
*               IF WRITE REQUEST, AND DISK IS WRITE LOCKED...
*                       CAUSES A "DISK WRITE LOCKED" ERROR
*               IF WRITING AT LEAST NBPS BYTES, STARTING ON A SECTOR BOUNDARY,
*                       "INVENTSECTOR" IS USED INSTEAD OF "READSECTOR"
*                       TO OPTIMIZE DISK I/O TIME
*                       THIS ALSO ALLOWS WRITES TO DISK SECTORS...
*                       WHICH CANNOT BE READ
*               IF EOF HIT, TAKES "EOF HIT" ERROR EXIT
*               OTHERWISE, SETS BYTECOUNT = NBPS - (CURBYTE MOD NBPS)
*                       USEDCOUNT = MIN(BYTECOUNT,REQUESTED)
*               CALLER MUST CALL UPDATECURBYTED WHEN DONE COPYING BYTES
*
LOCDSKD  EQU     *
        ;STD    USEDCOUNT        SAVE THE REQUESTED COUNT
        STAB      USEDCOUNT+1
        STAA      USEDCOUNT
        ;LDX    IOCBPOINTER       HIT EOF ?
        LDX     IOCBPOINTER
        LDAA      IOCB:EOFFLAG,X     ... ?
        BNE      ERREOFHITJ2     B/ YES
        LDAA      IOCB:DISKWRITELOCKED,X     DISK DEVICE WRITE LOCKED ?
        BEQ      LOCDSKD1 B/ NO, LET HIM DO ANYTHING
        LDAA      WRITEFLAG        YES, DOES HE WANT TO WRITE ?
        BNE      ERRDISKWRITELOCKED       B/ TOO BAD!
LOCDSKD1 EQU     *
        LDAA      IOCB:DRDSI,X      IS DISK SECTOR STILL AROUND ?
        BEQ      LOCDSKD0 B/ NO, GO READ IT IN AGAIN
        ;LDD    IOCB:BYTECOUNT,X    YES, ANY BYTES LEFT IN THIS SECTOR ?
        LDAB      (IOCB:BYTECOUNT)+1,X
        LDAA      IOCB:BYTECOUNT,X
        ;BNED    LOCATECURBYTEDJ     B/ YES, TAKE QUICK EXIT
        BNE      LOCATECURBYTEDJ
        TSTB
        BNE      LOCATECURBYTEDJ
LOCDSKD0 EQU     *
        LDAA      WRITEFLAG        WRITING TO SECTOR ?
        BEQ      LOCDSKDR B/ NO
        ;LDX    IOCB:DCB,X  YES, WRITING AT LEAST A SECTOR'S WORTH...
        LDX     IOCB:DCB,X
        ;LDD    DSKINFO:NBPSM1,X TO A SECTOR BOUNDARY ?
        LDAB      (DSKINFO:NBPSM1)+1,X
        LDAA      DSKINFO:NBPSM1,X
        ;LDX    IOCBPOINTER       (WE NEED THIS AGAIN)
        LDX     IOCBPOINTER
        BITA      IOCB:CURBYTE+2,X    IF NOT ON SECTOR BOUNDARY, READ TO UPDATE SECTOR
        BNE      LOCDSKDR B/ NOT ON A SECTOR BOUNDARY
        BITB      IOCB:CURBYTE+3,X
        BNE      LOCDSKDR B/ NOT ON A SECTOR BOUNDARY
        ;SUBD    USEDCOUNT        IS USEDCOUNT >= NBPS ?
        SUBB      USEDCOUNT+1
        SBCA       USEDCOUNT
        BCC        LOCDSKDR B/ NO, MUST READ TO UPDATE
        ;JSR    INVENTSECTOR     YES, OPTIMIZE SECTOR WRITE!
        JSR     INVENTSECTOR
        STAA      RDSI:MODIFIED,X MARK SECTOR AS "DIDDLED"
        ;LDX    IOCBPOINTER       REMEMBER WHERE THE SECTOR IS
        LDX     IOCBPOINTER
        ;STD    IOCB:DRDSI,X
        STAB      (IOCB:DRDSI)+1,X
        STAA      IOCB:DRDSI,X
        ;JSR    COMPUTENEXTBYTE   SET UP BYTECOUNT FOR TRANSFER
        JSR     COMPUTENEXTBYTE
        BRA       LOCATECURBYTEDJ     DON'T DO READ-AHEAD!
        PAGE
LOCDSKDR ; MUST READ SECTOR (WITH POSSIBLE UPDATE)
        ;JSR    READSECTOR        GO READ IN THE DATA SECTOR
        JSR     READSECTOR
        TST     WRITEFLAG        WRITING ?
        BEQ      LOCDSKD2 B/ NO
        STAA      RDSI:MODIFIED,X YES, MARK RDSI AS MODIFIED
LOCDSKD2 EQU     *
        ;LDX    IOCBPOINTER       REMEMBER THE RDSI ADDRESS
        LDX     IOCBPOINTER
        ;STD    IOCB:DRDSI,X
        STAB      (IOCB:DRDSI)+1,X
        STAA      IOCB:DRDSI,X
        ;JSR    COMPUTENEXTBYTE   SET UP BYTECOUNT
        JSR     COMPUTENEXTBYTE
        ;JSR    WAITRDSI WAIT FOR ARRIVAL OF DATA SECTOR
        JSR     WAITRDSI
        LDAA      NRDSIS  ENOUGH BUFFERS AVAILABLE TO START READ-AHEAD ?
        ;CMPA     #READAHEADRDSIMIN  ... ?
        CMPA      #READAHEADRDSIMIN
        BLS      LOCATECURBYTEDJ     B/ NO, SO DON'T INITIATE READ-AHEAD
        ;JSR    INCIOCB:CURLSN      COMPUTE NEXT SECTOR ADDRESS
        JSR     INCIOCB:CURLSN
        LDAA      IOCB:CURLSN,X      WILL READAHEAD LSN BE LEGAL ?
        PSHA             (I.E., IS CURRENT LSN + 1 < NLSN ?)
        ;LDD    IOCB:CURLSN+1,X    COPY CURRENT LSN TO (TOS,A,B)
        LDAB      (IOCB:CURLSN+1)+1,X
        LDAA      IOCB:CURLSN+1,X
        ;LDX    IOCB:DCB,X  SUBTRACT DSKINFO:NLSN
        LDX     IOCB:DCB,X
        ;SUBD    DSKINFO:NLSN+1,X        (I,E., IS CURRENT LSN < NLSN ?)
        SUBB      (DSKINFO:NLSN+1)+1,X
        SBCA       DSKINFO:NLSN+1,X
        PULA
        SBCA       DSKINFO:NLSN,X
        BCC        LOCDSKD4 B/ NO, DON'T DO READ-AHEAD
        ;LDX    IOCBPOINTER       SIGH!
        LDX     IOCBPOINTER
        ;JSR    READSECTOR        INITIATE ITS FETCH
        JSR     READSECTOR
        BCS       LOCDSKD3 B/ AN I/O ERROR ??
LOCDSKD4 EQU     *
        ;JSR    DECIOCB:CURLSN      PUT LSN BACK LIKE IT WAS
        JSR     DECIOCB:CURLSN
LOCATECURBYTEDJ     EQU     *
        ;JMP    LOCATECURBYTED      GO COMPUTE USEDCOUNT AND TRANSFERCOUNT
        JMP     LOCATECURBYTED

LOCDSKD3 EQU     *
        ;JMP    READAHEADCERRED     GO BACK UP CURLSN AND ANNOUNCE ERROR
        JMP     READAHEADCERRED
        PAGE
*       LOCATERDCN -- READS IN HEADER SECTOR CONTAINING LCN FOR IOCB:RDCN
*               OKRET: RETURNS (X) POINTING TO DESIRED LCN IN HEADER SECTOR
*               ERRET: DISK I/O ERROR OCCURRED
*
LOCATERDCN EQU     *
        ;LDX    IOCBPOINTER       GRAB RDCN
        LDX     IOCBPOINTER
        ;LDD    IOCB:RDCN,X
        LDAB      (IOCB:RDCN)+1,X
        LDAA      IOCB:RDCN,X
        ;JSR    COMPUTERHSN      GET RELATIVE HEADER SECTOR NUMBER DESIRED
        JSR     COMPUTERHSN
        ;CMPB     IOCB:HRSN,X       SAME HEADER SECTOR AS LAST TIME ?
        CMPB      IOCB:HRSN,X
        BNE      LOCATERDCN0        B/ NO, MUST READ HEADER SECTOR
        LDAA      IOCB:HRDSI,X      IS THE HEADER SECTOR FROM LAST TIME STILL AROUND ?
        BNE      LOCATERDCN2        B/ YES, DON'T BOTHER READING IT IN!
LOCATERDCN0        ; MUST READ IN HEADER SECTOR
        ;CLR     IOCB:HRDSI,X      MARK CURRENT HEADER SECTOR AS "WRONG ONE!"
        CLR      IOCB:HRDSI,X
        ;CLR     IOCB:HRDSI+1,X    (IN CASE WE GET AN ERROR)
        CLR      IOCB:HRDSI+1,X
        STAB      IOCB:HRSN,X       SAVE SO WE CAN COMPUTE DESIRED LSN
        ;LDX    IOCB:FCB,X  IS HEADER INITIALIZED FAR ENOUGH ?
        LDX     IOCB:FCB,X
        ;CMPB     FCB:HCSIC,X ... ?
        CMPB      FCB:HCSIC,X
        BCC        LOCATERDCN3        B/ NO, INVALID RDCN
        ;JSR    GENHLSNPLUSHRSN COMPUTE DESIRED LSN
        JSR     GENHLSNPLUSHRSN
        ;JSR    READSECTOR        READ SECTOR CONTAINING PREVIOUS LCN
        JSR     READSECTOR
        ;LDX    IOCBPOINTER
        LDX     IOCBPOINTER
        ;STD    IOCB:HRDSI,X      SAVE HEADER SECTOR POINTER
        STAB      (IOCB:HRDSI)+1,X
        STAA      IOCB:HRDSI,X
LOCATERDCN2        ; HEADER SECTOR IS (BEING) READ IN
        ;LDD    IOCB:RDCN,X        GET IOCB:RDCN AGAIN
        LDAB      (IOCB:RDCN)+1,X
        LDAA      IOCB:RDCN,X
        ;ASLD            CONVERT TO A BYTE DISPLACEMENT INTO HEADER CLUSTER SECTOR
        ASLB
        ROLA
        ;LDX    DCBPOINTER        MASK TO GET DISPLACEMENT...
        LDX     DCBPOINTER
        ANDA      DSKINFO:NBPSM1,X INTO HEADER SECTOR OF PREVIOUS RDCN
        ANDB      DSKINFO:NBPSM1+1,X
        ;LDX    IOCBPOINTER       ADD SECTOR BUFFER ADDRESS...
        LDX     IOCBPOINTER
        ;LDX    IOCB:HRDSI,X      (OF HEADER SECTOR)
        LDX     IOCB:HRDSI,X
        ;ADDD    RDSI:SECTORBASE,X  TO GET POINTER TO PREVIOUS LOGICAL CLUSTER NUMBER
        ADDB      (RDSI:SECTORBASE)+1,X
        ADCA       RDSI:SECTORBASE,X
        ;STD    LOCATERDCNX        SAVE THE POINTER
        STAB      LOCATERDCNX+1
        STAA      LOCATERDCNX
        ;JSR    WAITSECTOR        WAIT FOR HEADER SECTOR TO ARRIVE
        JSR     WAITSECTOR
        ;LDX    LOCATERDCNX        GET POINTER TO PREVIOUS LOGICAL CLUSTER NUMBER
        LDX     LOCATERDCNX
        OKRTS

LOCATERDCN3        ; INVALID RDCN ENCOUNTERED
        ;LDX    DCBPOINTER        IS IT EVER POSSIBLE FOR THIS RDCN TO BE VALID ?
        LDX     DCBPOINTER
        ;CMPB     DSKINFO:NSPC,X   (I.E., WILL RDCN BE FOUND SOMEWHERE IN HEADER CLUSTER?)
        CMPB      DSKINFO:NSPC,X
        BCS       ERRHCSICTOOSMALL   B/ YES, INVALID BECAUSE OF HCSIC
ERRCLUSTERSIZELIMITSFILE EQU     *
        ;JSR    ERRET
        JSR     ERRET
        FDB      ERR:CLUSTERSIZELIMITSFILE

ERRHCSICTOOSMALL   EQU     *
        ;JSR    ERRET
        JSR     ERRET
        FDB      ERR:HCSICTOOSMALL
        PAGE
*
*       COMPUTENEXTBYTE -- GENERATE VALUE FOR IOCB:NEXTBYTE
*               = SECTORBASE(RDSIPOINTER)+(IOCB:CURBYTE MOD DSKINFO:NBPS)
*               SETS IOCB:BYTECOUNT = NBPS - (IOCB:CURBYTE MOD DSKINFO:NBPS)
*               (X) = IOCBPOINTER ON EXIT
*
COMPUTENEXTBYTE   EQU     *
        ;LDX    DCBPOINTER        GET MASK TO COMPUTE "MOD NBPS"
        LDX     DCBPOINTER
        ;LDD    DSKINFO:NBPSM1,X
        LDAB      (DSKINFO:NBPSM1)+1,X
        LDAA      DSKINFO:NBPSM1,X
        ;LDX    IOCBPOINTER
        LDX     IOCBPOINTER
        ANDA      IOCB:CURBYTE+2,X
        ANDB      IOCB:CURBYTE+3,X    (A,B) = IOCB:CURBYTE MOD DSKINFO:NBPS
        ;STD    IOCB:BYTECOUNT,X    WE'LL NEED THIS AGAIN SOON
        STAB      (IOCB:BYTECOUNT)+1,X
        STAA      IOCB:BYTECOUNT,X
        ;LDX    IOCB:DRDSI,X
        LDX     IOCB:DRDSI,X
        ;ADDD    RDSI:SECTORBASE,X
        ADDB      (RDSI:SECTORBASE)+1,X
        ADCA       RDSI:SECTORBASE,X
        ;LDX    IOCBPOINTER       SAVE NEXTBYTE IN IOCB
        LDX     IOCBPOINTER
        ;STD    IOCB:NEXTBYTE,X
        STAB      (IOCB:NEXTBYTE)+1,X
        STAA      IOCB:NEXTBYTE,X
        ;LDX    DCBPOINTER        NOW COMPUTE NBPS - DISPLACMENT INTO SECTOR
        LDX     DCBPOINTER
        ;LDD    DSKINFO:NBPS,X   AND SAVE AS BYTECOUNT
        LDAB      (DSKINFO:NBPS)+1,X
        LDAA      DSKINFO:NBPS,X
        ;LDX    IOCBPOINTER
        LDX     IOCBPOINTER
        ;SUBD    IOCB:BYTECOUNT,X
        SUBB      (IOCB:BYTECOUNT)+1,X
        SBCA       IOCB:BYTECOUNT,X
        ;STD    IOCB:BYTECOUNT,X
        STAB      (IOCB:BYTECOUNT)+1,X
        STAA      IOCB:BYTECOUNT,X
        RTS
        PAGE
*
*       COMPUTERDCNF -- DIVIDES FCB:FILESIZE BY DSKINFO:NBPC
*               EXITS EXACTLY THE SAME AS COMPUTERDCN
*
COMPUTERDCNF ; DIVIDE FCB:FILESIZE BY DSKINFO:NBPC
        ;LDX    FCBPOINTER        COPY FCB:FILESIZE TO (A,B,X)
        LDX     FCBPOINTER
        ;LDD    FCB:FILESIZE,X
        LDAB      (FCB:FILESIZE)+1,X
        LDAA      FCB:FILESIZE,X
        ;LDX    FCB:FILESIZE+2,X
        LDX     FCB:FILESIZE+2,X
        BRA       COMPUTERDCNS      GO COMPUTE RELATIVE DATA CLUSTER NUMBER
*
*       COMPUTERDCN -- DIVIDES IOCB:CURBYTE BY NUMBER OF BYTES PER CLUSTER
*               RETURN RELATIVE DATA CLUSTER NUMBER (QUOTIENT) IN (A,B)
*               DEFINITION: 1 --> FIRST DATA CLUSTER
*               TAKES ERRET IF QUOTIENT >= DSKINFO:NBPC/2
*               LEAVES REMAINDER IN IOCB:RBN
*               RETURNS (X)=IOCBPOINTER
*
COMPUTERDCN       EQU     *
        ;LDX    IOCBPOINTER       COPY IOCB:CURBYTE TO (A,B,X)
        LDX     IOCBPOINTER
        ;LDD    IOCB:CURBYTE,X
        LDAB      (IOCB:CURBYTE)+1,X
        LDAA      IOCB:CURBYTE,X
        ;LDX    IOCB:CURBYTE+2,X
        LDX     IOCB:CURBYTE+2,X
COMPUTERDCNS      ; ENTRY POINT IF DIVIDEND IN (A,B,X)
        STX     TEMP.DIVIDEND   SAVE LOWER 16 BITS OF DIVIDEND
        PSHA             SAVE (A) SO WE CAN SET UP NUMBER OF ITERATIONS
        ;LDX    DCBPOINTER        GET DIVISOR
        LDX     DCBPOINTER
*       ASSERT: NBPC*2^16 > # BYTES IN LARGEST POSSIBLE FILE...
*       SINCE # BYTES/FILE <= (NBPC/2-1)*NBPC, AND NBPC < 2^16
*       THIS MEANS 1ST QUOTIENT BIT WOULD ALWAYS BE ZERO!
*       SO RATHER THAN GENERATE IT, WE SIMPLY SHIFT IN ZERO
        LDAA      #16     # QUOTIENT BITS TO GENERATE
        STAA      COUNT    # QUOTIENT BITS TO GENERATE
        PULA             GET UPPER 16 BITS OF DIVIDEND TO (D)
COMPUTERDCNL      ; GENERATE NEXT QUOTIENT BIT
        ASL      TEMP.DIVIDEND+1 SHIFT A BIT INTO (A,B) ...
        ROL     TEMP.DIVIDEND   FROM REST OF DIVDEND
        ;ROLD
        ROLB
        ROLA
        ;CMPD    DSKINFO:NBPC,X    IS (A,B) ...
        CMPA      DSKINFO:NBPC,X
        BNE      MACRO:0028
        CMPB      (DSKINFO:NBPC)+1,X
MACRO:0028
        BCS       COMPUTERDCN0      B/ < DIVISOR, CARRY IS 1
        ;SUBD    DSKINFO:NBPC,X    QUOTIENT BIT IS ONE (CARRY IS 0)
        SUBB      (DSKINFO:NBPC)+1,X
        SBCA       DSKINFO:NBPC,X
COMPUTERDCN0      ; CARRY = COMPLEMENT QUOTIENT BIT
        ROL     TEMP.QUOTIENT+1 MOVE QUOTIENT BIT INTO QUOTIENT
        ROL     TEMP.QUOTIENT
        ;DEC     COUNT    DOWN COUNT # QUOTIENT BITS TO GENERATE
        DEC      COUNT
        BNE      COMPUTERDCNL      LOOP IF MUST GEN MORE
        ;LDX    IOCBPOINTER       OOOPS! DON'T FORGET THIS!
        LDX     IOCBPOINTER
        ;STD    IOCB:RBN,X STORE REMAINDER FOR LATER USE
        STAB      (IOCB:RBN)+1,X
        STAA      IOCB:RBN,X
        ;LDD    TEMP.QUOTIENT   GET QUOTIENT INTO (A,B)
        LDAB      TEMP.QUOTIENT+1
        LDAA      TEMP.QUOTIENT
        ;NEGD           CONVERT QUOTIENT TO TRUE FORM
        NEGA
        NEGB
        SBCA       #0
*                       AND ADD 1 SINCE ZERO MEANS "HEADER CLUSTER"
        BCS       COMPUTERDCNLIMIT  IS QUOTIENT+1 >= DSKINFO:NBPC/2 ?
        ;ASLD            NOT > 65535; (DOUBLE QUOTIENT+1)
        ASLB
        ROLA
        ;LDX    DCBPOINTER        I.E., IS ( QUOTIENT+1 )*2 >= DSKINFO:NBPC ?
        LDX     DCBPOINTER
        ;CMPD    DSKINFO:NBPC,X    ...?
        CMPA      DSKINFO:NBPC,X
        BNE      MACRO:0029
        CMPB      (DSKINFO:NBPC)+1,X
MACRO:0029
        BCC        COMPUTERDCNLIMIT  B/ YES
        ;LSRD           HALVE DOUBLED QUOTIENT+1 TO GET QUOTIENT+1 BACK
        LSRA
        RORB
        ;LDX    IOCBPOINTER
        LDX     IOCBPOINTER
        OKRTS

COMPUTERDCNLIMIT  EQU     *
        ;JMP    ERRCLUSTERSIZELIMITSFILE
        JMP     ERRCLUSTERSIZELIMITSFILE
        PAGE
*
*       COMPUTERHSN -- COMPUTE RELATIVE HEADER SECTOR NUMBER
*       DIVIDES (A,B) BY (NBPS/2)
*       RETURNS QUOTIENT IN (B)
*       RETURNS (X)=IOCBPOINTER

COMPUTERHSN      EQU     *
        PSHA
        ;LDX    DCBPOINTER
        LDX     DCBPOINTER
        LDAA      DSKINFO:LOG2NBPS,X       GET NBPS POWER OF TWO
        DECA              DIVIDE BY TWO
COMPUTERHSN0     EQU     *
        STAA      TEMPA    SAVE # TIMES TO RIGHT SHIFT
        PULA
COMPUTERHSN1     EQU     *
        ;LSRD           DIVIDE BY 2^LOG2(NBPS)
        LSRA
        RORB
        ;DEC     TEMPA
        DEC      TEMPA
        BNE      COMPUTERHSN1
        ;LDX    IOCBPOINTER
        LDX     IOCBPOINTER
        RTS             EXIT WITH QUOTIENT
*
*       COMPUTERSN  -- COMPUTE SECTOR NUMBER WITHIN CLUSTER
*               DIVIDES (A,B) BY NBPS
*               RETURNS QUOTIENT IN (B)
*               RETURNS (X)=IOCBPOINTER
*
COMPUTERSN       EQU     *
        PSHA
        ;LDX    DCBPOINTER
        LDX     DCBPOINTER
        LDAA      DSKINFO:LOG2NBPS,X
        BRA       COMPUTERHSN0
        PAGE
*
*       CONVERTLCNTOLSN  -- CONVERTS LCN IN (A,B) TO CORRESPONDING LSN
*               ADDS IOCB:DRSN TO RESULT
*               FINAL LSN PLACED IN IOCB:CURLSN
*               DESTROYS SYSSECTORDB
*               RETURNS (X)=IOCBPOINTER
*
CONVERTLCNTOLSN   EQU     *
        BSR      CONVERTLCNTO1ST   FIND LSN OF FIRST SECTOR IN CLUSTER
        ;LDX    IOCBPOINTER       FOR CONVENIENCE
        LDX     IOCBPOINTER
        ADDB      IOCB:DRSN,X       ADD RELATIVE SECTOR # ...
        ADCA       #0      TO RESULT
        BCC        CONVERTLCN2
        ;INC     SYSSECTORDB+SECTORDB:LSN
        INC      SYSSECTORDB+SECTORDB:LSN
CONVERTLCN2       EQU     *
        ;STD    IOCB:CURLSN+1,X    UPDATE IOCB
        STAB      (IOCB:CURLSN+1)+1,X
        STAA      IOCB:CURLSN+1,X
        LDAA      SYSSECTORDB+SECTORDB:LSN    COPY MSB OF DESIRED LSN TO IOCB
        STAA      IOCB:CURLSN,X
        RTS             AND SPLIT
        PAGE
*
*       CONVERTLCNTO1ST -- CONVERTS LCN IN (A,B) TO 1ST LSN IN CLUSTER
*               RESULT PLACED IN SYSSECTORDB+SECTORDB:LSN
*               LOWER 16 BITS RETURNED IN (A,B)
*               (X) POINTS TO SYSSECTORDB, ALL SET TO READ ON EXIT
*
CONVERTLCNTO1ST   EQU     *
        ;STD    TEMP.MPCND       SAVE THE MULTIPLICAND
        STAB      TEMP.MPCND+1
        STAA      TEMP.MPCND
        ;LDX    DCBPOINTER        GET MULTIPLIER FROM DISKINFO
        LDX     DCBPOINTER
        STX     SYSSECTORDB+SECTORDB:DISKINFO       SET UP TO READ THIS SECTOR
        LDAB      DSKINFO:NSPC,X   (I.E., THE CLUSTER SIZE)
        STAB      TEMP.MPR        SAVE THE MULTIPLIER
        LDAA      #8      # MULTIPLIER BITS TO PROCESS
        STAA      COUNT
        CLRA              ZERO THE PARTIAL PRODUCT
        CLRB              ACCUMULATE PRODUCT IN SYSSECTOR+SECTORDB:LSN
CONVERTLCNL       EQU     *
        ;ASLD
        ASLB
        ROLA
************** USE MUL INSTRUCTION IN HERE?????
        ROL     SYSSECTORDB+SECTORDB:LSN    NO OVERFLOW POSSIBLE
        ASL      TEMP.MPR        CHECK NEXT MULTIPLIER BIT
        BCC        CONVERTLCN1       B/ =0, DON'T ADD MULTIPLICAND
        ;ADDD    TEMP.MPCND       =1, ADD MULTIPLICAND TO PARTIAL PRODUCT
        ADDB      TEMP.MPCND+1
        ADCA       TEMP.MPCND
        BCC        CONVERTLCN1       (PROPOGATE CARRY TO 3RD BYTE)
        ;INC     SYSSECTORDB+SECTORDB:LSN
        INC      SYSSECTORDB+SECTORDB:LSN
CONVERTLCN1       EQU     *
        ;DEC     COUNT    DOWN COUNT UNPROCESSED MULTIPLIER BITS
        DEC      COUNT
        BNE      CONVERTLCNL       B/ MORE TO PROCESS
        ;STD    SYSSECTORDB+SECTORDB:LSN+1  SAVE LOWER 16 BITS OF LSN
        STAB      SYSSECTORDB+SECTORDB:LSN+1+1
        STAA      SYSSECTORDB+SECTORDB:LSN+1
        ;LDX    #SYSSECTORDB      AS PROMISED
        LDX     #SYSSECTORDB
        RTS
        PAGE
*
*       GENHLSNPLUSHRSN -- ADD FCB:HLSN TO IOCB:HRSN
*               AND COPY SUM TO IOCB:CURLSN
*               RETURNS (X) = IOCBPOINTER
*
GENHLSNPLUSHRSN EQU     *
        ;LDX    FCBPOINTER        GET LSN OF 1ST SECTOR...
        LDX     FCBPOINTER
        LDAA      FCB:HLSN,X        OF HEADER CLUSTER...
        PSHA             TO (TOS),(A,B)
        ;LDD    FCB:HLSN+1,X
        LDAB      (FCB:HLSN+1)+1,X
        LDAA      FCB:HLSN+1,X
        ;LDX    IOCBPOINTER       ADD HRSN...
        LDX     IOCBPOINTER
        ADDB      IOCB:HRSN,X
        ADCA       #0      PROPOGATE CARRY
        ;STD    IOCB:CURLSN+1,X    AND COPY TO IOCB:CURLSN
        STAB      (IOCB:CURLSN+1)+1,X
        STAA      IOCB:CURLSN+1,X
        PULA
        ADCA       #0
        STAA      IOCB:CURLSN,X
        ;CLR     IOCB:LOCATEDF,X     FORCE "LOCATECURBYTE" AGAIN LATER
        CLR      IOCB:LOCATEDF,X
        RTS
        PAGE     DISK FILE DRIVERS -- DISK I/O
*       READBEHIND -- INITIATES PRE-FETCH OF PREVIOUS LSN IN FILE
*               (X) POINTS TO IOCB
*               INITIATES READ FOR IOCB:CURLSN-1
*               IF IOCB:CURLSN IS OUTSIDE OF IOCB:CURLCN,
*               DOES NOTHING AT ALL
*               DCBPOINTER SELECTS PROPER DISK INFO TABLE

READBEHIND        EQU     *
        ;LDX    IOCBPOINTER
        LDX     IOCBPOINTER
        LDAA      IOCB:DRSN,X       AT 1ST SECTOR OF CLUSTER?
        BEQ      READBEHINDOKRTS   B/ YES, NO READ-BEHIND TO DO!
        BSR      DECIOCB:CURLSN      BACK UP LSN TO PREVIOUS LSN
        ;JSR    READSECTOR        GO INITIATE THE READ
        JSR     READSECTOR
        BCS       READBEHINDERRED   B/ I/O ERROR
*       BSR      INCIOCB:CURLSN      PUT IOCB:LSN BACK LIKE IT WAS
*
*       INCIOCB:CURLSN -- INCREMENTS IOCB:CURLSN
*               NO IDIOT CHECKS
*
*
INCIOCB:CURLSN      EQU     *
        ;LDX    IOCBPOINTER
        LDX     IOCBPOINTER
        ;INC     IOCB:CURLSN+2,X    BUMP LSB
        INC      IOCB:CURLSN+2,X
        BNE      INCIOCB:CURLSNX
        ;INC     IOCB:CURLSN+1,X    PROPOGATE CARRY
        INC      IOCB:CURLSN+1,X
        BNE      INCIOCB:CURLSNX
        ;INC     IOCB:CURLSN,X      AND AGAIN
        INC      IOCB:CURLSN,X
READBEHINDOKRTS   EQU     *
INCIOCB:CURLSNX     EQU     *
        OKRTS

READBEHINDERRED   EQU     *
        BSR      INCIOCB:CURLSN      RESTORE CURLSN TO ORIGINAL VALUE
        ;JMP    ERRORED
        JMP     ERRORED
        PAGE
*
*       READAHEAD -- INITIATES PRE-FETCH FOR NEXT LSN OF FILE
*               (INITIATES WRITE OF LAST SECTOR BUFFER ON LRU QUEUE IF NEEDED [WRITE-AHEAD])
*               INITIATES READ FOR IOCB:CURLSN+1 UNLESS THAT IS OUTSIDE OF IOCB:CURLSN
*               OTHERWISE INITIATES READ FOR APPROPRIATE HEADER CLUSTER SECTOR
*               ASSUMES A LOCATECURBYTE HAS RECENTLY SET UP THE IOCB
*
READAHEAD  EQU     *
*       IF LAST SECTOR IN LRU QUEUE IS NOT BUSY,...
*       AND DISK IT COMES FROM IS NOT BUSY,...
*       AND LAST SECTOR IN LRU QUEUE IS MODIFIED,...
*       INITIATE A WRITE AND RESET THE MODIFIED FLAG; DON'T ISSUE A READ!!
        ;LDX    LASTSECTORREADQ+RDSI:BLINK  GET POINTER TO LAST SECTOR RDSI
        LDX     LASTSECTORREADQ+RDSI:BLINK
        LDAA      RDSI:STATE,X     IS SECTOR IN I/O STATE ?
        ORAA      RDSI:MODIFIED,X OR IS IT MODIFIED ?
        BEQ      READAHEAD0 B/ NEITHER, GO ISSUE A READ!
        LDAA      RDSI:STATE,X     IS THIS SECTOR BUSY?
        BNE      READBEHINDOKRTS   B/ SECTOR IS IN I/O STATE, DON'T USE IT!
*       THIS IS WRITEAHEAD --> RDSI:MODIFIED IS SET!
        ;LDX    RDSI:DISKINFO,X GET DISK DCB ADDRESS (ASSERT: RDSK:DISKINFO <>0)
        LDX     RDSI:DISKINFO,X
        ;LDX    DSKINFO:SECTORDB,X        IS DISK FOR LAST SECTOR BUSY ?
        LDX     DSKINFO:SECTORDB,X
        BNE      READBEHINDOKRTS   B/ YES, DO NADA
        ;LDX    LASTSECTORREADQ+RDSI:BLINK  GET POINTER TO LAST SECTOR RDSI AGAIN
        LDX     LASTSECTORREADQ+RDSI:BLINK
        STX     RDSIPOINTER     IN CASE WE GET A WRITE ERROR
        LDAA      #RDSISTATE:WRITING       MARK SECTOR AS IN I/O STATE
        STAA      RDSI:STATE,X
        ;CLR     RDSI:MODIFIED,X REMOVE THE MODIFIED FLAG
        CLR      RDSI:MODIFIED,X
        ;JSR    DISKWRITE       ISSUE THE WRITE REQUEST
        JSR     DISKWRITE
        BCC        READBEHINDOKRTS   B/ NO ERRORS
        ;JMP    WAITSECTORERRED   GOT WRITE ERROR, GO CLEAN UP THE MESS!
        JMP     WAITSECTORERRED

READAHEAD0 ; TRY TO DO READ-AHEAD
        LDAA      NRDSIS  SHOULD WE DO READ-AHEAD ?
        ;CMPA     #READAHEADRDSIMIN  (ARE THERE ENOUGH BUFFERS ?)
        CMPA      #READAHEADRDSIMIN
        BLT      READBEHINDOKRTS   B/ NOPE, DON'T DO READ-AHEAD
        ;LDX    DCBPOINTER        IS THIS DISK DRIVE ALREADY BUSY ?
        LDX     DCBPOINTER
        ;LDX    DSKINFO:SECTORDB,X        (IF SO, DON'T MAKE US WAIT BY CAUSING MORE DISK I/O!)
        LDX     DSKINFO:SECTORDB,X
        BNE      READBEHINDOKRTS   B/ YES, GIVE UP NOW!
        ;LDX    IOCBPOINTER
        LDX     IOCBPOINTER
        LDAA      IOCB:EOFFLAG,X     AT EOF ?
        BNE      READBEHINDOKRTS   B/ YES, NO POINT IN FETCHING FROM DISK!
        LDAA      IOCB:DRSN,X       GET RELATIVE SECTOR NUMBER OF :CURLSN
        ;LDX    IOCB:DCB,X  =LAST SECTOR IN CLUSTER?
        LDX     IOCB:DCB,X
        SUBA      DSKINFO:NSPC,X   (IOCN:RSN-DSKINFO:NSPC=-1)
        INCA
        BEQ      READAHEADH B/ YES, SO READ AHEAD ON HEADER SECTOR INSTEAD
        ;LDX    IOCBPOINTER       IS THIS CLUSTER ALLOCATED ?
        LDX     IOCBPOINTER
        ;LDX    IOCB:CURLCN,X       ...?
        LDX     IOCB:CURLCN,X
        INX                     ...?
        BEQ      READBEHINDOKRTS   B/ NO, DON'T DO A READ-AHEAD
        BSR      INCIOCB:CURLSN      NO, COMPUTE NEXT LSN IN CLUSTER
        ;JSR    READSECTOR        INITIATE PRE-FETCH
        JSR     READSECTOR
        BCS       READAHEADCERRED     IF AN ERROR OCCURRED, REPORT IT!
*       JSR     DECIOCB:CURLSN
*       OKRTS
*
*       DECIOCB:CURLSN -- DECREMENTS IOCB:CURLSN
*               NO IDIOT CHECKS
*
DECIOCB:CURLSN      EQU     *
        ;LDX    IOCBPOINTER
        LDX     IOCBPOINTER
        LDAA      IOCB:CURLSN+2,X    CHECK LEAST SIG BYTE
        BNE      DECIOCB:CURLSN1     B/ NOT ZERO, NO BORROW
        ;LDD    IOCB:CURLSN,X      RATS, MUST PROPOGATE BORROW
        LDAB      (IOCB:CURLSN)+1,X
        LDAA      IOCB:CURLSN,X
        ;SUBD    #1      SUBTRACT 1 FROM UPPER 16 BITS OF IOCB:CURLSN
        SUBB      #(1)&$FF
        SBCA       #(1)/256
        ;STD    IOCB:CURLSN,X
        STAB      (IOCB:CURLSN)+1,X
        STAA      IOCB:CURLSN,X
DECIOCB:CURLSN1     EQU     *
        ;DEC     IOCB:CURLSN+2,X    DECREMENT LSB OF LSN
        DEC      IOCB:CURLSN+2,X
        OKRTS

READAHEADCERRED     EQU     *
        BSR      DECIOCB:CURLSN      PUT CURLSN BACK LIKE IT WAS
        ;JMP    ERRORED
        JMP     ERRORED
        PAGE
READAHEADH ; DO PREFETCH ON HEADER CLUSTER SECTOR
        ;LDX    IOCBPOINTER       WE CAN'T GET HERE UNLESS IOCB:RDCN IS VALID
        LDX     IOCBPOINTER
        ;LDD    IOCB:RDCN,X        COMPUTE (IOCB:RDCN+1)*2
        LDAB      (IOCB:RDCN)+1,X
        LDAA      IOCB:RDCN,X
        ;ADDD    #1
        ADDB      #(1)&$FF
        ADCA       #(1)/256
        ;ASLD            ...*2
        ASLB
        ROLA
        ;LDX    IOCB:DCB,X  = DSKINFO:NBPC ?
        LDX     IOCB:DCB,X
        ;CMPD    DSKINFO:NBPC,X    ... ?
        CMPA      DSKINFO:NBPC,X
        BNE      MACRO:002A
        CMPB      (DSKINFO:NBPC)+1,X
MACRO:002A
        BEQ      READAHEADOKRTS     B/ YES, WOULD RUN OFF END OF HEADER CLUSTER
        ANDA      DSKINFO:NBPSM1,X TAKE MOD NBPS
        ANDB      DSKINFO:NBPSM1+1,X       BY MASKING AGAINST (2^N)-1
        BNE      READAHEAD1 B/ HAVEN'T RUN OFF END ...
        TSTA             OF CURRENT HEADER SECTOR
        BEQ      READAHEADNX        B/ DID RUN OFF END OF HEADER SECTOR
READAHEAD1 EQU     *
        ;LDX    IOCBPOINTER
        LDX     IOCBPOINTER
        ;LDX    IOCB:HRDSI,X      DESIRED HEADER SECTOR IN MEMORY?
        LDX     IOCB:HRDSI,X
        BEQ      READAHEADHA B/ NO, MUST READ IN
        ;ADDD    RDSI:SECTORBASE,X  YES, FETCH DATA CLUSTER NUMBER
        ADDB      (RDSI:SECTORBASE)+1,X
        ADCA       RDSI:SECTORBASE,X
*       COMPUTE POINTER TO DATA CLUSTER NUMBER
        ;PSHD           COPY POINTER FROM (A,B) TO (X)
        PSHB
        PSHA
        ;JSR    REQUERDSI       MOVE HEADER SECTOR TO TOP OF LRU QUEUE...
        JSR     REQUERDSI
*       BECAUSE IT WORKS WELL
*       IN SPITE OF THE FACT THAT WE DON'T KNOW IF USER WANTS HEADER SECTOR AGAIN!
        ;PULX
        TSX
        LDX     0,X
        INS
        INS
        ;LDD    HEADER:LCN,X      GET LCN OF NEXT DATA CLUSTER
        LDAB      (HEADER:LCN)+1,X
        LDAA      HEADER:LCN,X
        ;LDX    HEADER:LCN,X      UNALLOCATED DATA CLUSTER?
        LDX     HEADER:LCN,X
        INX             (I.E., IS LCN = DUMMYLCN ?)
        BEQ      READAHEADOKRTS     B/ YES, NO DATA TO READ AHEAD ON
        ;JSR    CONVERTLCNTO1ST   FIND 1ST LSN IN NEXT DATA CLUSTER
        JSR     CONVERTLCNTO1ST
        BCS       READAHEADOKRTS     IF OFF END OF WORLD, IGNORE IT!
READAHEADS EQU     *
        ;LDX    #SYSSECTORDB
        LDX     #SYSSECTORDB
        ;JSR    READSECTOR        READ IN THE DATA SECTOR
        JSR     READSECTOR
READAHEADOKRTS     EQU     *
        OKRTS

READAHEADNX        ; MUST READ NEXT HEADER SECTOR
        ;LDX    IOCBPOINTER
        LDX     IOCBPOINTER
        LDAA      IOCB:HRSN,X
        INCA
        BEQ      READAHEADOKRTS     B/ HRSN+1=256, INVALID
        ;LDX    IOCB:FCB,X
        LDX     IOCB:FCB,X
        ;CMPA     FCB:HCSIC,X HRSN+1>=HCSIC?
        CMPA      FCB:HCSIC,X
        BLS      READAHEADH1        NO, GO ISSUE THE READ
        BRA       READAHEADOKRTS     WOULD FETCH UNINITZD HEADER SECTOR

READAHEADHA ; MUST RE-READ CURRENT HEADER SECTOR
        ;LDX    IOCBPOINTER
        LDX     IOCBPOINTER
        LDAA      IOCB:HRSN,X
READAHEADH1        ; READ HEADER SECTOR; RSN IS IN (A)
        ;LDX    FCBPOINTER        COMPUTE FCB:LSN+(A)
        LDX     FCBPOINTER
        ADDA      FCB:HLSN+2,X
        STAA      SYSSECTORDB+SECTORDB:LSN+2
        LDAA      FCB:HLSN+1,X
        ADCA       #0
        STAA      SYSSECTORDB+SECTORDB:LSN+1
        LDAA      FCB:HLSN,X
        ADCA       #0
        STAA      SYSSECTORDB+SECTORDB:LSN    AND COPY INTO SYSSECTOR
        ;LDX    DCBPOINTER        SET UP TO READ FROM CURRENT DISK
        LDX     DCBPOINTER
        STX     SYSSECTORDB+SECTORDB:DISKINFO
        BRA       READAHEADS GO INITIATE THE SECTOR READ
*       DON'T SAVE RDSIPOINTER RETURNED IN IOCB:HRDSI...
*       BECUZ IT MIGHT BE FOR "NEXT" HEADER SECTOR!
        PAGE
*
*       INVENTSECTOR -- ALLOCATES A SECTOR BUFFER WITHOUT READING SECTOR
*               LIKE READSECTOR, BUT DOES NOT DO READ!
*               HOWEVER, IT DOES DO A WAITRDSI TO MAKE SURE THE SECTOR HAS ARRIVED
*               NOTE: CAN BE CALLED TO INVENT SECTOR FOR IMAGINARY DISK (DISKINFO=0)
*
INVENTSECTOR     EQU     *
        CLRA              FLAG "DON'T DO THE READ!"
        BRA       READSECTOR0

*
*       READSECTOR -- INITIATE READ OF DISK SECTOR INTO MEMORY
*               (X) POINTS TO SECTOR DESCRIPTOR (SECTORDB)
*               1)  SEARCH RDSIS TO SEE IF ALREADY IN CORE
*               2)  IF NOT, FIND OLDEST BLOCK; IF MODIFIED, WRITE
*               3)  INIT SECTOR FETCH
*               4)  ZAP ALL IOCBS THAT REFER TO OLDEST BLOCK
*       RETURNS (A,B), (X), RDSIPOINTER POINTING TO RDSI CONTAINING DISK SECTOR
*       NOTE: CALLER MUST LATER DO A "WAITRDSI" TO ENSURE ARRIVAL OF SECTOR!
*       NOTE: CANNOT BE CALLED TO READ A SECTOR FROM IMAGINARY DISK (DISKINFO=0)
*       ERRET INDICATES SOME KIND OF DISK I/O PROBLEM
*
READSECTOR        EQU     *
        LDAA      #1      FLAG "DOING A READSECTOR"
READSECTOR0       EQU     *
        STAA      READFLAG
        STX     READSECTORDBP      SAVE POINTER TO DESCRIPTOR BLOCK
        ;LDD    SECTORDB:LSN+1,X  GET LEAST SIG 16 BITS OF LSN
        LDAB      (SECTORDB:LSN+1)+1,X
        LDAA      SECTORDB:LSN+1,X
        ;LDX    LASTSECTORREADQ+RDSI:FLINK SEARCH RDSI CHAIN
        LDX     LASTSECTORREADQ+RDSI:FLINK
READSECTORL       EQU     *
        ;CMPD    RDSI:LSN+1,X    COMPARE LSB'S FIRST...
        CMPA      RDSI:LSN+1,X
        BNE      MACRO:002B
        CMPB      (RDSI:LSN+1)+1,X
MACRO:002B
        BNE      READSECTORNM      SINCE THEY HAVE HIGHEST PROBABILITY OF NOT MATCHING
        STX     RDSIPOINTER     SAVE X A MOMENT...
        ;LDD    RDSI:DISKINFO,X DO DISKINFO POINTERS MATCH ?
        LDAB      (RDSI:DISKINFO)+1,X
        LDAA      RDSI:DISKINFO,X
        ;LDX    READSECTORDBP      ...?
        LDX     READSECTORDBP
        ;CMPD    SECTORDB:DISKINFO,X       ...?
        CMPA      SECTORDB:DISKINFO,X
        BNE      MACRO:002C
        CMPB      (SECTORDB:DISKINFO)+1,X
MACRO:002C
        BNE      READSECTORNMA      B/ NO
        LDAB      SECTORDB:LSN,X    YES, GRAB MSB OF LSN OF DESIRED SECTOR
        ;LDX    RDSIPOINTER     DOES IT MATCH DESIRED LSN ?
        LDX     RDSIPOINTER
        ;CMPB     RDSI:LSN,X      ... ?
        CMPB      RDSI:LSN,X
        BNE      READSECTORL1      B/ DIDN'T MATCH, AND AFTER ALL THAT EFFORT!
        ;JMP    READSECTORF       WE FOUND IT !!
        JMP     READSECTORF

READSECTORL1      EQU     *
        ;LDX    READSECTORDBP      GET POINTER TO SECTOR DESCRIPTOR
        LDX     READSECTORDBP
READSECTORNMA      ; NO MATCH, RELOAD 16 LSBS OF DESIRED LSN
        ;LDD    SECTORDB:LSN+1,X  GET 16 LSBS OF DESIRED LSN AGAIN
        LDAB      (SECTORDB:LSN+1)+1,X
        LDAA      SECTORDB:LSN+1,X
        ;LDX    RDSIPOINTER     GRAB ADDRESS OF RDSI THAT DIDN'T MATCH
        LDX     RDSIPOINTER
READSECTORNM      ; THIS RDSI ISN'T IT!
        ;LDX    RDSI:FLINK,X    FIND NEXT RDSI
        LDX     RDSI:FLINK,X
        CPX      #LASTSECTORREADQ   END OF RDSI LIST?
        BNE      READSECTORL       B/ NO, CHECK NEXT RDSI
*       MUST DO DISK I/O
*       0) VERIFY THAT LSN IS LEGAL FOR THIS DRIVE
*       1) WAIT FOR DISK SPECIFIED BY TARGET READ BUFFER TO BE DONE
*       2) WRITE TARGET READ BUFFER CONTENTS BACK TO DISK IF MODIFIED
*       3) WAIT FOR DISK OF DESIRED SECTOR TO BE DONE
*       4) ISSUE READ TO GET DISK SECTOR
READSECTORV       ; VERIFY LSN IS LEGAL FOR THIS DRIVE
        ;LDX    READSECTORDBP      GET THE SECTOR NUMBER...
        LDX     READSECTORDBP
        LDAA      SECTORDB:LSN,X
        PSHA
        ;LDD    SECTORDB:LSN+1,X
        LDAB      (SECTORDB:LSN+1)+1,X
        LDAA      SECTORDB:LSN+1,X
        ;LDX    RDSI:DISKINFO,X SUBTRACT NLSN FROM IT..
        LDX     RDSI:DISKINFO,X
        BEQ      READSECTORVD      B/ READ FROM DUMMY DISK, DON'T DO ILLEGAL LSN CHECK
        ;SUBD    DSKINFO:NLSN+1,X
        SUBB      (DSKINFO:NLSN+1)+1,X
        SBCA       DSKINFO:NLSN+1,X
        PULA
        SBCA       DSKINFO:NLSN,X
        BCS       READSECTORVD1     B/ LSN IS LEGAL FOR TARGET DISK
ERRILLLSN
        ;JSR    ERRET
        JSR     ERRET
        FDB      ERR:ILLLSN
        PAGE
READSECTORVD      ; READ FROM DUMMY (VIRTUAL) DISK
        ;LEAS    1,S     POP MSB OF LSN SINCE WE DON'T NEED TO DO ILLEGAL LSN CHECK
        IF      1<0
        RPT     -1
        DES
        ELSE
        RPT     1
        INS
        FIN
READSECTORVD1
        ;LDX    #LASTSECTORREADQ   FIND AVAILABLE SECTOR BUFFER
        LDX     #LASTSECTORREADQ
READSECTOR1       EQU     *
        ;LDX    RDSI:BLINK,X     FIND DCB ADDRESS OF DISK OF LAST SECTOR BUFFER IN QUEUE
        LDX     RDSI:BLINK,X
        LDAA      RDSI:STATE,X     WE ONLY NEED TO WAIT IF TARGET BUFFER IS BUSY...
        ORAA      RDSI:MODIFIED,X OR IT NEEDS TO BE WRITTEN TO THE DISK
        BEQ      READSECTOR3       B/ DON'T NEED TO WAIT FOR TARGET BUFFER
        ;LDX    RDSI:DISKINFO,X GOT IT! (ASSERT: RDSI:DSKINFO <> 0!)
        LDX     RDSI:DISKINFO,X
        ;LDX    DSKINFO:SECTORDB,X        IS TARGET BUFFER'S DISK BUSY ?
        LDX     DSKINFO:SECTORDB,X
        BEQ      READSECTOR2       B/ NO, SEE IF TARGET SECTOR BUFFER IS MODIFIED
        STX     RDSIPOINTER     YES, WAIT FOR IT
        ;JSR    WAITRDSI ...
        JSR     WAITRDSI
READSECTOR2       ; CHECK TO SEE IF TARGET SECTOR BUFFER IS MODIFIED
        ;LDX    LASTSECTORREADQ+RDSI:BLINK  GET ADDRESS OF TARGET RDSI
        LDX     LASTSECTORREADQ+RDSI:BLINK
READSECTOR2L      ; WRITE FROM POOL, OLDEST BUFFER TO NEWEST BUFFER,
*       UNTIL DIFFERENT DISK ENCOUNTERED, BUFFER NOT MODIFIED,
*       OR RDSI:CYLINDER DOESN'T MATCH
        LDAA      RDSI:MODIFIED,X IS IT MODIFIED ?
        BEQ      READSECTOR3       B/ NO, GO WAIT FOR DESIRED DISK TO BECOME FREE
        STX     RDSIPOINTER     YES, ISSUE THE WRITE
        LDAA      #RDSISTATE:WRITING       WHICH MOVES SECTOR BACK TO DISK
        STAA      RDSI:STATE,X     AND FREES UP THIS SECTOR BUFFER
        ;CLR     RDSI:MODIFIED,X MARK SECTOR AS UNCHANGED (TAKES EFFECT AFTER WRITE)
        CLR      RDSI:MODIFIED,X
        ;JSR    DISKWRITE       ISSUE THE ACTUAL WRITE COMMAND
        JSR     DISKWRITE
        BCS       WAITSECTORERRJ    B/ DISK I/O ERROR OCCURRED
        ;LDX    RDSIPOINTER     WAIT FOR WRITE TO FINISH
        LDX     RDSIPOINTER
        ;JSR    WAITSECTOR1       OLD SECTOR CONTENTS ARE NOW GONE!!
        JSR     WAITSECTOR1
        ;LDX    RDSIPOINTER     SEE IF NEXT OLDEST SECTOR IN POOL NEEDS WRITING
        LDX     RDSIPOINTER
        ;LDD    RDSI:CYLINDER,X  ONLY WRITE ANOTHER SECTOR IF IN SAME PHYSICAL CYLINDER
        LDAB      (RDSI:CYLINDER)+1,X
        LDAA      RDSI:CYLINDER,X
        ;LDX    RDSI:BLINK,X     FIND NEXT OLDEST SECTOR
        LDX     RDSI:BLINK,X
        CPX      #LASTSECTORREADQ   EXHAUSTED POOL ?
        BEQ      READSECTOR3       B/ ALL MOD'D SECTORS IN POOL WRITTEN TO DISK
        ;CMPD    RDSI:CYLINDER,X  NO, IS NEXT OLDEST SECTOR IN SAME CYLINDER ?
        CMPA      RDSI:CYLINDER,X
        BNE      MACRO:002D
        CMPB      (RDSI:CYLINDER)+1,X
MACRO:002D
        BEQ      READSECTOR2L      B/ YES, GO SEE IF MODIFIED AND THEN WRITE IT!
**** THIS LOGIC SHOULD ISSUE JUST WRITES, FOLLOWED BY JUST VERIFIES!
READSECTOR3       ; WAIT FOR DESIRED DISK TO BE DONE
        ;LDX    READSECTORDBP      GET DCB ADDRESS OF DESIRED DISK
        LDX     READSECTORDBP
        ;LDX    SECTORDB:DISKINFO,X       ...
        LDX     SECTORDB:DISKINFO,X
        BEQ      READSECTOR4       B/ WISH TO READ FROM DUMMY DISK, IT'S DONE...
        ;LDX    DSKINFO:SECTORDB,X        GET POINTER TO SECTOR BEING PROCESSED
        LDX     DSKINFO:SECTORDB,X
        BEQ      READSECTOR4       B/ DESIRED DISK IS IDLE
        STX     RDSIPOINTER     WAIT FOR DESIRED DISK TO FINISH I/O
        ;JSR    WAITRDSI ...
        JSR     WAITRDSI
READSECTOR4       ; NOW (AT LAST!) READ IN THE DESIRED SECTOR
        ;LDX    READSECTORDBP      GET POINTER TO DESIRED SECTOR ADDRESS
        LDX     READSECTORDBP
        ;LDD    SECTORDB:DISKINFO,X       COPY DISKINFO TO (TOS-1,TOS)
        LDAB      (SECTORDB:DISKINFO)+1,X
        LDAA      SECTORDB:DISKINFO,X
        ;PSHD
        PSHB
        PSHA
        LDAA      SECTORDB:LSN,X    COPY DESIRED SECTOR # TO (TOS),(A,B)
        PSHA
        ;LDD    SECTORDB:LSN+1,X
        LDAB      (SECTORDB:LSN+1)+1,X
        LDAA      SECTORDB:LSN+1,X
        ;LDX    LASTSECTORREADQ+RDSI:BLINK  GET POINTER TO CHOSEN RDSI AGAIN
        LDX     LASTSECTORREADQ+RDSI:BLINK
        STX     RDSIPOINTER     AND REMEMBER IT FOR EVERYBODY'S CONVENIENCE
        ;STD    RDSI:LSN+1,X    STORE SECTOR DESCRIPTION INTO RDSI
        STAB      (RDSI:LSN+1)+1,X
        STAA      RDSI:LSN+1,X
        PULA
        STAA      RDSI:LSN,X
        ;PULD
        PULA
        PULB
        ;STD    RDSI:DISKINFO,X
        STAB      (RDSI:DISKINFO)+1,X
        STAA      RDSI:DISKINFO,X
        LDAA      #$FF    MARK RDSI AS "REQUIRES LSN TO PHYSICAL" MAPPING
        ;STA     RDSI:TRACK,X      (DRIVER CHANGES RDSI:SECTOR, :TRACK, :CYLINDER BY DOING MAPPING)
        STAA      RDSI:TRACK,X
        ;CLR     RDSI:CYLINDER,X  SET CYLINDER TO CONSTANT...
        CLR      RDSI:CYLINDER,X
        ;CLR     RDSI:CYLINDER+1,X        IN CASE DRIVER DOES NOT FILL IN CYLINDER NUMBER
        CLR      RDSI:CYLINDER+1,X
        LDAA      READFLAG  INVENTING A SECTOR ? (RDSI:STATE = "IDLE" WHEN WE GET HERE)
        BEQ      READSECTORI       B/ YES, DON'T BOTHER READING IT IN
        LDAA      #RDSISTATE:READING        MARK SECTOR AS BEING READ
        STAA      RDSI:STATE,X
        ;JSR    DISKREAD INITIATE SECTOR FETCH
        JSR     DISKREAD
        BCC        READSECTORR       B/ NO ERROR IN STARTING THE DISK I/O
WAITSECTORERRJ    EQU     *
        ;JMP    WAITSECTORERRED
        JMP     WAITSECTORERRED

READSECTORI       ; INVENTING A SECTOR
        ;JSR    WAITRDSI IN THE RARE CASE THAT WE WISH TO INVENT...
        JSR     WAITRDSI
*                       A SECTOR THAT SOMEBODY DID A READ-AHEAD ON!
READSECTORR       EQU     *
        BSR      REMOVERDSI      DELETE ALL OLD REFERENCES TO RDSI
READSECTORF       ; WE FOUND IT !
        ;LDX    RDSIPOINTER     MAKE THIS SECTOR THE MOST RECENTLY READ
        LDX     RDSIPOINTER
        BSR      REQUERDSI1
        ;LDX    RDSIPOINTER     EXIT WITH POINTER IN (X)...
        LDX     RDSIPOINTER
        ;LDD    RDSIPOINTER     AND (A,B)
        LDAB      RDSIPOINTER+1
        LDAA      RDSIPOINTER
        OKRTS
        PAGE
*       REMOVERDSI -- REMOVE RDSIPOINTER FROM ALL IOCBS...
*       THAT HAVE REFERENCES TO IT
*
REMOVERDSI      EQU     *
        ;LDX    CODE+SDOS:CONFIGURATION
        LDX     CODE+SDOS:CONFIGURATION
        LDAA      CNFG:NIOCHANNELS,X FIND OUT HOW MANY IOCBS TO SCAN
        STAA      REMOVESECTORCNT
        ;LDX    CNFG:IOCBPOINTERS,X        SET UP TO SCAN IOCB POINTER TABLE
        LDX     CNFG:IOCBPOINTERS,X
        ;LDD    RDSIPOINTER     GET TARGET RDSI ADDRESS TO (A,B)
        LDAB      RDSIPOINTER+1
        LDAA      RDSIPOINTER
REMOVERDSIL     EQU     *
        STX     REMOVEIOCBPTR     SAVE IOCB POINTER LIST SCANNER
        ;LDX    ,X      GET REAL IOCB POINTER
        LDX     0,X
        BSR      READSECTORZAPIOCB    REMOVE RDSI FROM IOCB
        ;LDX    REMOVEIOCBPTR     GET LIST SCAN POINTER
        LDX     REMOVEIOCBPTR
        ;LEAX    2,X     BUMP TO NEXT IOCB POINTER
        IF      2<0
        RPT     -2
        DEX
        ELSE
        RPT     2
        INX
        FIN
        ;DEC     REMOVESECTORCNT   DOWN COUNT # IOCBS TO CHECK
        DEC      REMOVESECTORCNT
        BNE      REMOVERDSIL     B/ MORE TO CHECK
        ;LDX    #SYSIOCB  CHECK SYSIOCB OUT, TOO!
        LDX     #SYSIOCB
        BSR      READSECTORZAPIOCB    REMOVE RDSI FROM IT IF IN USE
        ;LDX    #LOGIOCB  REMOVE RDSI FROM LOG FILE IF IN USE
        LDX     #LOGIOCB
        BSR      READSECTORZAPIOCB
        ;LDX    RDSIPOINTER     FOR THE CONVENIENCE OF THE CALLER
        LDX     RDSIPOINTER
        RTS
        PAGE
*       READSECTORZAPIOCB -- REMOVE MATCHING RDSI POINTER REFERENCES
*       (A,B) ON ENTRY CONTAIN RDSI ADDRESS TO REMOVE FROM IOCB(X)
*
READSECTORZAPIOCB    EQU     *
        STX     TEMPX   SAVE IOCB TO TEST
        ;LDX    IOCB:DRIVER,X     FIND OUT WHICH DRIVER OWNS THIS IOCB
        LDX     IOCB:DRIVER,X
        CPX      #DISKFILEDRIVER DO HIGH PROBABILITY TEST FIRST
        BEQ      READSECTORZAPH     B/ DISK FILE DRIVER, CHECK HRDSI
        CPX      #DISKDEVICEDRIVER        LOW PROBABILITY TEST
        BEQ      READSECTORZAPD     B/ DISK DEVICE DRIVER, JUST CHECK DRDSI
        RTS             NOT OPEN TO A DISK DRIVER, JUST QUIT!

READSECTORZAPH     ; CHECK HRDSI OF IOCB
        ;LDX    TEMPX
        LDX     TEMPX
        ;CMPD    IOCB:HRDSI,X      (A,B) MATCH HRDSI ?
        CMPA      IOCB:HRDSI,X
        BNE      MACRO:002E
        CMPB      (IOCB:HRDSI)+1,X
MACRO:002E
        BNE      READSECTORZAPD1    B/ NO
        ;CLR     IOCB:HRDSI,X      YES, MARK HRDSI AS INVALID
        CLR      IOCB:HRDSI,X
        ;CLR     IOCB:HRDSI+1,X
        CLR      IOCB:HRDSI+1,X
READSECTORZAPD     EQU     *
        ;LDX    TEMPX   RESTORE (X) TO IOCB POINTER
        LDX     TEMPX
READSECTORZAPD1    ; ENTER HERE IF (X) IS ALREADY SET UP
        ;CMPD    IOCB:DRDSI,X      (A,B) MATCH DRDSI ?
        CMPA      IOCB:DRDSI,X
        BNE      MACRO:002F
        CMPB      (IOCB:DRDSI)+1,X
MACRO:002F
        BNE      READSECTORZAPRTS   B/ NO
        ;CLR     IOCB:DRDSI,X      YES, MARK DRDSI AS INVALID
        CLR      IOCB:DRDSI,X
        ;CLR     IOCB:DRDSI+1,X
        CLR      IOCB:DRDSI+1,X
READSECTORZAPRTS   EQU     *
        RTS
        PAGE
*       REQUERDSI -- REQUE RDSI(X) ONTO TOP OF QUEUE
*       USED TO IMPLEMENT LRU POLICY OF DISK SECTOR BUFFER MANAGEMENT
*
REQUERDSI       ; FIRST, TAKE IT OUT OF THE QUEUE
        STX     RDSIPOINTER     SAVE THE RDSI ADDRESS
REQUERDSI1      ; IF RDSIPOINTER AND (X) ARE ALREADY SET UP
        ;LDD    RDSI:FLINK,X    MAKE FLINK(BLINK(X))=FLINK(X)
        LDAB      (RDSI:FLINK)+1,X
        LDAA      RDSI:FLINK,X
        ;LDX    RDSI:BLINK,X
        LDX     RDSI:BLINK,X
        ;STD    RDSI:FLINK,X
        STAB      (RDSI:FLINK)+1,X
        STAA      RDSI:FLINK,X
        ;LDX    RDSIPOINTER     MAKE BLINK(FLINK(X))=BLINK(X)
        LDX     RDSIPOINTER
        ;LDD    RDSI:BLINK,X
        LDAB      (RDSI:BLINK)+1,X
        LDAA      RDSI:BLINK,X
        ;LDX    RDSI:FLINK,X
        LDX     RDSI:FLINK,X
        ;STD    RDSI:BLINK,X
        STAB      (RDSI:BLINK)+1,X
        STAA      RDSI:BLINK,X
        ;LDX    RDSIPOINTER     SO WE CAN DO THE ENQUE
        LDX     RDSIPOINTER
*       BSR      ENQUELASTSECTORREAD
*       RTS
*
*       ENQUELASTSECTORREAD -- ADD RDSI(X) TO TOP OF LASTSECTORREADQ
*
ENQUELASTSECTORREAD        EQU     *
        ;LDD    LASTSECTORREADQ+RDSI:FLINK
        LDAB      LASTSECTORREADQ+RDSI:FLINK+1
        LDAA      LASTSECTORREADQ+RDSI:FLINK
        ;STD    RDSI:FLINK,X    MAKE FLINK(X) := FLINK(QHEAD)
        STAB      (RDSI:FLINK)+1,X
        STAA      RDSI:FLINK,X
        ;LDD    #LASTSECTORREADQ   MAKE BLINK(X) := ADDRESS(QHEAD)
        LDAB      #(LASTSECTORREADQ)&$FF
        LDAA      #(LASTSECTORREADQ)/256
        ;STD    RDSI:BLINK,X
        STAB      (RDSI:BLINK)+1,X
        STAA      RDSI:BLINK,X
        STX     LASTSECTORREADQ+RDSI:FLINK MAKE FLINK(QHEAD) := X
        ;LDD    LASTSECTORREADQ+RDSI:FLINK BLINK(FLINK(X)) := X
        LDAB      LASTSECTORREADQ+RDSI:FLINK+1
        LDAA      LASTSECTORREADQ+RDSI:FLINK
        ;LDX    RDSI:FLINK,X
        LDX     RDSI:FLINK,X
        ;STD    RDSI:BLINK,X
        STAB      (RDSI:BLINK)+1,X
        STAA      RDSI:BLINK,X
        RTS             AND EXIT
        PAGE
*       FETCHSECTOR -- INITIATE READ FOR AND THEN WAIT FOR SECTOR ARRIVAL
*       (X) POINTS TO SECTOR DESCRIPTOR
*
FETCHSECTOR       EQU     *
        ;JSR    READSECTOR        GO START THE SECTOR READ
        JSR     READSECTOR
        BRA       WAITSECTOR1       THEN GO WAIT FOR IT TO ARRIVE
*
*       WAITSECTOR -- WAIT FOR SECTOR WHOSE RDSI IS IN (X)
*       SETS RDSIPOINTER TO (X)
*       MOVES RDSI TO TOP OF LRU QUEUE
*       DOES WAIT ONLY IF RDSI SAYS "NOT IDLE"
*       RETURNS (X) = RDSIPOINTER
*
WAITSECTOR        EQU     *
        BSR      REQUERDSI       MOVE RDSI TO TOP OF LRU QUEUE
WAITRDSI ; WAIT FOR RDSI SELECTED BY RDSIPOINTER
        ;LDX    RDSIPOINTER     CHECK OUT STATE OF RDSI
        LDX     RDSIPOINTER
        LDAA      RDSI:DISKINFO,X DUMMY DISKINFO TABLE ?
        BEQ      WAITSECTORRTS     B/ YES, IGNORE IT.
        LDAA      RDSI:STATE,X     IDLE ?
        BEQ      WAITSECTORRTS     B/ YES, TAKE QUICK EXIT!
WAITSECTOR1       ; WAIT FOR ARRIVAL OF SECTOR
        ;CLR     RDSI:STATE,X     RESET SECTOR STATE TO "IDLE"
        CLR      RDSI:STATE,X
        ;JSR    DISKWAITD        WAIT FOR DISK TRANSFER COMPLETED
        JSR     DISKWAITD
        BCS       WAITSECTORERRED   B/ WE GOT A PROBLEM!
        ;LDX    RDSIPOINTER     SO (X) IS CORRECT ON EXIT
        LDX     RDSIPOINTER
WAITSECTORRTS     EQU     *
        OKRTS

WAITSECTORERRED   ; DISK I/O ERROR OCCURRED
        ;PSHX           SAVE THE ERROR CODE!
        STX     TEMPX
        LDAB      TEMPB
        PSHB
        LDAB      TEMPA
        PSHB
        ;LDX    RDSIPOINTER
        LDX     RDSIPOINTER
        ;CLR     RDSI:DISKINFO,X CAN'T DO I/O, LSN IN RDSI IS NOW A LIE!
        CLR      RDSI:DISKINFO,X
        ;CLR     RDSI:DISKINFO+1,X       MARK RDSI AS COMING FROM "MAGIC 0" DISK
        CLR      RDSI:DISKINFO+1,X
        LDAA      #1      (BECAUSE WE WANT SOMETHING NON-ZERO)
        STAA      RDSI:LSN,X      MAKE LSN <> 0 SO WE DON'T THINK ITS THE MAGIC 0 SECTOR
        ;CLR     RDSI:STATE,X     MARK SECTOR AS BEING INACTIVE
        CLR      RDSI:STATE,X
        ;CLR     RDSI:MODIFIED,X THIS SHOULD BE REDUNDANT, BUT MAKES ME FEEL SAFE!
        CLR      RDSI:MODIFIED,X
        ;JSR    REMOVERDSI      REMOVE ANY REFERENCES TO RDSI FROM IOCBS
        JSR     REMOVERDSI
        ;PULX           GET THE ERROR CODE BACK...
        TSX
        LDX     0,X
        INS
        INS
        ;JMP    ERRORINX        GO TELL SOMEBODY WE HAD A PROBLEM!
        JMP     ERRORINX
        PAGE
*
*       DSKDUMPBUFFERS -- WRITE MODIFIED SECTORS BACK TO DISK
*               WRITE CONTENTS OF MODIFIED FCBS BACK TO CORRESPONDING DIRECTORY ENTRIES
*               WRITES ONLY RDSI'S WHOSE DISKINFO POINTER MATCHES "DCBPOINTER"
*               ALSO FORCES CONTENTS OF MATCHING DISK FCB'S BACK TO DIRECTORY SECTORS
*               ERRET TAKEN IF SOME FCB IS FOR A NEWLY CREATED FILE
*                       SECTORS ARE DUMPED ANYWAY
*               WAIT FOR ALL DISK I/O DONE
*               DSKDUMPBUFFERS IS GENERALLY DONE WHEN MAPALGORITHM IS ABOUT TO BE CHANGED
*
DSKDUMPBUFFERS   EQU     *
        LDAA      NFCBS     GET # FCBS TO SEARCH
        STAA      COUNT    AND SAVE AS LOOP COUNTER
        ;LDX    CODE+SDOS:CONFIGURATION    NOW SCAN ALL THE FCBS
        LDX     CODE+SDOS:CONFIGURATION
        ;LDD    [CNFG:IOCBPOINTERS,X]      FIND ADDRESS OF FIRST FCB
        LDX     CNFG:IOCBPOINTERS,X
        LDAB      1,X
        LDAA      0,X
DSKDUMPFCBL       EQU     *
        ;SUBD    #FCB:SIZE =ADDRESS OF PREVIOUS FCB - FCB:SIZE
        SUBB      #(FCB:SIZE)&$FF
        SBCA       #(FCB:SIZE)/256
        ;STD    FCBPOINTER        STORE FCB ADDRESS
        STAB      FCBPOINTER+1
        STAA      FCBPOINTER
        ;LDX    FCBPOINTER        IS THIS FCB ACTIVE ?
        LDX     FCBPOINTER
        LDAA      FCB:REFCOUNT,X     ... ?
        BEQ      DSKDUMPFCB1       B/ NO, IGNORE IT
        LDAA      FCB:FLAGS,X        YES, GET FILE STATUS FLAGS
        BITA      #FCBFLG::NEWFILE  A NEW FILE ?
        BNE      DSKDUMPFCB1       B/ YES, DON'T UPDATE DIRECTORY
        ;LDX    FCB:DISKINFO,X    IS THIS FCB FOR REQUESTED DISK ?
        LDX     FCB:DISKINFO,X
        CPX      DCBPOINTER        ...?
        BNE      DSKDUMPFCB1       B/ NO, IGNORE IT
        LDAA      COUNT            SAVE # FCBS TO LOOK AT
        PSHA
        ;JSR    UPDATEDIRFROMFCB   YES, UPDATE THE DIRECTORY
        JSR     UPDATEDIRFROMFCB
        BCS       DSKDUMPERR1     B/ ERROR OCCURRED, YUK!
        PULA             RESTORE COUNT
        STAA      COUNT
DSKDUMPFCB1       ; THROUGH WITH THIS FCB
        ;LDD    FCBPOINTER        GET FCB ADDRESS
        LDAB      FCBPOINTER+1
        LDAA      FCBPOINTER
        ;DEC     COUNT
        DEC      COUNT
        BNE      DSKDUMPFCBL       B/ MORE FCBS TO SEARCH
*       WE CANNOT DO A DSKDUMPBUFFER SAFELY UNLESS WE KNOW
*       THAT ALL I/O ON THE DRIVE (SUCH AS READ-AHEAD) IS COMPLETED.
        ;LDX    DCBPOINTER        COMPLETE ANY I/O ON THIS DRIVE
        LDX     DCBPOINTER
        ;LDX    DSKINFO:SECTORDB,X        I/O ACTIVE ON THIS DISK DRIVE ?
        LDX     DSKINFO:SECTORDB,X
        BEQ      DSKDUMPBUF0      B/ NO
        STX     RDSIPOINTER     IN CASE WE GO TO WAITSECTORERRED
        ;JSR    WAITRDSI NOW WAIT FOR I/O OPERATION COMPLETE
        JSR     WAITRDSI
DSKDUMPBUF0      ; I/O ON DISK DRIVE IS COMPLETED
        ;LDX    LASTSECTORREADQ+RDSI:FLINK SCAN RDSI LIST
        LDX     LASTSECTORREADQ+RDSI:FLINK
DSKDUMPBUFL      EQU     *
        STX     RDSIPOINTER     YES, SAVE POINTER TO RDSI'S
        ;LDX    RDSI:DISKINFO,X CORRECT DISK ?
        LDX     RDSI:DISKINFO,X
        CPX      DCBPOINTER        ...?
        BNE      DSKDUMPBUFN      B/ NO, IGNORE RDSI
        ;LDX    RDSIPOINTER     NOW DO A WRITE...
        LDX     RDSIPOINTER
        LDAA      RDSI:MODIFIED,X IF THIS SECTOR MODIFIED
        BEQ      DSKDUMPBUFN      B/ NO, LEAVE RDSI ALONE
        ;CLR     RDSI:MODIFIED,X FORCE TRANSITION FROM "MODIFIED" TO "BEING WRITTEN"
        CLR      RDSI:MODIFIED,X
        LDAA      #RDSISTATE:WRITING       MARK RDSI AS BEING WRITTEN
        STAA      RDSI:STATE,X
        BSR      DISKWRITE       OF MODIFIED SECTOR
        BCS       WAITSECTORERRJ2   B/ RATS, WE GOT AN I/O ERROR
        ;JSR    WAITRDSI NOW WAIT FOR DISK I/O COMPLETE
        JSR     WAITRDSI
DSKDUMPBUFN      EQU     *
        ;LDX    RDSIPOINTER
        LDX     RDSIPOINTER
        ;LDX    RDSI:FLINK,X    FIND NEXT RDSI
        LDX     RDSI:FLINK,X
        CPX      #LASTSECTORREADQ   HIT END OF RDSI LIST?
        BNE      DSKDUMPBUFL      B/ NO, GO CHECK NEXT RDSI
        OKRTS           NO

DSKDUMPERR1
        INS             THROW AWAY THE SAVED COUNT
        ;JMP    ERRORED AND PASS THE ERROR ON...
        JMP     ERRORED

WAITSECTORERRJ2   EQU     *
        ;JMP    WAITSECTORERRED
        JMP     WAITSECTORERRED

        PAGE
        IF      SWAPPING WHICH WE'RE NOT!
*       READDIRECT -- READ IOCB:LSN INTO BUFFER(IOCB:BUFFERP)
*               IF IOCB:LSN DOES NOT EXIST, ZEROS NBPS BYTES
*               IOCB:LOCATEDF MUST BE SET ON ENTRY
*
READDIRECT        EQU     *
        ;LDX    IOCBPOINTER       CHECK VALIDITY OF CURLSN
        LDX     IOCBPOINTER
        ;LDX    IOCB:CURLCN,X       IF CURLCN IS VALID,
        LDX     IOCB:CURLCN,X
        INX             SO IS CURLSN
        BNE      READDIRECT1       B/ CURLCN IS VALID (<>-1)
        ;LDX    DCBPOINTER        OOPS, NO SUCH CLUSTER!
        LDX     DCBPOINTER
        CLRA              ZERO A SECTOR'S WORTH
        CLRB              GET -NBPS TO (A,B)
        ;SUBD    DSKINFO:NBPS,X
        SUBB      (DSKINFO:NBPS)+1,X
        SBCA       DSKINFO:NBPS,X
        ;LDX    IOCBPOINTER
        LDX     IOCBPOINTER
        ;LDX    IOCB:BUFFERP,X
        LDX     IOCB:BUFFERP,X
        ;JMP    STAASECTORL        AND LET ZERO SECTOR DO THE WORK
        JMP     STAASECTORL

READDIRECT1       ; VALID CLUSTER # ENCOUNTERED
        ;LDX    IOCBPOINTER       SO READ THE LSN INDICATED
        LDX     IOCBPOINTER
*       BSR      DISKREAD
*       OKRTS
        FIN
        PAGE
*
*       DISKREAD -- INITIATE READ DISK SECTOR SPECIFIED BY SECTORDB(X)
*       NOTE: DISKREAD, DISKWRITE, AND DISKWAITD ROUTINES MUST NOT BE
*       CALLED WITH SECTORDB FOR DUMMY DISK!
*       ASSERT: DSKINFO:SECTORDB = 0
*       PRESERVES DCBPOINTER
*
*
DISKREAD EQU     *
        BSR      DISKRWCOPYARGS    COPY ARGUMENTS TO INFO BLOCK
        ;LDD    DRIVER:DISKREAD,X        GET ADDRESS OF DISKREAD ENTRY POINT TO (A,B)
        LDAB      (DRIVER:DISKREAD)+1,X
        LDAA      DRIVER:DISKREAD,X
        BSR      SECTORDRIVER     SET (X) = DCBPOINTER AND PASS CONTROL TO DISKREAD
        BCC        DISKDCBUNSAVE      B/ NO ERROR
        BRA       DISKWAITE        B/ WE GOT AN ERROR, YUK
*
*       DISKWRITE -- INITIATE WRITE DISK SECTOR OF SECTORDB(X)
*       ASSERT: DSKINFO:SECTORDB = 0
*       PRESERVES DCBPOINTER
*
DISKWRITE       EQU     *
        BSR      DISKRWCOPYARGS
        ;LDD    DRIVER:DISKWRITE,X      GET ADDRESS OF DISKWRITE ROUTINE TO (A,B)
        LDAB      (DRIVER:DISKWRITE)+1,X
        LDAA      DRIVER:DISKWRITE,X
        BSR      SECTORDRIVER     SET (X) = DCBPOINTER AND PASS CONTROL TO (A,B)
        BCC        DISKDCBUNSAVE      B/ NO ERROR
        BRA       DISKWAITE        B/ WE GOT AN ERROR!
*
*       DISKWAITD -- WAIT FOR DISK I/O COMPLETE ON DRIVE SECTORDB(X)
*       PRESERVES DCBPOINTER
*
DISKWAITD        EQU     *
        BSR      DISKDCBSAVE        SAVE CURRENT VALUE OF DCB AND SET TO SECTORDB:DISKINFO
        ;LDX    DCB:DRIVER,X      GET ADDRESS OF DISKWAIT ROUTINE TO (A,B)
        LDX     DCB:DRIVER,X
        ;LDD    DRIVER:DISKWAIT,X
        LDAB      (DRIVER:DISKWAIT)+1,X
        LDAA      DRIVER:DISKWAIT,X
        BSR      SECTORDRIVER     SET (X) = DCBPOINTER AND PASS CONTROL
        BCC        DISKWAITD2       B/ NO ERROR
DISKWAITE        ; DISK I/O ERROR OCCURRED
        ;JSR    ERRORSAVE        SAVE THE ERROR CODE
        JSR     ERRORSAVE
        CPX      #ERR:DISKREAD    CHECK FOR "CAN'T GET SECTOR" ERROR
        BEQ      DISKWAITE1       B/ CAN'T READ IT...
        CPX      #ERR:DISKWRITE  CHECK FOR "CAN'T CHANGE IT" ERROR
        BNE      DISKWAITE2       B/ ISN'T READ OR WRITE ERROR, DON'T MARK SECTOR AS BAD
DISKWAITE1       ; DISK READ OR DISK WRITE ERROR, MARK SECTOR AS BAD
        ;LDX    DCBPOINTER        SAVE BAD LSN FROM RDSI
        LDX     DCBPOINTER
        ;LDX    DSKINFO:SECTORDB,X        COPY BAD LSN TO (TOS,A,B)
        LDX     DSKINFO:SECTORDB,X
        LDAA      SECTORDB:LSN,X
        PSHA
        ;LDD    SECTORDB:LSN+1,X
        LDAB      (SECTORDB:LSN+1)+1,X
        LDAA      SECTORDB:LSN+1,X
        ;LDX    DCBPOINTER
        LDX     DCBPOINTER
        ;STD    DSKINFO:BADLSN+1,X
        STAB      (DSKINFO:BADLSN+1)+1,X
        STAA      DSKINFO:BADLSN+1,X
        PULA
        STAA      DSKINFO:BADLSN,X
DISKWAITE2       ; FINISH UP ERROR HANDLING
        BSR      DISKWAITD2       MARK DISK DRIVER AS "NOT BUSY"
        ;JMP    ERRORED AND GO CROAK
        JMP     ERRORED

DISKWAITD2       ; MARK DISK DRIVER AS "NOT BUSY"
        ;LDX    DCBPOINTER        BY ZEROING DSKINFO:SECTORDB
        LDX     DCBPOINTER
        ;CLR     DSKINFO:SECTORDB,X
        CLR      DSKINFO:SECTORDB,X
        ;CLR     DSKINFO:SECTORDB+1,X
        CLR      DSKINFO:SECTORDB+1,X
DISKDCBUNSAVE      ; RESTORE DCB POINTER TO ORIGINAL VALUE
        ;LDX    DCBPTRSAVE NEED I SAY MORE?
        LDX     DCBPTRSAVE
        STX     DCBPOINTER        (THIS CODE MUST PRESERVE THE CARRY BIT!)
        RTS
        PAGE
*
*       DISKRWCOPYARGS -- COPY SECTORDB ADDRESS TO DISKINFO BLOCK
*               SAVES CURRENT VALUE OF DCBPOINTER; SETS DCBPOINTER TO SECTORDB:DISKINFO,X
*
DISKRWCOPYARGS    EQU     *
        BSR      DISKDCBSAVE        SAVE CURRENT DCB AND SET UP FROM SECTORDB:
        ;LDD    TEMPX   INTO DISKINFO TABLEI SO WE CAN FIGURE OUT WHICH RDSI GOT AN ERROR
        LDAB      TEMPX+1
        LDAA      TEMPX
        ;STD    DSKINFO:SECTORDB,X        WHEN WE DO A DISKWAITD!
        STAB      (DSKINFO:SECTORDB)+1,X
        STAA      DSKINFO:SECTORDB,X
        ;LDX    DCB:DRIVER,X      GET DRIVER VECTOR ENTRY POINT TO (X)
        LDX     DCB:DRIVER,X
        RTS
*
*       DISKDCBSAVE -- SAVE CURRENT VALUE OF DCBPOINTER
*               SET TEMPX TO (X)
*               SET DCBPOINTER TO SECTORDB:DISKINFO,X
*               PRESERVE (X)
*
DISKDCBSAVE        EQU     *
        STX     TEMPX   SAVE POINTER TO SECTORDB:...
        ;LDX    DCBPOINTER        SAVE THE CURRENT VALUE OF THE DCBPOINTER
        LDX     DCBPOINTER
        STX     DCBPTRSAVE
        ;LDX    TEMPX   GET SECTORDB: POINTER AGAIN
        LDX     TEMPX
        ;LDX    SECTORDB:DISKINFO,X       AND SET UP DCB POINTER FROM SECTORDB:
        LDX     SECTORDB:DISKINFO,X
        STX     DCBPOINTER
        RTS
*
*       SECTORDRIVER -- LOADS (X) WITH DCBPOINTER; PASS CONTROL TO (A,B)
*
SECTORDRIVER     EQU     *
        ;PSHD           SET UP FAKE RETURN ADDRESS
        PSHB
        PSHA
        ;LDX    DCBPOINTER        AS PROMISED
        LDX     DCBPOINTER
        RTS             PASS CONTROL
        PAGE     BLOCK MOVE UP ROUTINE
        IF      M6800!M6801
LIMIT   EQU     4       TRANSFER LIMIT ADDRESS
BLOCKMOVEX        EQU     6       SCRATCH PAD LOCATIONS

BLOCKMOVE ; PRESERVES DCBPOINTER
*       BLOCKMOVEDOWN -- MOVE BLOCK AT (X) TO (Y) FOR (D) BYTES
*       (Y) = LOCATION ZERO
*       ON EXIT, (X) IS OLD (X)+(D)
*                (Y) IS OLD (Y)+(D)
*       COPIES LARGE BLOCKS AT 17uS. PER BYTE
*       ASSUMES COPY-TO REGION DOES NOT OVERLAP COPY-FROM REGION
*       OR THAT "FROM" >= "TO"
*
BLOCKMOVEDOWN     EQU     *
        STX     FROMPOINTER     SAVE WHERE TO COPY FROM
        ;ADDD    FROMPOINTER     COMPUTE ADDRESS OF BYTE PAST END OF FROM RE
        ADDB      FROMPOINTER+1
        ADCA       FROMPOINTER
        ;STD    LIMIT   SAVE AS LIMIT ADDRESS
        STAB      LIMIT+1
        STAA      LIMIT
        ;LDD    DCBPOINTER        SAVE DCB POINTER
        LDAB      DCBPOINTER+1
        LDAA      DCBPOINTER
        ;PSHD
        PSHB
        PSHA
        ;LDB     LIMIT+1 RESTORE (B)...
        LDAB      LIMIT+1
        SUBB      FROMPOINTER+1   (B):= COUNT MOD 256
        BITB      #%00000001      GOING TO MOVE TO AN EVEN NUMBER OF BYTES ?
        BEQ      BLOCKMOVEDOWNE    B/ YES
        ;LDA     ,X+     FETCH ODD BYTE FROM "FROM" AREA
        LDAA      0,X
        INX
        STX     FROMPOINTER     (TO COPY ODD BYTE TAKES 37 CYCLES)
        ;LDX    TOPOINTER       STORE BYTE INTO "TO" AREA
        LDX     TOPOINTER
        ;STA     ,X+
        STAA      0,X
        INX
        STX     TOPOINTER
        ;LDX    FROMPOINTER     GET SET TO MOVE BYTE PAIR
        LDX     FROMPOINTER
BLOCKMOVEDOWNE    ; EVEN NUMBER OF BYTES LEFT TO MOVE
        BITB      #%00000010      TWO BYTES LEFT TO MOVE BEFORE MULTIPLE OF 4 REACHED ?
        BEQ      BLOCKMOVEDOWNA     B/ NO, READY TO MOVE MULTIPLES OF 4 BYTES
        ;LDD    ,X++    FETCH BYTE PAIR
        LDAB      (0)+1,X
        LDAA      0,X
        INX
        INX
        STX     FROMPOINTER     (TO COPY BYTE PAIR TAKES 28 CYCLES/BYTE)
        ;LDX    TOPOINTER       WHERE TO PUT BYTE PAIR
        LDX     TOPOINTER
        ;STD    ,X++
        STAB      (0)+1,X
        STAA      0,X
        INX
        INX
        STX     TOPOINTER
        ;LDX    FROMPOINTER     GET SET TO MOVE 4 BYTES AT A TIME
        LDX     FROMPOINTER
BLOCKMOVEDOWNA     LDAB      FROMPOINTER+1   DO WE STILL HAVE TO MOVE A MULTIPLE OF 16 BYTES
        SUBB      LIMIT+1 (B):= COUNT MOD 256
        BITB      #%00001111      ....?
        BEQ      BLOCKMOVEDOWNB     B/ YEP.
*
*       MOVE 4 BYTES AT A TIME UNTIL A MULTIPLE OF 16 IS LEFT TO MOVE
*       COPY RATE IS 23.5 uS. PER BYTE
*
BLOCKMOVEDOWN4    ;LDD    2,X     GET 2ND AND 3RD BYTE...
        LDAB      (2)+1,X
        LDAA      2,X
        ;LDX    ,X      AND 1ST AND 2ND BYTES FROM THE "FROM" AREA
        LDX     0,X
        STX     BLOCKMOVEX        SAVE 1ST AND 2ND BYTES
        ;LDX    TOPOINTER       NO STORE 4 BYTES TO "TO" AREA
        LDX     TOPOINTER
        ;STD    2,X     STORE 2ND AND 3RD BYTE
        STAB      (2)+1,X
        STAA      2,X
        ;LDD    BLOCKMOVEX
        LDAB      BLOCKMOVEX+1
        LDAA      BLOCKMOVEX
        ;STD    ,X      STORE 1ST AND SECOND BYTES
        STAB      (0)+1,X
        STAA      0,X
        LDAB      TOPOINTER+1     ADVANCE POINTERS BY 4 BYTES
        ADDB      #4
        STAB      TOPOINTER+1
        BCC        *+5
        ;INC     TOPOINTER
        INC      TOPOINTER
        LDAB      FROMPOINTER+1
        ADDB      #4
        STAB      FROMPOINTER+1
        BCC        *+5
        ;INC     FROMPOINTER
        INC      FROMPOINTER
        ;LDX    FROMPOINTER     SET UP FOR NEXT LOOP ITERATION
        LDX     FROMPOINTER
        SUBB      LIMIT+1 MULTIPLE OF 16 BYTES LEFT TO MOVE ?
        BITB      #%00001111      ....?
        BNE      BLOCKMOVEDOWN4    B/ NOPE, MOVE ANOTHER 4 BYTES
BLOCKMOVEDOWNB     CPX      LIMIT   YES, ALL DONE MOVING BYTES ?
        BEQ      BLOCKMOVEDOWND    B/ YES, LEAVE!
*
*       MOVE 16 BYTES AT A TIME UNTIL TRANSFER IS COMPLETE
*       COPY RATE IS 17.1 uS. PER BYTE
*
BLOCKMOVEDOWN16   EQU     *
        ;LDD    0+2,X   COPY 1ST 4 BYTES
        LDAB      (0+2)+1,X
        LDAA      0+2,X
        ;LDX    0+0,X
        LDX     0+0,X
        STX     BLOCKMOVEX
        ;LDX    TOPOINTER
        LDX     TOPOINTER
        ;STD    0+2,X
        STAB      (0+2)+1,X
        STAA      0+2,X
        ;LDD    BLOCKMOVEX
        LDAB      BLOCKMOVEX+1
        LDAA      BLOCKMOVEX
        ;STD    0+0,X
        STAB      (0+0)+1,X
        STAA      0+0,X
        ;LDX    FROMPOINTER     COPY 2ND GROUP OF 4 BYTES
        LDX     FROMPOINTER
        ;LDD    4+2,X
        LDAB      (4+2)+1,X
        LDAA      4+2,X
        ;LDX    4+0,X
        LDX     4+0,X
        STX     BLOCKMOVEX
        ;LDX    TOPOINTER
        LDX     TOPOINTER
        ;STD    4+2,X
        STAB      (4+2)+1,X
        STAA      4+2,X
        ;LDD    BLOCKMOVEX
        LDAB      BLOCKMOVEX+1
        LDAA      BLOCKMOVEX
        ;STD    4+0,X
        STAB      (4+0)+1,X
        STAA      4+0,X
        ;LDX    FROMPOINTER     COPY 3RD GROUP OF 4 BYTES
        LDX     FROMPOINTER
        ;LDD    8+2,X
        LDAB      (8+2)+1,X
        LDAA      8+2,X
        ;LDX    8+0,X
        LDX     8+0,X
        STX     BLOCKMOVEX
        ;LDX    TOPOINTER
        LDX     TOPOINTER
        ;STD    8+2,X
        STAB      (8+2)+1,X
        STAA      8+2,X
        ;LDD    BLOCKMOVEX
        LDAB      BLOCKMOVEX+1
        LDAA      BLOCKMOVEX
        ;STD    8+0,X
        STAB      (8+0)+1,X
        STAA      8+0,X
        ;LDX    FROMPOINTER     COPY 4TH GROUP OF 4 BYTES
        LDX     FROMPOINTER
        ;LDD    12+2,X
        LDAB      (12+2)+1,X
        LDAA      12+2,X
        ;LDX    12+0,X
        LDX     12+0,X
        STX     BLOCKMOVEX
        ;LDX    TOPOINTER
        LDX     TOPOINTER
        ;STD    12+2,X
        STAB      (12+2)+1,X
        STAA      12+2,X
        ;LDD    BLOCKMOVEX
        LDAB      BLOCKMOVEX+1
        LDAA      BLOCKMOVEX
        ;STD    12+0,X
        STAB      (12+0)+1,X
        STAA      12+0,X
        LDAB      TOPOINTER+1     ADVANCE POINTERS BY 16 BYTES
        ADDB      #16
        STAB      TOPOINTER+1
        BCC        *+5
        ;INC     TOPOINTER
        INC      TOPOINTER
        LDAB      FROMPOINTER+1
        ADDB      #16
        STAB      FROMPOINTER+1
        BCC        *+5
        ;INC     FROMPOINTER
        INC      FROMPOINTER
        ;LDX    FROMPOINTER     CHECK TO SEE IF COPY IS COMPLETE
        LDX     FROMPOINTER
        CPX      LIMIT   AT LIMIT OF "FROM" REGION ?
        BNE      BLOCKMOVEDOWN16   B/ NO, GO MOVE ANOTHER 16 BYTES
BLOCKMOVEDOWND    ; BLOCK TRANSFER IS COMPLETE!
        ;PULD           RESTORE DCBPOINTER
        PULA
        PULB
        ;STD    DCBPOINTER
        STAB      DCBPOINTER+1
        STAA      DCBPOINTER
        RTS
        PAGE
        ELSE    (M6809)
        PAGE
BLOCKMOVE ; ENTRY POINT TO BLOCKMOVE FOR '09, PRESERVES DCBPOINTER
*       BLOCKMOVEDOWN -- 6809 VERSION (5 uS./byte, average)
*       (X) = from address
*       (Y) = to address
*       (D) = count (0..65535)
*       On exit, (X) has old (X)+(D); (Y) has old (Y)+(D)
*       ASSUMES THAT COPY-TO REGION DOES NOT OVERLAP COPY-FROM REGION,
*       OR THAT "FROM" >= "TO".
*
BLOCKMOVEDOWN
        LEAU     D,X     COMPUTE END OF TRANSFER ADDRESS
        PSHS    U       SAVE ON STACK
        BITB      #1      TAKE CARE OF "ODD" BYTE
        BEQ      BLOCKMOVEDOWN0
        LDAA      ,X+     MOVE ODD BYTE
        STAA      ,Y+     THEN WE CAN IGNORE LSB OF D
BLOCKMOVEDOWN0
        COMB              MAP BITS 3-1: 0->,1->6,...,N->7-N
        ANDB      #%1110  BRANCH INTO COPY LOOP...
        ASLB              AT PROPER POINT
        LDU     #BLOCKMOVEDOWNLOOP+4
        ;JMP    B,U      MULTIPLE OF 16 TAKES US TO CMPX 0,S
        JMP     B
        PAGE
BLOCKMOVEDOWNLOOP
        ;LDD    ,X++    (CAN'T GET HERE DIRECTLY FROM JMP B,U)
        LDAB      (0)+1,X
        LDAA      0,X
        INX
        INX
        ;STD    ,Y++
        STAB      +1
        STAA      
        ;LDD    ,X++    1110
        LDAB      (0)+1,X
        LDAA      0,X
        INX
        INX
        ;STD    ,Y++
        STAB      +1
        STAA      
        ;LDD    ,X++    1100
        LDAB      (0)+1,X
        LDAA      0,X
        INX
        INX
        ;STD    ,Y++
        STAB      +1
        STAA      
        ;LDD    ,X++    1010
        LDAB      (0)+1,X
        LDAA      0,X
        INX
        INX
        ;STD    ,Y++
        STAB      +1
        STAA      
        ;LDD    ,X++    1000
        LDAB      (0)+1,X
        LDAA      0,X
        INX
        INX
        ;STD    ,Y++
        STAB      +1
        STAA      
        ;LDD    ,X++    0110
        LDAB      (0)+1,X
        LDAA      0,X
        INX
        INX
        ;STD    ,Y++
        STAB      +1
        STAA      
        ;LDD    ,X++    0100
        LDAB      (0)+1,X
        LDAA      0,X
        INX
        INX
        ;STD    ,Y++
        STAB      +1
        STAA      
        ;LDD    ,X++    0010
        LDAB      (0)+1,X
        LDAA      0,X
        INX
        INX
        ;STD    ,Y++
        STAB      +1
        STAA      
        CMPX     0,S     0000
        BNE      BLOCKMOVEDOWNLOOP
        ;LEAS    2,S     POP LIMIT ADDRESS
        IF      2<0
        RPT     -2
        DES
        ELSE
        RPT     2
        INS
        FIN
        RTS
        FIN     M6800!M6801
        PAGE     CLOCK TICK AND TIMEOUT ROUTINES
*       TASKING AND INTERRUPT HANDLING FOR SDOS
*
*       CLOCKTICKED -- BUMPS SDOS:CLOCK
*       ADJUSTS THE DATE IF NEEDED
*       WAKES UP TIMEOUT TASK
*       INVOKED AS EXIT OF SOME INTERRUPT ROUTINE
*       (A) ON ENTRY = # CLOCK TICKS (60THS SEC) ELAPSED SINCE LAST CALL
*       RUNS WITH INTERRUPTS DISABLED
*
CLOCKTICKED        EQU     *
        TAB
        ADDA      CLOCKTICKEDEVENT   SET UP WAKEUP COUNT FOR TIMEOUT TASK
        STAA      CLOCKTICKEDEVENT
        ADDB      CODE+SDOS:CLOCK+2  ADJUST TIME-OF-DAY...
        STAB      CODE+SDOS:CLOCK+2  AS MEASURED IN 60THS OF A SECOND
        BCC        CLOCKTICK1 B/ DON'T NEED TO UPDATE UPPER 2 BYTES
        ;LDX    CODE+SDOS:CLOCK    UPDATE UPPER 2 BYTES
        LDX     CODE+SDOS:CLOCK
        INX
        STX     CODE+SDOS:CLOCK
CLOCKTICK1 ; DID WE JUST PASS MIDNITE ?
        LDAA      CODE+SDOS:CLOCK+1  IS CODE+SDOS:CLOCK - "MIDNITE" >= 0 ?
        ;SUBD    #6656   (6656 = 5184000 MOD 65536; TRY IT!)
        SUBB      #(6656)&$FF
        SBCA       #(6656)/256
        LDAA      CODE+SDOS:CLOCK
        SBCA       #79     ( = 5184000 / 65536 )
        BCS       CLOCKTICKEXIT      B/ NOT MIDNITE, GET OUT QUICK!
        ;LDX    #0      JUST PAST MIDNITE, RESET THE CLOCK
        LDX     #0
        STX     CODE+SDOS:CLOCK    SET CLOCK:=CLOCK MOD (1 DAY)
        STAB      CODE+SDOS:CLOCK+2
        LDAA      CODE+SDOS:DAY     INCREMENT DAY NUMBER
        ADDA      #1      BECAUSE "INCA" DOESN'T WORK ON BCD STUFF
        DAA
        STAA      CODE+SDOS:DAY
        LDAA      CODE+SDOS:MONTH  EXCEED # DAYS ALLOWED FOR THIS MONTH ?
        BSR      BCDTOBIN   CAUSE I DON'T THINK GOOD IN BCD
        STAA      DAYSPERMONTHX+1  (GO LOOK UP IN TABLE)
        ;LDX    DAYSPERMONTHX
        LDX     DAYSPERMONTHX
        LDAA      CODE+SDOS:DAY     (GET CURRENT DAY NUMBER)
        ;CMPA     (DAYSPERMONTH-1)&$FF,X   (COMPARE TO # DAYS ALLOWED IN THIS MONTH)
        CMPA      (DAYSPERMONTH-1)&$FF,X
        BLS      CLOCKTICKEXIT      B/ LOWER, BYE!
        ;CMPA     #$29    # DAYS FOR THIS MONTH EXCEEDED
        CMPA      #$29
        BNE      CLOCKTICK2 B/ MUST SWITCH TO NEXT MONTH
        LDAA      CODE+SDOS:YEAR    I HATE LEAP YEAR STUFF; IS THIS A LEAP YEAR ?
        BSR      BCDTOBIN   NEED I SAY MORE ?
        BITA      #3      IT MAKES THE "A MULTIPLE OF 4" TEST EASY
        BEQ      CLOCKTICKEXIT      B/ FEB 29 IS LEGAL
CLOCKTICK2 ; TIME FOR NEW MONTH
        LDAA      #1      SET DAY TO "1ST OF MONTH"
        STAA      CODE+SDOS:DAY
        ADDA      CODE+SDOS:MONTH  BUMP MONTH
        DAA               IN DECIMAL
        STAA      CODE+SDOS:MONTH
        ;CMPA     #$12    BET YOU CAN'T GUESS WHAT THIS MAGIC CONSTANT IS...
        CMPA      #$12
        BLS      CLOCKTICKEXIT      B/ MONTH IS OK, BYEBYE!
        LDAA      #1      NEW YEAR STRUCK, SET MONTH TO "JANUARY"
        STAA      CODE+SDOS:MONTH
        ADDA      CODE+SDOS:YEAR    BUMP THE YEAR
        DAA               ALSO IN DECIMAL (WHY'D I PICK THAT??)
        STAA      CODE+SDOS:YEAR    THAT'S ALL YOU'LL GET ME TO DO!
CLOCKTICKEXIT      EQU     *
        ;JMP    FORCESCHEDULE     TO FORCE THE TIMEOUT TASK TO RUN
        JMP     FORCESCHEDULE
*
*       BCDTOBIN -- CONVERTS BCD NUMBER IN (A) TO BINARY EQUIVALENT IN (A)
*
BCDTOBIN   EQU     *
        TAB
        ANDB      #$F     = RIGHT DIGIT
        SBA
        PSHB
        LSRA             = LEFT DIGIT * 8
        TAB
        LSRA             = LEFT DIGIT * 4
        LSRA             = LEFT DIGIT * 2
        ABA                = LEFT DIGIT * 10
        PULB             ADD RIGHT DIGIT
        ABA                = LEFT DIGIT * 10 + RIGHT DIGIT
        RTS             LOOK MA! A SUBR OF ALL(MOST) SINGLE BYTE INSTRUCTIONS!

DAYSPERMONTH     FCB       $31,$28,$31,$30,$31,$30,$31,$31,$30,$31,$30,$31
        PAGE
*       TIMEOUT TASK CODE
*       FOR EACH WAKEUP, PROCESS NEXT TIMEOUT LIST ELEMENT
*       SUBTRACTS 1 TICK FOR EACH TIMEOUT LIST ELEMENT FROM TIMEOUT:FUSE
*       IF FUSE GETS ZEROED (OR GOES NEGATIVE), TRIGGERS ASSOCIATED TIMEOUT ROUTINE
*       ALL LIST ELEMENT UPDATING IS DONE WITH INTERRUPTS DISABLED...
*       TO PREVENT NASTY TIMING SPLINTERS
*
TIMEOUTTASKBORED  EQU     *
        ;LDX    #CLOCKTICKEDEVENT  WAKE ME UP SOMEDAY
        LDX     #CLOCKTICKEDEVENT
        ;JSR    WAITEVENT$       ZZZZZZZ....
        JSR     WAITEVENT$
TIMEOUTTASK      EQU     *
        ;LDX    CODE+SDOS:CONFIGURATION    START AT TOP OF TIMEOUT LIST
        LDX     CODE+SDOS:CONFIGURATION
        ;LDX    CNFG:TIMEOUTLIST,X
        LDX     CNFG:TIMEOUTLIST,X
*       BEQ      TIMEOUTTASKBORED  B/ NO TIMEOUT LIST
*       ASSERT: TIMEOUT LIST IS *NOT* EMPTY!
TIMEOUTTASKL     ; PROCESS TIMEOUT LIST ELEMENT
        STX     TIMEOUTLEPTR    SET UP LIST ELEMENT POINTER
        ;LDX    #TIMEOUTLEH     FIRE UP THE LIST ELEMENT HANDLER
        LDX     #TIMEOUTLEH
        ;JSR    STARTIO$
        JSR     STARTIO$
        page
*
*       The following code is the secondary SDOS checksum check.
*       Its purpose is to detect that the first checksum routine has
*       been tampered with, and to blow up unpredictably when this occurs.
*
        ;ldx    exitscanptr     pick up place where we left off last
        LDX     exitscanptr
        ;ldb    exitpartialchksum       get partial checksum as of last round
        LDAB      exitpartialchksum
        aslb            do 1 step of incremental checksum check
        adcb    15,x
        ;stb    exitpartialchksum       save partial checksum value
        STAB      exitpartialchksum
        inx             bump pointer for next round
        cpx     #exitchksumend-15       reached end of area to be checksummed?
        bne     secondarychecksum1      b/ not yet
        ;ldx    #exitchksumbase-15      yes, restart pointer from beginning
        LDX     #exitchksumbase-15
*       Assert: exitpartialchksum is zero here (if EXIT not tampered)
        ;ZZZ 	addb    Usertasktcb+tcb:stack+1 add checksum value to user stack pointer
        nop
        nop
        nop
        ;ZZZ	stab    Usertasktcb+tcb:stack+1 which causes user to die mysteriously if <>0!
        nop
        nop
        nop
secondarychecksum1      ; end of secondary checksum code
        stx     exitscanptr     save scan pointer for next clock tick
*
*       NOW, FINISH PROCESSING THE CLOCK TICK
*
        ;LDX    #CLOCKTICKEDEVENT  WAKE ME UP WHEN THE SUN SHINES AGAIN
        LDX     #CLOCKTICKEDEVENT
        ;DEC     ,X      TO TAKE CARE OF THE CLOCK TICK WE JUST PROCESSED
        DEC      0,X
        ;JSR    WAITEVENT$       ZZZZZZ....
        JSR     WAITEVENT$
        ;LDX    TIMEOUTLEPTR    WAKE UP, SLEEPYHEAD!
        LDX     TIMEOUTLEPTR
        ;LDX    TIMEOUT:LINK,X  FIND NEXT TIMEOUT LIST ELEMENT
        LDX     TIMEOUT:LINK,X
        BNE      TIMEOUTTASKL     B/ NOT AT END OF LIST, GO PROCESS THIS ELEMENT
        BRA       TIMEOUTTASK      END OF LIST HIT, START AT TOP OF LIST
        PAGE
*       TIMEOUT LIST ELEMENT PROCESSOR
*       STARTED BY "STARTIO" CALL FROM TIMEOUT TASK
*
TIMEOUTLEH      EQU     *
        ;LDX    TIMEOUTLEPTR    NOTE: ALL INTERRUPTS ARE DISABLED HERE!
        LDX     TIMEOUTLEPTR
        ;LDD    TIMEOUT:FUSE,X  DO DOUBLE PRECISION DECREMENT
        LDAB      (TIMEOUT:FUSE)+1,X
        LDAA      TIMEOUT:FUSE,X
        ;BEQD    IORTI1  B/ THIS TIMEOUT LIST ELEMENT IS DE-FUSED
        BNE      MACRO:0030
        TSTB
        BEQ      IORTI1
MACRO:0030
        SUBB      NTIMEOUTBLKS     SUBTRACT # CLOCK TICKS THAT WILL PASS
        SBCA       #0      BEFORE WE GET BACK TO THIS LIST ELEMENT AGAIN
        BCS       TIMEOUTLEH3     B/ TIMED OUT!
        ;STD    TIMEOUT:FUSE,X  PERHAPS TIME OUT DID NOT OCCUR; STORE FUSE BACK
        STAB      (TIMEOUT:FUSE)+1,X
        STAA      TIMEOUT:FUSE,X
        ;BNED    IORTI1  B/ TIMEOUT DID NOT OCCUR
        BNE      IORTI1
        TSTB
        BNE      IORTI1
TIMEOUTLEH3     ; TIMEOUT OCCURRED
        ;CLR     TIMEOUT:FUSE,X  DEFUSE THIS LIST ELEMENT
        CLR      TIMEOUT:FUSE,X
        ;CLR     TIMEOUT:FUSE+1,X
        CLR      TIMEOUT:FUSE+1,X
        ;LDD    TIMEOUT:DCB,X     FETCH DCB POINTER FROM TIMEOUT BLOCK
        LDAB      (TIMEOUT:DCB)+1,X
        LDAA      TIMEOUT:DCB,X
        ;JMP    [TIMEOUT:ROUTINE,X]     AND GO TO THE DEVICE INTERRUPT ROUTINE
        LDX     TIMEOUT:ROUTINE,X
        JMP     0,X
*       IT WILL DO THE IORTI FOR US
        PAGE     *** TASK SCHEDULER ***
*       ASSERT: INTERRUPTS ARE OFF AND SDOS:STACKSWITCHED=:FF
*
TASKRTI  ;LDX    CODE+SDOS:CURRENTASK       QUICK EXIT FROM INTERRUPT BACK TO TASK
        LDX     CODE+SDOS:CURRENTASK
        LDS     TCB:STACK,X POINTS TO CONTEXT BLOCK; WE NEVER SAVED 0-7
FORCERTI ;JMP    INTRTI  EXIT FROM INTERRUPT ROUTINE
        JMP     INTRTI

FORCESCHEDULE     ; FORCE SCHEDULER TO LOOK AROUND AFTER INTERRUPT
* NOTE: 6809 DPR REGISTER IS UNDEFINED HERE!
        ;CLR     SURPRISE        SYSTEM STATE HAS CHANGED SIGNIFICANTLY
        CLR      SURPRISE
IORTI   ; SYSTEM STATE HAS NOT CHANGED SIGNIFICANTLY
        ;JSR    INTDISABLE        SO WE DON'T GET INTERRUPTED...
        JSR     INTDISABLE
*                       IF CODE+SDOS:STACKSWITCHED GOES TO -1!
IORTI1  ; ENTRY POINT FOR TIMEOUT LIST ELEMENT HANDLER
        ;DEC     CODE+SDOS:STACKSWITCHED     SCHEDULER OR INTERRUPT ROUTINE ALREADY ACTIVE ?
        DEC      CODE+SDOS:STACKSWITCHED
        BPL      FORCERTI YES, GO BACK TO IT...
        LDAA      SURPRISE        ANYTHING INTERESTING HAPPEN ?
        ORAA      DONTSTOPME      OR ARE WE IN TASK CRITICAL CODE ?
        BNE      TASKRTI  B/ NO, GO BACK TO TASK NOW
PUSH0TO7        ; SAVE LOCATIONS 0 TO 7 IN TCB
        ;INC     CODE+SDOS:STACKSWITCHED     REMEMBER THAT "STACKS ARE SWITCHED"
        INC      CODE+SDOS:STACKSWITCHED
*                       ASSERT: SDOS:STACKSWITCHED=0
        ;JSR    INTENABLE RE-ENABLE INTERRUPTS
        JSR     INTENABLE
        ;LDX    CODE+SDOS:CURRENTASK       BUT FIRST WE MUST SAVE THE REST OF THE TASK CONTEXT
        LDX     CODE+SDOS:CURRENTASK
        IF      M6809
        LDU     TCB:STACK,X SET DPR USED BY SCHEDULER TO LAST TASK DPR
        ;LDA     REG:DP,U
        LDAA      REG:DP
        ;TFR    A,DP
        TADP
        FIN
        ;LDD    $0              SAVE LOCATIONS 0-7
        LDAB      $0+1
        LDAA      $0
        ;STD    TCB:SCRATCHPAD+0,X
        STAB      (TCB:SCRATCHPAD+0)+1,X
        STAA      TCB:SCRATCHPAD+0,X
        ;LDD    $2
        LDAB      $2+1
        LDAA      $2
        ;STD    TCB:SCRATCHPAD+2,X
        STAB      (TCB:SCRATCHPAD+2)+1,X
        STAA      TCB:SCRATCHPAD+2,X
        ;LDD    $4
        LDAB      $4+1
        LDAA      $4
        ;STD    TCB:SCRATCHPAD+4,X
        STAB      (TCB:SCRATCHPAD+4)+1,X
        STAA      TCB:SCRATCHPAD+4,X
        ;LDD    $6
        LDAB      $6+1
        LDAA      $6
        ;STD    TCB:SCRATCHPAD+6,X
        STAB      (TCB:SCRATCHPAD+6)+1,X
        STAA      TCB:SCRATCHPAD+6,X
        PAGE
SCHEDLDS ; RESET TO BASE OF INTERRUPT STACK
        LDS     INTERRUPTSTACK    USE INTERRUPT STACK FOR SCHEDULER'S STACK
SCHEDTOP ; START SCANNING TCB LIST
        LDAA      #1      WE'RE STARTING OVER, NO BAD DECISIONS
        STAA      SURPRISE        "NO SURPRISES HAVE OCCURRED"
        ;LDX    CODE+SDOS:CONFIGURATION    GET POINTER TO LIST OF TASKS
        LDX     CODE+SDOS:CONFIGURATION
        ;LDX    CNFG:TASKQUEUE,X
        LDX     CNFG:TASKQUEUE,X
SCHEDLOOP        EQU     *
        STX     CODE+SDOS:CURRENTASK       SAVE POINTER TO THIS TCB IN CASE HE'S READY
        BSR      SCHEDTEST        GO TEST WAKE UP CONDITION
        BNE      JUSTREADY        B/ TASK JUST WENT READY!
        ;LDX    CODE+SDOS:CURRENTASK       GET TCB ADDRESS
        LDX     CODE+SDOS:CURRENTASK
        ;LDX    TCB:LNK,X FOLLOW TO NEXT TCB
        LDX     TCB:LNK,X
        BNE      SCHEDLOOP        LOOP IF NOT END OF LIST
        BRA       SCHEDTOP ELSE START PROCESSING THE LIST AGAIN

SCHEDTEST        ; GET PARAMETER AND GO TEST WAKE-UP CONDITION
        ;LDD    TCB:COND,X PUSH WAKE-UP SUBROUTINE ADDRESS ONTO THE STACK
        LDAB      (TCB:COND)+1,X
        LDAA      TCB:COND,X
        ;PSHD
        PSHB
        PSHA
        ;LDX    TCB:PARAM,X GET PARAMETER FOR WAKE-UP ROUTINE
        LDX     TCB:PARAM,X
        RTS             AND PASS CONTROL TO IT (RETURN ADDRESS PUSHED BY BSR)
**** NOTE: DPR NOT DEFINED ON ENTRY TO WAKE-UP CONDITION SUBROUTINE ****
        PAGE
JUSTREADY        ; TASK JUST BECAME READY
        ;LDX    CODE+SDOS:CURRENTASK       GET ADDRESS OF TCB THAT JUST WENT READY
        LDX     CODE+SDOS:CURRENTASK
        LDAB      #EXECUTING/256   MARK TCB AS 'EXECUTING'
        STAB      TCB:COND,X SO INVOKING WAKE-UP ROUTINE...
        LDAB      #EXECUTING&$FF   WILL SPEED UP FURTHER DISPATCHES
        STAB      TCB:COND+1,X
        ;LDX    TCB:STACK,X GET TASK'S STACK POINTER
        LDX     TCB:STACK,X
        STAA      REG:A,X  SET TASK'S A REGISTER TO WAKE UP CODE
EXECUTING        ; TASK WAS IN EXECUTION WHEN STOPPED
        ;LDX    CODE+SDOS:CURRENTASK       SWITCH TO TASK'S STACK
        LDX     CODE+SDOS:CURRENTASK
        IF      M6809
        LDU     TCB:STACK,X SELECT DPR FOR PAGE ZERO SCRATCH
        ;LDA     REG:DP,U
        LDAA      REG:DP
        ;TFR    A,DP
        TADP
        FIN
        ;LDD    TCB:SCRATCHPAD+0,X    RESTORE LOCATIONS 0 TO 7
        LDAB      (TCB:SCRATCHPAD+0)+1,X
        LDAA      TCB:SCRATCHPAD+0,X
        ;STD    $0
        STAB      $0+1
        STAA      $0
        ;LDD    TCB:SCRATCHPAD+2,X
        LDAB      (TCB:SCRATCHPAD+2)+1,X
        LDAA      TCB:SCRATCHPAD+2,X
        ;STD    $2
        STAB      $2+1
        STAA      $2
        ;LDD    TCB:SCRATCHPAD+4,X
        LDAB      (TCB:SCRATCHPAD+4)+1,X
        LDAA      TCB:SCRATCHPAD+4,X
        ;STD    $4
        STAB      $4+1
        STAA      $4
        ;LDD    TCB:SCRATCHPAD+6,X
        LDAB      (TCB:SCRATCHPAD+6)+1,X
        LDAA      TCB:SCRATCHPAD+6,X
        ;STD    $6
        STAB      $6+1
        STAA      $6
        LDAA      SURPRISE        DID WE GET SURPRISED ?
        BEQ      SCHEDLDS YES, GO SCHEDULE AGAIN!
        ;JSR    INTDISABLE        INTERRUPTS OFF SO WE CAN DIDDLE WITHOUT TROUBLE
        JSR     INTDISABLE
        LDS     TCB:STACK,X SWITCH TO USER'S STACK
        ;DEC     CODE+SDOS:STACKSWITCHED     FLAG "USING TASK'S STACK, NOT INTERRUPT STACK"
        DEC      CODE+SDOS:STACKSWITCHED
*                       ASSERT: SDOS:STACKSWITCHED=:FF
        ;JMP    INTRTI  AND PICK UP EXECUTION OF USER TASK
        JMP     INTRTI
        PAGE
WAITEVENTCOND     ; WAIT FOR EVENT CONDITIONAL WAKE-UP ROUTINE
        LDAA      ,X      FETCH THE EVENT (A BYTE) OF INTEREST
WAITEVENTCONDRTS
        RTS             RETURN CC <> 0 IF BYTE IS NON-ZERO
*
*       WAITEVENT$ -- WAIT FOR EVENT (X) TO GO NON-ZERO
*
WAITEVENT$       EQU     *
        LDAA      ,X      HAS EVENT ALREADY OCCURRED ?
        BNE      WAITEVENTCONDRTS  B/ YES, AVOID INVOKING THE SCHEDULER!
        ;LDD    #WAITEVENTCOND    GET ADDRESS OF CONDITIONAL TEST ROUTINE
        LDAB      #(WAITEVENTCOND)&$FF
        LDAA      #(WAITEVENTCOND)/256
*       BSR      WAIT$
*       RTS
*
*       WAIT$ -- MAKE TASK WAIT FOR WAKEUP CONDITION
*       (A,B) POINTS TO WAKE UP CONDITION TEST SUBROUTINE...
*       WHICH IS CONTINUALLY CALLED BY THE SCHEDULER
*       (X) CONTAINS PARAMETER TO BE PASSED IN (X) TO WAKE-UP TEST
*       A NON-ZERO CONDITION CODE ON EXIT FROM WAKE-UP ROUTINE...
*       CAUSES THE TASK TO BE WOKEN; (A) FROM WAKE-UP ROUTINE...
*       WILL BE PASSED TO TASK IN (A) REGISTER
*       WAKE UP SUBROUTINE IS NOT CALLED ANYMORE.
*       ALL REGISTERS DESTROYED; SCRATCHPAD PRESERVED
*
WAIT$    ; (X) POINT TO WAIT SUBROUTINE FOR TASK
        ;INC     DONTSTOPME      SO WE COME RIGHT BACK AFTER INTERRUPT
        INC      DONTSTOPME
*                       ASSERT: DONTSTOPME=1
        STX     SCHEDX   SAVE PARAMETER OF WAKE UP ROUTINE
        ;LDX    CODE+SDOS:CURRENTASK       REMEMBER ADDRESS OF WAKE-UP SUBROUTINE
        LDX     CODE+SDOS:CURRENTASK
        ;STD    TCB:COND,X
        STAB      (TCB:COND)+1,X
        STAA      TCB:COND,X
        ;LDD    SCHEDX   SAVE PARAMETER FOR WAKE-UP SUBROUTINE
        LDAB      SCHEDX+1
        LDAA      SCHEDX
        ;STD    TCB:PARAM,X IN TCB
        STAB      (TCB:PARAM)+1,X
        STAA      TCB:PARAM,X
        IF      M6800!M6801
        ;PSHD           TURN RETURN ADDRESS INTO A CONTEXT BLOCK
        PSHB
        PSHA
        CLRA              MAKE A ZERO TO STORE
        PSHA             A ZERO FOR B REGISTER
        PSHA             A ZERO FOR THE A REGISTER
        PSHA             A ZERO CONDITION CODE BYTE
        ELSE    (M6809)
        CLI              MAKE SURE TASK INTERRUPTS ARE ON WHEN HE IS AWOKEN AGAIN
        PSHS    U,Y,X,DP,B,A,CC
        FIN
        ;JSR    INTDISABLE        SHUT DOWN THE WORLD...
        JSR     INTDISABLE
*                       SO WE CAN SWITCH STACKS SAFELY
        STS     TCB:STACK,X SAVE TASK'S STACK POINTER
        LDS     INTERRUPTSTACK    AND SWITCH TO THE INTERRUPT STACK
        ;DEC     DONTSTOPME      SWITCH FROM TASK CRITICAL MODE...
        DEC      DONTSTOPME
*                       TO "INTERRUPT" MODE (STACKSWITCHED WILL SAVE US!)
        ;JMP    PUSH0TO7        SAVE TEMPS AND THEN SCHEDULE SOME OTHER TASK
        JMP     PUSH0TO7
*       STARTIO$ -- (X) POINTS TO INTERRUPT ROUTINE ADDRESS
*       SIMULATES AN I/O INTERRUPT AND TRANSFERS CONTROL TO (X)
*       ALL REGISTERS DESTROYED EXCEPT (A,B) WHICH ARE PASSED TO INTERRUPT ROUTINE
*       USED TO START AN INTERRUPT ROUTINE UP; CALLABLE ONLY BY TASK LEVEL ROUTINES
*
STARTIO$ EQU     *
        IF      M6800!M6801
        ;JSR    INTDISABLE        DISABLE INTERRUPTS
        JSR     INTDISABLE
        STX     SCHEDX   SAVE INTERRUPT ROUTINE ADDRESS
        DES             PUSH A GARBAGED X REGISTER
        DES
        ;PSHD           PUSH D REGISTER [NOTE: (D) IS PASSED TO ROUTINE INVOKED BY STARTIO!]
        PSHB
        PSHA
        DES             RESERVE SPACE FOR CC BITS ON STACK
        TSX             ZERO CC BITS (ENABLING INTERRUPTS ON RETURN)
        ;CLR     0,X
        CLR      0,X
        ;INC     CODE+SDOS:STACKSWITCHED     FLAG 'IN AN INTERRUPT ROUTINE'
        INC      CODE+SDOS:STACKSWITCHED
        ;LDX    CODE+SDOS:CURRENTASK       LEAVE TCB:COND = "EXECUTING"
        LDX     CODE+SDOS:CURRENTASK
        STS     TCB:STACK,X AND SWITCH TO THE INTERRUPT STACK
        LDS     INTERRUPTSTACK    ...
        ;JMP    [SCHEDX] GO TO INTERRUPT ROUTINE ADDRESS
        LDX     SCHEDX
        JMP     0,X
        ELSE    (M6809)
        ;JSR    INTDISABLE        DISABLE INTERRUPTS
        JSR     INTDISABLE
        PSHS    U,Y,X,DP,B,A      PUSH REST OF CONTEXT BLOCK
        LDAA      #$80    = CC BYTE WITH "ENTIRE CONTEXT ON STACK" BIT SET
        PSHA
        ;LDA     1,S     RESTORE (D) TO ENTRY VALUE
        TSX
        LDAA      1,X
        ;INC     CODE+SDOS:STACKSWITCHED     FLAG 'IN AN INTERRUPT ROUTINE'
        INC      CODE+SDOS:STACKSWITCHED
        LDU     CODE+SDOS:CURRENTASK       LEAVE TCB:COND = "EXECUTING"
        STS     TCB:STACK,U AND SWITCH TO THE INTERRUPT STACK
        LDS     INTERRUPTSTACK    ...
        ;JMP    ,X      GO TO INTERRUPT ROUTINE ADDRESS
        JMP     0,X
        FIN

IOINTERRUPT     ; IO INTERRUPT GOES HERE FIRST!
        ;INC     CODE+SDOS:STACKSWITCHED     BUMP NUMBER OF NESTED INTERRUPTS
        INC      CODE+SDOS:STACKSWITCHED
        BNE      IOINTJ  B/ ALREADY SWITCHED TO INTERRUPT STACK
        ;LDX    CODE+SDOS:CURRENTASK       SWITCH TO SCHEDULER'S STACK
        LDX     CODE+SDOS:CURRENTASK
        STS     TCB:STACK,X SAVE TASK'S STACK IN HIS TCB
        LDS     INTERRUPTSTACK    GET THE SCHEDULER'S STACK INSTEAD
IOINTJ ; JUMP TO INTERRUPT ROUTINE
        IF      M6809
        ;LDA     #$FF    SET DPR TO FIXED CONSTANT
        LDAA      #$FF
        ;TFR    A,DP
        TADP
        FIN
        ;JMP    JMPIOINT        GO DEAL WITH I/O INTERRUPT
        JMP     JMPIOINT

PATCHSPACE  RPT     30     PATCH SPACE
        SWI
        PAGE
SDOS:END        EQU     *

ACTSIZE   EQU     *-CODE   ACTUAL RESIDENT SDOS SIZE
        IF      ACTSIZE>>SDOS:ESTSIZE
        ?SDOS TOO BIG FOR MEMORY SIZE SPECIFIED
        FIN
        END

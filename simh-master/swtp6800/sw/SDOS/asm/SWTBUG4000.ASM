; * NAM SWTBUG
; * VERSION 1.00

; * OPT PAG
; ****************************************************
; * REPLACEMENT FOR MIKBUG ROM
; * FOR SWTPC 6800 COMPUTER SYSTEM
; * COPYRIGHT 1977
; * SOUTHWEST TECHNICAL PROD. CORP.
; * AUGUST, 1977
; ****************************************************
; * Modified by Roberto Sancho Jul/2022
; * Relocated to assemble at $4000, ram at $4800, ACIA at $FF04
; * to be used in Swtpc 64k hack to load SDOS at BE00-F000
; * (regular swtbuf resides at E000 and is overwritten)

   ORG $4800
 
IRQ RMB 2 		; IRQ POINTER
BEGA RMB 2 		; BEGINNING ADDR PNCH
ENDA RMB 2 		; ENDING ADDR PNCH
NMI RMB 2 		; NMI INTERRUPT VECTOR
SP RMB 1 		; S HIGH
   RMB 1 		; S LOW
PORADD RMB 2 		; PORT ADDRESS
PORECH RMB 1 		; ECHO ON/OFF FLAG
XHI RMB 1 		; XREG HIGH
XLOW RMB 1 		; XREG LOW
CKSM RMB 1 		; CHECKSUM
XTEMP RMB 2 		; X-REG TEMP STGE
SWIJMP RMB 2 		; SWI JUMP VECTOR
TW EQU 		$4844 	; TEMPORARY STORAGE
TEMP EQU 	$4846 	; TEMPORARY STORAGE
BYTECT EQU 	$4847 	; BYTECT AND MCONT TEMP.
CTLPOR EQU 	$FF04 	; CONTROL PORT ADDRESS
PROM EQU $C000 		; JUMP TO PROM ADDRESS
BKPT RMB 2 		; BREAKPOINT ADDRESS
BKLST RMB 1 		; BREAKPOINT DATA

 ORG $4842
 
STACK RMB 1 	; SWTBUG STACK

 ORG $4000

; *I/O INTERRUPT SEQUENCE
IRQV LDX IRQ
 JMP 0,X

; *JUMP TO USER PROGRAM
JUMP BSR BADDR
 JMP 0,X

CURSOR FCB $10,$16,4 ; CT-1024 CURSOR CONTROL

; *ASCII LOADING ROUTINE
LOAD JSR RDON 	; READER ON, DIS ECHO, GET P#
LOAD3 BSR INCH
 CMPA #'S
 BNE LOAD3 	; 1ST CHAR NOT S
 BSR INCH 	; READ CHAR
 CMPA #'9
 BEQ LOAD21
 CMPA #'1
 BNE LOAD3 	; 2ND CHAR NOT 1
 CLR CKSM 	; ZERO CHECKSUM
 BSR BYTE 	; READ BYTE
 SUBA #2
 STAA BYTECT 	; BYTE COUNT
; *BUILD ADDRESS
 BSR BADDR
; *STORE DATA
LOAD11 BSR BYTE
 DEC BYTECT
 BEQ LOAD15 	; ZERO BYTE COUNT
 STAA 0,X 	; STORE DATA
 CMPA 0,X 	; DATA STORED?
 BNE LOAD19
 INX
 BRA LOAD11
LOAD15 INC CKSM
 BEQ LOAD3
LOAD19 LDAA #'?
 BSR OUTCH
LOAD21 JMP RDOFF1

; *BUILD ADDRESS
BADDR BSR BYTE 	; READ 2 FRAMES
 STAA XHI
 BSR BYTE
 STAA XLOW
 LDX XHI 	; LOAD IXR WITH NUMBER
 RTS

; *INPUT BYTE (TWO FRAMES)
BYTE BSR INHEX 	; GET HEX CHAR
BYTE1 ASLA
 ASLA
 ASLA
 ASLA
 TAB
 BSR INHEX
 ABA
 TAB
 ADDB CKSM
 STAB CKSM
 RTS

OUTHL LSRA 	; OUT HEX LEFT BCD DIGIT
 LSRA
 LSRA
 LSRA
OUTHR ANDA #$F 	; OUT HEX RIGHT BCD DIGIT
 ADDA #$30
 CMPA #$39
 BLS OUTCH
 ADDA #$7

; *OUTPUT ONE CHAR
OUTCH JMP OUTEEE
INCH JMP INEEE

; *PRINT DATA POINTED TO BY X REG
PDATA2 BSR OUTCH
 INX
PDATA1 LDAA 0,X
 CMPA #4
 BNE PDATA2
 RTS 		; STOP ON HEX 04

C1 JMP SWTCTL

; *MEMORY EXAMINE AND CHANGE
CHANGE BSR BADDR
CHA51 LDX #MCL
 BSR PDATA1 	; C/R L/F
 LDX #XHI
 BSR OUT4HS 	; PRINT ADDRESS
 LDX XHI
 BSR OUT2HS 	; PRINT OLD DATA
 BSR OUTS 	; OUTPUT SPACE
ANOTH BSR INCH 	; INPUT CHAR
 CMPA #$20
 BEQ ANOTH
 CMPA #$D
 BEQ C1
 CMPA #'^ 	; UP ARROW?
 BRA AL3 	; BRANCH FOR ADJUSTMENT
 NOP

; *INPUT HEX CHARACTER
INHEX BSR INCH
INHEX1 SUBA #$30
 BMI C3
 CMPA #$9
 BLE IN1HG
 CMPA #$11
 BMI C3 	; NOT HEX
 CMPA #$16
 BGT C3 	; NOT HEX
 SUBA #7
IN1HG RTS

OUT2H LDAA 0,X 	; OUTPUT 2 HEX CHAR
OUT2HA BSR OUTHL ; OUT LEFT HEX CHAR
 LDAA 0,X
 INX
 BRA OUTHR 	; OUTPUT RIGHT HEX CHAR

OUT4HS BSR OUT2H ; OUTPUT 4 HEX CHAR + SPACE
OUT2HS BSR OUT2H ; OUTPUT 2 HEX CHAR + SPACE

OUTS LDAA #$20 	; SPACE
 BRA OUTCH 	; (BSR & TRS)

; *ENTER POWER ON SEQUENCE
START LDS #STACK
 BRA AL1 	; BRANCH FOR ADDRESS COMPATIBIL

; ********************************************
; *PART OF MEMORY EXAMINE AND CHANGE
AL3 BNE SK1
 DEX
 DEX
 STX XHI
 BRA CHA51
SK1 STX XHI
 BRA AL4

EOE3 BRA CONTRL ; BRANCH FOR MIKBUG EQUIV. CONT

AL4 CMPA #$30
 BCS CHA51
 CMPA #$46
 BHI CHA51
 BSR INHEX1
 JSR BYTE1
 DEX
 STAA 0,X 	; CHANGE MEMORY
 CMPA 0,X
 BEQ CHA51 	; DID CHANGE
 JMP LOAD19 	; DIDN'T CHANGE
C3 LDS SP
 BRA SWTCTL
; **************************************************

; *CONTINUE POWER UP SEQUENCE
AL1 STS SP 	; INIT TARGET STACK PTR.
 LDAA #$FF
 JSR SWISET
; *CONFIGURE FOR PIA AND SEE IF OK
 LDX #CTLPOR
 JSR PIAINI 	; INIT PIA
 LDAA 0,X
 CMPA 2,X
 BRA AL2

 BRA PRINT 	; BRA FOR BILOAD

AL2 BNE CONTRL

; *INITIALIZE AS ACIA
 LDAA #3 	; ACIA MASTER RESET
 STAA 0,X
 LDAA #$11
 STAA 0,X
 BRA CONTRL

; *ENTER FROM SOFTWARE INTERRUPT
SF0 NOP
SFE1 STS SP 	; SAVE TARGETS STACK POINTER
; *DECREMENT P COUNTER
 TSX
 TST 6,X
 BNE *+4
 DEC 5,X
 DEC 6,X
; *PRINT CONTENTS OF STACK.
PRINT LDX #MCL
 JSR PDATA1
 LDX SP
 INX
 BSR OUT2HS 	; COND CODES
 BSR OUT2HS 	; ACC B
 BSR OUT2HS 	; ACC A
 BSR OUT4HS 	; IXR
 BSR OUT4HS 	; PGM COUNTER
 LDX #SP
 JSR OUT4HS 	; STACK POINTER
SWTCTL LDX SWIJMP
 CPX #SF0
 BEQ CONTR1

CONTRL LDS #STACK ; SET CONTRL STACK POINTER
 LDX #CTLPOR 	; RESET TO CONTROL PORT
 STX PORADD
 CLR PORECH 	; TURN ECHO ON
 BSR SAVGET 	; GET PORT # AND TYPE
 BEQ POF1
 JSR PIAECH 	; SET PIA ECHO ON IF MP-C INTER
POF1 JSR PNCHOF ; TURN PUNCH OFF
 JSR RDOFF 	; TURN READER OFF
CONTR1 LDX #MCLOFF
 JSR PDATA1 	; PRINT DATA STRING
 BSR INEEE 	; READ COMMAND CHARACTER

; *COMMAND LOOKUP ROUTINE
LOOK LDX #TABLE
OVER CMPA 0,X
 BNE SK3
 JSR OUTS 	; SKIP SPACE
 LDX 1,X
 JMP 0,X
SK3 INX
 INX
 INX
 CPX #TABEND+3
 BNE OVER
SWTL1 BRA SWTCTL

; *SOFTWARE INTERRUPT ENTRY POINT
SFE LDX SWIJMP 	; JUMP TO VECTORED SOFTWARE INT
 JMP 0,X

S9 FCB 'S,'9,4 	; END OF TAPE

; ***************************************************
MTAPE1 FCB $D,$A,$15,0,0,0,'S,'1,4 ; PUNCH FORMAT

MCLOFF FCB $13 ; READER OFF
MCL FCB $D,$A,$15,0,0,0,'$,4

EIA5 BRA BILD 	; BINARY LOADER INPUT
; ***************************************************


; *NMI SEQUENCE
NMIV LDX NMI 	; GET NMI VECTOR
 JMP 0,X

INEEE BRA INEEE1

; *BYTE SEARCH ROUTINE
SEARCH JSR BADDR ; GET TOP ADDRESS
 STX ENDA
 JSR BADDR 	; GET BOTTOM ADDRESS
 JSR BYTE 	; GET BYTE TO SEARCH FOR
 TAB
OVE LDAA 0,X
 STX XHI
 CBA
 BEQ PNT
 BRA INCR1
PNT LDX #MCL
 JSR PDATA1
 LDX #XHI
 BRA SKP0
; ***************************************************

; *GO TO USER PROGRAM ROUTINE
GOTO RTI
OUTEEE BRA OUTEE1



; *SAVE IXR AND LOAD IXR WITH CORRECT
; *PORT NUMBER AND TEST FOR TYPE
SAVGET STX XTEMP ; STORE INDEX REGISTER
GETPT1 LDX PORADD
ISACIA PSHB
 LDAB 1,X
 CMPB 3,X
 PULB
 RTS
; ***************************************************

; *CONTINUATION OF SEARCH ROUTINE
SKP0 JSR OUT4HS
 LDX XHI
INCR1 CPX ENDA
 BEQ SWTL1
 INX
 BRA OVE

INEEE1 BSR INCH8 ; INPUT 8 BIT CHARACTER
 ANDA #%01111111 ; GET RID OF PARITY BIT
 RTS

BILD INS 	; FIX UP STACK WHEN USING
 INS 		; BINARY LOADER ON SWTPC TAPES
 INS

; *INPUT ONE CHAR INTO ACC B
INCH8 PSHB 	; SAVE ACC B
 BSR SAVGET 	; SAVE IXR, GET PORT# AND TYPE
 BNE IN1 	; INPUT FROM PIA IF NOT
 LDAA #$15 	; RECONFIG FOR 8 BIT, 1 SB
 STAA 0,X
ACIAIN LDAA 0,X
 ASRA
 BCC ACIAIN 	; NOT READY
 LDAA 1,X 	; LOAD CHAR
 LDAB PORECH
 BEQ ACIOUT 	; ECHO
 BRA RES 	; DON'T ECHO

; *OUTPUT ONE CHARACTER
OUTEE1 PSHB 	; SAVE ACC B
 BSR SAVGET
 BNE IOUT

ACIOUT LDAB #$11
 STAB 0,X
ACIOU1 LDAB 0,X
 ASRB
 ASRB
 BCC ACIOU1 	; ACIA NOT READY
 STAA 1,X 	; OUTPUT CHARACTER
RES PULB 	; RESTORE ACC B
 LDX XTEMP
 RTS

; *PIA INPUT ROUTINE
IN1 LDAA 0,X 	; LOOK FOR START BIT
 BMI IN1
 BSR DDL 	; DELAY HALF BIT TIME
 LDAB #4 	; SET DEL FOR FULL BIT TIME
 STAB 2,X
 ASLB 		; SET UP CNTR WITH 8
IN3 BSR DEL 	; WAIT ONE CHAR TIME
 SEC
 ROL 0,X
 RORA
 DECB
 BNE IN3
 BSR DEL 	; WAIT FOR STOP BIT
 LDAB PORECH 	; IS ECHO DESIRED?
 BEQ IOUT2 	; ECHO
 BRA RES 	; RESTORE IXR,ACCB
; *PIA OUTPUT ROUTINE
IOUT BSR DDL1 	; DELAY ONE HALF BIT TIME
 LDAB #$A 	; SET UP COUNTER
 DEC 0,X 	; SET START BIT
 BSR DE 	; START TIMER
OUT1 BSR DEL 	; DELAY ONE BIT TIME
 STAA 0,X 	; PUT OUT ONE DATA BIT
 SEC
 RORA 		; SHIFT IN NEXT BIT
 DECB 		; DECREMENT COUNTER
 BNE OUT1 	; TEST FOR 0
IOUT2 LDAB 2,X 	; TEST FOR STOP BITS
 ASLB 		; SHIFT BIT TO SIGN
 BPL RES 	; BRA FOR 1 STOP BIT
 BSR DEL 	; DELAY FOR STOP BITS
 BRA RES
DEL TST 2,X 	; IS TIME UP
 BPL DEL
DE INC 2,X 	; RESET TIMER
 DEC 2,X
 RTS

DDL CLR 2,X 	; HALF BIT DELAY
DDL1 BSR DE
 BRA DEL


; *OPTIONAL PORT ROUTINE
OPTL BSR INEEE1
 TAB
 CLR PORADD+1 	; SET I/O ADDRESS FOR $8000
 LDX PORADD
 BSR PIAINI 	; INITIALIZE PIA
 BSR PIAECH 	; SET ECHO
 LDX #TABLE1 	; P, L OR E
 TBA
 JMP OVER 	; LOOK AT TABLE FOR E, L OR P

PIAECH LDAA #$34 ; SET DDR
 STAA 3,X
 STAA 2,X
NOOPT RTS

; *PIA INITIALIZATION ROUTINE
PIAINI INC 0,X 	; SET DDR
 LDAA #$7
 STAA 1,X
 INC 0,X
 STAA 2,X
 RTS

; *MINIFLOPPY DISK BOOT
DISK CLR $8014
 BSR DELAY
 LDAB #$0B
 BSR RETT2
LOOP1 LDAB 4,X
 BITB #1
 BNE LOOP1
 CLR 6,X
 BSR RETURN
 LDAB #$9C
 BSR RETT2
 LDX #$2400
LOOP2 BITB #2
 BEQ LOOP3
 LDAA $801B
 STAA 0,X
 INX
LOOP3 LDAB $8018
 BITB #1
 BNE LOOP2
 JMP $2400
RETT2 STAB 4,X
RETURN BSR RETT1
RETT1 RTS

; *GENERAL PURPOSE DELAY LOOP
DELAY LDX #$FFFF
DELAY1 DEX
 CPX #$8014 	; STOP AT 8014
DUM BNE DELAY1
 RTS


; *CLRAR SCREEN FOR CT-1024 TYPE TERMINALS
CLEAR LDX #CURSOR
 JSR PDATA1
 BSR DELAY1 	; DELAY
RDOFF1 JSR RDOFF
 BRA C4

; *BREAKPOINT ENTERING ROUTINE
BREAK LDX #SF0
 CPX SWIJMP 	; BREAKPOINTS ALREADY IN USE?
 BEQ INUSE
 INX
BREAK0 BSR STO1
 JSR BADDR
 STX BKPT
 LDAA 0,X
 STAA BKLST
 LDAA #$3F
 STAA 0,X
 LDX #SF0
 BSR STO1
 JMP CONTR1
INUSE LDX BKPT
 LDAA BKLST
 STAA 0,X
 LDX #SFE1
 BRA BREAK0

SWISET STAA STACK+1 ; FIX POWER UP INTERRUPT
 LDX SWIJMP
 CPX #SF0
 BEQ STORTN
STO LDX #SFE1
STO1 STX SWIJMP
STORTN RTS

PUNCH1 BSR PUNCH
 BRA POFC4

; *FORMAT END OF TAPE WITH PGM. CTR. AND S9
PNCHS9 LDX #$A049
 STX ENDA
 DEX
 BSR PUNCH2
 LDX #S9
PDAT JSR PDATA1
POFC4 BSR PNCHOF
 BSR DELAY
C4 JMP CONTRL

RDON COM PORECH ; DISABLE ECHO FOR ACIA
 LDAA #$11 	; RON CHAR.
 LDAB #$20 	; STROBE CHAR
 BSR STROBE
 JSR ISACIA 	; CHECK TO SEE IF PIA
 BEQ RTNN
 LDAA #$3C 	; DISABLE PIA ECHO IF PIA
 STAA 3,X
RTNN RTS

RDOFF LDAA #$13 ; TURN READER OFF
 LDAB #$10
 BRA STROBE

PNCHON LDAA #$12
 LDAB #4
 BRA STROBE

PNCHOF LDAA #$14
 LDAB #$8

; *PIA STROBING ROUTINE FOR PUNCH/READ ON/OFF
STROBE JSR OUTCH
 JSR GETPT1
 BEQ RTN1
 LDAA #2
 ORAB #1
 BSR STR2
 BSR STR1
 LDAA #2
 LDAB #1
 STAB 0,X
 BSR STR2
STR1 LDAA #6
STR2 STAA 1,X
 STAB 0,X
RTN1 RTS

; *PUNCH FROM BEGINNING ADDRESS (BEGA) THRU
; *ENDING ADDRESS (ENDA)
PUNCH LDX BEGA
PUNCH2 STX TW
 BSR PNCHON
PUN11 LDAA ENDA+1
 SUBA TW+1
 LDAB ENDA
 SBCB TW
 BNE PUN22
 CMPA #16
 BCS PUN23
PUN22 LDAA #15
PUN23 ADDA #4
 STAA BYTECT
 SUBA #3
 STAA TEMP
; *PUNCH C/R L/F NULLS S1
 LDX #MTAPE1
 JSR PDATA1
 CLRB
; *PUNCH FRAME COUNT
 LDX #BYTECT
 BSR PUNT2 	; PUNCH 2 HEX CHARACTERS
; *PUNCH ADDRESS
 LDX #TW
 BSR PUNT2
 BSR PUNT2
; *PUNCH DATA
 LDX TW
PUN32 BSR PUNT2 ; PUNCH ONE BYTE
 DEC TEMP
 BNE PUN32
 STX TW
 COMB
 PSHB
 TSX
 BSR PUNT2 	; PUNCH CHECKSUM
 PULB 		; RESTORE STACK
 LDX TW
 DEX
 CPX ENDA
 BNE PUN11
RTN5 RTS

; *PUNCH 2 HEX CHAR, UPDATE CHECKSUM
PUNT2 ADDB 0,X
 JMP OUT2H 	; OUTPUT 2 HEX CHAR AND RTS

; *COMMAND TABLE
TABLE FCB 'G 	; GOTO
 FDB GOTO
 FCB 'Z 	;GOTO PROM
 FDB PROM
 FCB 'M 	; MEMORY EXAM AND CHANGE
 FDB CHANGE
 FCB 'F 	; BYTE SEARCH
 FDB SEARCH
 FCB 'R 	; REGISTER DUMP
 FDB PRINT
 FCB 'J		; JUMP
 FDB JUMP
 FCB 'C 	; CLEAR SCREEN
 FDB CLEAR
 FCB 'D 	; DISK BOOT
 FDB DISK
 FCB 'B 	; BREAKPOINT
 FDB BREAK
 FCB 'O 	; OPTIONAL PORT
 FDB OPTL
TABLE1 FCB 'P 	; ASCII PUNCH
 FDB PUNCH1
 FCB 'L 	; ASCII LOAD
 FDB LOAD
TABEND FCB 'E 	; END OF TAPE
 FDB PNCHS9

 ORG $43F8
 FDB IRQV 	; IRQ VECTOR
 FDB SFE 	; SOFTWARE INTERRUPT
 FDB NMIV 	; NMI VECTOR
 FDB START 	; RESTART VECTOR

 ; autostart relocated SWTBUG when loaded from regular SWTBUG
 ORG $A048
 FDB START
 END
